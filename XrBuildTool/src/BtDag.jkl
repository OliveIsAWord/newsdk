//
// Build the update DAG for the project.
//

#INCLUDE "Bt.hjk"

EXTERN BtSelectedTarget : ^BtTarget

FN BtConnectDagNodes (
    IN fromnode : ^BtDagNode,
    IN tonode : ^BtDagNode,
)

    // Allocate a DAG edge and connect the nodes.

    dagedge : ^BtDagEdge

    status := TlBumpAlloc (
        SIZEOF BtDagEdge, // bytes
        OUT dagedge, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate DAG edge", 0, 0, 0 )
    END

    dagedge^.From = fromnode
    dagedge^.To = tonode

    // Add to the in-edge list of the TO node, and the out-edge list of the
    // FROM node.

    TlInsertAtTailList (
        &tonode^.InEdgeListHead, // head
        &dagedge^.InEdgeListEntry, // entry
    )

    TlInsertAtTailList (
        &fromnode^.OutEdgeListHead, // head
        &dagedge^.OutEdgeListEntry, // entry
    )
END

FN BtCreateDagNode (
    IN target : ^BtTarget,
    IN type : BtDagNodeType,
) : ^BtDagNode

    // Build a DAG node.

    dagnode : ^BtDagNode

    status := TlBumpAlloc (
        SIZEOF BtDagNode, // bytes
        OUT dagnode, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate DAG node", 0, 0, 0 )
    END

    TlInitializeList ( &dagnode^.InEdgeListHead )
    TlInitializeList ( &dagnode^.OutEdgeListHead )

    dagnode^.Target = target
    dagnode^.Type = type

    RETURN dagnode
END

STRUCT BtProcessDirectoryContext
    Target : ^BtTarget,
    DagNode : ^BtDagNode,
    SourceDirPath : ^UBYTE,
END

FN (TlIterateDirectoryCallbackF) BtProcessDirectoryEntry (
    IN fullpath : ^UBYTE,
    IN filename : ^UBYTE,
    IN context : ^VOID,
)

    TlPrintString ( fullpath )
    TlPrintString ( "\n" )
    TlPrintString ( filename )
    TlPrintString ( "\n" )
END

FN BtBuildDagForTarget (
    IN target : ^BtTarget,
) : ^BtDagNode

    // Build the update sub-DAG for a target. If the target is up to date, we
    // return a NULLPTR.

    IF target^.CheckedForUpdate THEN
        RETURN target^.DagNode
    END

    dagnode : ^BtDagNode = NULLPTR

    dagtype : BtDagNodeType

    IF target^.HasFileName THEN
        dagtype = DAG_EXECUTABLE
    ELSE
        dagtype = DAG_NULL
    END

    // We have to recursively build DAG nodes for all of the targets depended
    // upon by this target. Any that return non-NULLPTR need to be added as out-
    // edges to this node (plus, we need to create the node if it hasn't been
    // created yet).

    dependhead := &target^.DependsOnListHead
    dependentry := dependhead^.Next

    WHILE dependentry != dependhead DO
        dependnode := BtBuildDagForTarget (
            (CONTAINEROF dependentry TO BtDependsListEntry.Entry)^.Target
        )

        IF dependnode THEN
            IF NOT dagnode THEN
                dagnode = BtCreateDagNode (
                    target, // target
                    dagtype, // type
                )
            END

            BtConnectDagNodes (
                dagnode, // fromnode
                dependnode, // tonode
            )
        END

        dependentry = dependentry^.Next
    END

    IF target^.HasFileName THEN
        // For all SOURCES subdirectories specified, we need to iterate their
        // contents. Each *.jkl and *.s file represent an object file in the
        // build cache that must exist and have a modification date later than
        // the source file, and later than that of all header files upon which
        // the source file depends (which are themselves cached). If this
        // invariant is violated, we have to create a node in the DAG and add an
        // out-edge from ourselves to it.

        // Note: Also check for *.c files when building for the C transpilation
        //       host.

        sourceshead := &target^.SourcesListHead
        sourcesentry := sourceshead^.Next

        context : BtProcessDirectoryContext

        context.Target = target
        context.DagNode = dagnode

        WHILE sourcesentry != sourceshead DO
            sourcesrcrd := CONTAINEROF sourcesentry TO BtSourcesRecord.Entry

            context.SourceDirPath = sourcesrcrd^.FilePathBuffer.Buffer

            status := TlIterateDirectory (
                sourcesrcrd^.FilePathBuffer.Buffer, // path
                &BtProcessDirectoryEntry, // callback
                &context, // context
            )

            IF status THEN
                TlInternalError ( "Failed to iterate directory", 0, 0, 0 )
            END

            sourcesentry = sourcesentry^.Next
        END

        dagnode = context.DagNode

        // If there still isn't a DAG node, check to make sure that the
        // executable actually does exist. If it doesn't, we need to create a
        // node for relinking.

        IF NOT dagnode THEN
            // TODO
        END
    END

    // Now cache the DAG node and return.

    target^.DagNode = dagnode
    target^.CheckedForUpdate = TRUE

    RETURN dagnode
END

FN BtBuildDag ()
    
    // The update DAG represents all of the 'objects' that need to be updated to
    // bring the selected target up to date. A node represents one of these
    // objects, and a directed edge leads FROM an object TO an object that must
    // be updated first.
    //
    // If an object is added to the DAG, all objects that depend upon it will
    // also be added to the DAG.
    //
    // An exhaustive list of objects and their associated actions are:
    //
    //   o An object code file is added to the DAG if:
    //      1. The object code file does not exist OR
    //      2. The associated source file was modified more recently than the
    //         object code file OR
    //      3. One of the source file's headers was modified more recently OR
    //      4. The header cache file for the source file does not exist.
    //
    //     The action to be taken is to recompile the source file, regenerating
    //     the header cache file in the process.
    //
    //   o An executable file is added to the DAG if one of its object files
    //     are, or if a target upon which it depends is added to the DAG.
    //
    //     The action to be taken is to relink the executable file.
    //
    //   o A null node is added to the DAG if a target without an output file
    //     must be updated. There is no action taken.

    dagroot := BtBuildDagForTarget ( BtSelectedTarget )

    IF NOT dagroot THEN
        TlPrintString ( "The target is already up to date.\n" )

        LEAVE
    END

    // Now we have a dependency DAG, and a list of leaf nodes (i.e., nodes that
    // have zero out-edges). In order to process this DAG, we need to spawn the
    // maximum number of worker threads specified by the -j argument. These
    // worker threads will spin a loop popping items from the leaf list and
    // processing them. After processing, the leaf node will be removed from the
    // DAG, thereby creating more leaf nodes. This is repeated until the DAG is
    // emptied.

    // Note: If the maximum number of threads is one, directly call the worker
    //       thread entrypoint in the context of this thread.

    // TODO
END