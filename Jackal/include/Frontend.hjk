#INCLUDE "<inc>/Runtime.hjk"

CONST FE_PATH_BUFFER_SIZE := 256

EXTERN FN JklCompileProgram (
    IN argc : ULONG,
    IN argv : ^UBYTE[],
)

EXTERN FeLibraryDirectory : UBYTE[FE_PATH_BUFFER_SIZE]
EXTERN FeIncludeDirectory : UBYTE[FE_PATH_BUFFER_SIZE]

EXTERN FeInputFile : UBYTE[FE_PATH_BUFFER_SIZE]
EXTERN FeOutputFile : UBYTE[FE_PATH_BUFFER_SIZE]

EXTERN FeInputFileHandle : ^VOID
EXTERN FeOutputFileHandle : ^VOID

EXTERN JklTargetInfo : ^JklTargetInfoRecord

ENUM JklPrimitiveType : UBYTE
    PRIM_TYPE_VOID,

    // The order that these are declared in determines the type compatibility,
    // such that a primitive type is only compatible with the same or a larger
    // type.

    PRIM_TYPE_SIGNED, // signed types bottom

    PRIM_TYPE_BYTE,
    PRIM_TYPE_INT,
    PRIM_TYPE_LONG,
    PRIM_TYPE_QUAD,

    PRIM_TYPE_SIGNED_MAX, // signed types top

    PRIM_TYPE_UNSIGNED, // signed types bottom

    PRIM_TYPE_UBYTE,
    PRIM_TYPE_UINT,
    PRIM_TYPE_ULONG,
    PRIM_TYPE_UQUAD,

    PRIM_TYPE_UNSIGNED_MAX, // unsigned types top

    PRIM_TYPE_MAX, // MUST be at the end
END

STRUCT JklTargetInfoRecord
    PointerAlignment : UBYTE,
    PrimitiveAlignment : UBYTE[64], // TODO make this bound just be PRIM_TYPE_MAX when compiler non-stupid
    SupportedTypes : UBYTE[64],
END

// fileblock stuff

STRUCT FeFileBlock
    Entry : TlHashTableEntry, // must be at the start

    FilePath : UBYTE[FE_PATH_BUFFER_SIZE],
    IncludeName : UBYTE[FE_PATH_BUFFER_SIZE],
END

EXTERN FN FeIsMacroArgument (
    IN arg : ^UBYTE,
) : ^UBYTE

EXTERN FN FeCreateFileBlock (
    IN includename : ^UBYTE,
    OUT created : ^UBYTE,
) : ^FeFileBlock

EXTERN FN FeCopyPathFileBlock (
    IN fileblock : ^FeFileBlock,
    IN filepath : ^UBYTE,
)