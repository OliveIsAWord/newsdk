#INCLUDE "<inc>/Runtime.jh"
#INCLUDE "<inc>/Frontend.jh"

CONST LEX_PUTBACK_STACK_DEPTH := 4
CONST LEX_BUFFER_SIZE := 8192

ENUM LexTokenType : UBYTE
	TOKEN_STATEMENT, // subtype is a statement type
	TOKEN_PTYPE, // subtype is a primitive type
	TOKEN_OPER, // subtype is operator type
	TOKEN_VALUE, // some kind of primitive value (NULL, NULLPTR, TRUE, FALSE)
	TOKEN_ARGSPEC, // argument specifier (IN, OUT)
	TOKEN_DECL, // declarator
	TOKEN_OTHER, // anything else (THEN, DO, )
	TOKEN_ASSIGN, // assignment operators

	TOKEN_LPAREN,
	TOKEN_RPAREN,
	TOKEN_LBRACKET,
	TOKEN_RBRACKET,
	TOKEN_CARET,
	TOKEN_COLON,
	TOKEN_LBRACE,
	TOKEN_RBRACE,

	TOKEN_IDENTIFIER, // payload is a symbol table entry pointer
	TOKEN_STRING, // payload is a pointer to a LexStringContents structure

	// If the token started with a CHAR_SPLIT or CHAR_COALESCE character but
	// didn't hash to a keyword, this shouldn't match with anything, ever, and
	// should just drop through to a syntax error. Same thing with a token that
	// only contains uppercase A-Z characters -- these are reserved for language
	// keywords. These are the only types of tokens that we actually look up in
	// the keyword table, so if that lookup fails, we always give the token the
	// type of TOKEN_NOTHING_GOOD.

	TOKEN_NOTHING_GOOD,
END

ENUM LexTokenSubtype : UBYTE
	TOKEN_AND,         // operator
	TOKEN_BEGIN,       // statement
	TOKEN_BREAK,       // statement
	TOKEN_BYTE,        // type
	TOKEN_CAST,        // operator
	TOKEN_CONST,       // declarator
	TOKEN_CONTINUE,    // statement
	TOKEN_DO,          // other
	TOKEN_ELSE,        // statement
	TOKEN_ELSEIF,      // statement
	TOKEN_END,         // statement
	TOKEN_ENUM,        // declarator
	TOKEN_EXTERN,      // declarator
	TOKEN_FALSE,       // value
	TOKEN_FN,          // declarator
	TOKEN_FNPTR,       // declarator
	TOKEN_FNSECTION,   // statement
	TOKEN_GOTO,        // statement
	TOKEN_IF,          // statement
	TOKEN_IN,          // argspec
	TOKEN_INT,         // type
	TOKEN_LEAVE,       // statement
	TOKEN_LONG,        // type
	TOKEN_NOT,         // operator
	TOKEN_NULL,        // value
	TOKEN_NULLPTR,     // value
	TOKEN_OR,          // operator
	TOKEN_OUT,         // argspec
	TOKEN_PACKED,      // other
	TOKEN_PUBLIC,      // declarator
	TOKEN_RETURN,      // statement
	TOKEN_SECTION,     // declarator
	TOKEN_SIZEOF,      // value
	TOKEN_SIZEOFVALUE, // operator
	TOKEN_STRUCT,      // declarator
	TOKEN_THEN,        // other
	TOKEN_TO,          // other
	TOKEN_TRUE,        // value
	TOKEN_TYPE,        // declarator
	TOKEN_UBYTE,       // type
	TOKEN_UINT,        // type
	TOKEN_ULONG,       // type
	TOKEN_UNION,       // declarator
	TOKEN_VOID,        // type
	TOKEN_WHILE,       // statement

	TOKEN_EQUIV,       // operator
	TOKEN_NOTEQUIV,    // operator
	TOKEN_BITAND,      // operator
	TOKEN_BITOR,       // operator
	TOKEN_LESSTHAN,    // operator
	TOKEN_GREATERTHAN, // operator
	TOKEN_LTEQ,        // operator
	TOKEN_GTEQ,        // operator
	TOKEN_PLUS,        // operator
	TOKEN_MINUS,       // operator
	TOKEN_DIVIDE,      // operator
	TOKEN_MODULO,      // operator
	TOKEN_DOT,         // operator
	TOKEN_LABEL,       // statement
	TOKEN_BITXOR,      // operator
	TOKEN_LEFTSHIFT,   // operator
	TOKEN_RIGHTSHIFT,  // operator
	TOKEN_BITNOT,      // operator

	TOKEN_EQUALS,      // assign
	TOKEN_PLUSEQUALS,  // assign
	TOKEN_MINUSEQUALS, // assign
	TOKEN_MULEQUALS,   // assign
	TOKEN_DIVEQUALS,   // assign
	TOKEN_MODEQUALS,   // assign
	TOKEN_ANDEQUALS,   // assign
	TOKEN_OREQUALS,    // assign
	TOKEN_XOREQUALS,   // assign
	TOKEN_LSHEQUALS,   // assign
	TOKEN_RSHEQUALS,   // assign
END

ENUM LexCharBehavior : UBYTE
	CHAR_NORMAL, // guaranteed to be zero
	CHAR_SPLIT,
	CHAR_COALESCE,
	CHAR_WHITESPACE,
END

STRUCT LexStringContents
	Length : ULONG,
	Buffer : ^UBYTE, // typically allocated inline with this structure
END

STRUCT LexToken
	Payload : ^VOID,
	FileBlock : ^FeFileBlock,
	LineNumber : ULONG,
	Type : LexTokenType,
	Subtype : LexTokenSubtype,
END

STRUCT LexStream
	Previous : ^LexStream,

	Buffer : ^UBYTE,
	BufferSize : ULONG,
	ValidLength : ULONG,
	BufferPosition : ULONG,

	LineNumber : ULONG,
	LinePosition : ULONG,

	IsMacro : UBYTE,
	LastWasNewline : UBYTE,
END

STRUCT LexFileStream
	Generic : LexStream, // must be at the beginning

	FileBlock : ^FeFileBlock,
END

STRUCT LexMacroStream
	Generic : LexStream, // must be at the beginning
END

EXTERN LexCharTreatment : LexCharBehavior[256]

EXTERN LexCurrentStream : ^LexStream
EXTERN LexCurrentMacroScope : ^TlSymbolTable
EXTERN LexFalseCount : ULONG

EXTERN LexPutbackStack : LexToken[LEX_PUTBACK_STACK_DEPTH]
EXTERN LexPutbackStackPtr : ULONG 

EXTERN FN LexInitialize () : TlStatus

EXTERN FN LexStreamInitialize (
	IN stream : ^LexStream,
	IN ismacro : UBYTE,
) : TlStatus

EXTERN FN LexStreamUninitialize (
	IN stream : ^LexStream,
)

EXTERN FN LexStreamFree (
	IN stream : ^LexStream,
)

EXTERN FN LexStreamPush (
	IN stream : ^LexStream,
)

EXTERN FN LexStreamPop () : ^LexStream

EXTERN FN LexFileStreamInitialize (
	IN filestream : ^LexFileStream,
	IN handle : ^VOID,
	IN filename : ^UBYTE,
) : TlStatus

EXTERN FN LexFileStreamCreate (
	IN handle : ^VOID,
	IN filename : ^UBYTE,
	OUT filestream : ^^LexFileStream,
) : TlStatus

EXTERN FN LexStreamGetLastFileStream () : ^LexFileStream

EXTERN FN LexStreamNextCharacter () : UBYTE

EXTERN FN LexParseDirective ()