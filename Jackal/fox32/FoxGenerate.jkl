//
// Implements the fox32 code generator.
//

#INCLUDE "<inc>/Target.hjk"

// FORWARD
EXTERN FN (JklTargetF) FoxCompile ()

// FORWARD
EXTERN FoxLirInfo : LirTargetInfoRecord

FoxTargetInfo : JklTargetInfoRecord = {
    [Name] = "fox32",
    [EntryFunc] = &FoxCompile,
    [LirInfo] = &FoxLirInfo,
    [StackAlignment] = 4,
    [PointerAlignment] = 4,
    [PointerSize] = 4,
    [LargestPrimitive] = PRIM_TYPE_ULONG,
    [LargestSignedPrimitive] = PRIM_TYPE_LONG,
    [SupportedTypes] = {
        [PRIM_TYPE_VOID] = TRUE,
        [PRIM_TYPE_UBYTE] = TRUE,
        [PRIM_TYPE_UINT] = TRUE,
        [PRIM_TYPE_ULONG] = TRUE,
        [PRIM_TYPE_UQUAD] = FALSE,
        [PRIM_TYPE_BYTE] = TRUE,
        [PRIM_TYPE_INT] = TRUE,
        [PRIM_TYPE_LONG] = TRUE,
        [PRIM_TYPE_QUAD] = FALSE,
    },
    [PrimitiveAlignment] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
    [PrimitiveSize] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
}

ENUM FoxInstructionTypes : UBYTE
    FOX_ADD,
    FOX_MUL,
    FOX_AND,
    FOX_SLA,
    FOX_SRA,
    FOX_BSE,
    FOX_CMP,
    FOX_JMP,
    FOX_RJMP,
    FOX_PUSH,
    FOX_INC,
    FOX_OR,
    FOX_IMUL,
    FOX_SRL,
    FOX_BCL,
    FOX_MOV,
    FOX_CALL,
    FOX_RCALL,
    FOX_POP,
    FOX_BRK,
    FOX_SUB,
    FOX_DIV,
    FOX_XOR,
    FOX_ROL,
    FOX_ROR,
    FOX_BTS,
    FOX_MOVZ,
    FOX_RET,
    FOX_DEC,
    FOX_REM,
    FOX_NOT,
    FOX_IDIV,
    FOX_IREM,

    FOX_MAX,
END

ENUM FoxConditionTypes : UBYTE
    FOX_COND_ALWAYS,
    FOX_COND_IFZ,
    FOX_COND_IFNZ,
    FOX_COND_IFLT,
    FOX_COND_IFGTEQ,
    FOX_COND_IFGT,
    FOX_COND_IFLTEQ,

    FOX_COND_MAX,
END

ENUM FoxBits : UBYTE
    FOX_BITS_8,
    FOX_BITS_16,
    FOX_BITS_32,

    FOX_BITS_MAX,
END

ENUM FoxAccessType : UBYTE
    FOX_ACCESS_IMM,
    FOX_ACCESS_IMM_ASM_NAME,
    FOX_ACCESS_REGISTER,
    FOX_ACCESS_POINTER,
END

FoxInstructionNames : ^UBYTE[FOX_MAX] = {
    [FOX_ADD] = "add",
    [FOX_MUL] = "mul",
    [FOX_AND] = "and",
    [FOX_SLA] = "sla",
    [FOX_SRA] = "sra",
    [FOX_BSE] = "bse",
    [FOX_CMP] = "cmp",
    [FOX_RJMP] = "rjmp",
    [FOX_PUSH] = "push",
    [FOX_INC] = "inc",
    [FOX_OR] = "or",
    [FOX_IMUL] = "imul",
    [FOX_SRL] = "srl",
    [FOX_BCL] = "bcl",
    [FOX_MOV] = "mov",
    [FOX_CALL] = "call",
    [FOX_POP] = "pop",
    [FOX_BRK] = "brk",
    [FOX_SUB] = "sub",
    [FOX_DIV] = "div",
    [FOX_XOR] = "xor",
    [FOX_ROL] = "rol",
    [FOX_ROR] = "ror",
    [FOX_BTS] = "bts",
    [FOX_MOVZ] = "movz",
    [FOX_RET] = "ret",
    [FOX_DEC] = "dec",
    [FOX_REM] = "rem",
    [FOX_NOT] = "not",
    [FOX_IDIV] = "idiv",
    [FOX_IREM] = "irem",
}

FoxConditionNames : ^UBYTE[FOX_COND_MAX] = {
    [FOX_COND_ALWAYS] = "",
    [FOX_COND_IFZ] = "ifz ",
    [FOX_COND_IFNZ] = "ifnz ",
    [FOX_COND_IFLT] = "iflt ",
    [FOX_COND_IFGTEQ] = "ifgteq ",
    [FOX_COND_IFGT] = "ifgt ",
    [FOX_COND_IFLTEQ] = "iflteq ",
}

FoxBitsNames : ^UBYTE[FOX_BITS_MAX] = {
    [FOX_BITS_8] = ".8",
    [FOX_BITS_16] = ".16",
    [FOX_BITS_32] = "",
}

FN FoxGetPtrOffset (
    IN src : ^IrVariable,
    OUT offset : ^UWORD,
) : UWORD

    // If the src variable contains a constant offset that fits in a fox32
    // pointer offset, return it. Caller should have determined it's a
    // temporary (i.e. it has a DefinedBy instruction).

    inst := src^.DefinedBy

    IF inst^.Type == IR_CONSTANT THEN
        const := inst^.Body.Constant.Constant

        IF const < 256 THEN
            offset^ = const

            RETURN TRUE
        END
    END

    RETURN FALSE
END

FN FoxFillSource (
    IN lirinst : ^LirInstruction,
    IN var : ^IrVariable,
)

    // Fill the source fields of the instruction appropriately.

    // Fox32 allows these source modes on all instructions:
    //
    // REG [REG] [REG + OFF] IMM

    srcreg : ^LirRegister

    inst := var^.DefinedBy

    IF inst THEN
        // Var is a temporary. Check for cases.

        IF inst^.Type == IR_STACK_ADDR THEN
            // It's on the stack frame, this is an SP + OFF. 
        END
    END

    // If we got here we've decided to use reg.

    lirinst^.Source1 = srcreg
    lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REGISTER
END

FN (LirSelectF) FoxSelectLoad (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // This maps to a fox32 mem-to-reg MOV instruction.

    def := inst^.Defines
    src := inst^.Source1

    IF src^.DefinedBy THEN
        // The source is a temporary. If its defining instruction was a 
    END
END

FN (LirSelectF) FoxSelectMove (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Select the most appropriate instruction.

    def := inst^.Defines
    src := inst^.Source1
    srcreg : ^LirRegister

    IF src^.DefinedBy THEN
        // The source is a temporary.

        IF src^.Opt.Dve.References == 1 THEN
            // This is the only reference to the temporary, so don't bother
            // sharing; twiddle its defining instruction to define us and then
            // generate that instead.

            src^.DefinedBy^.Defines = def

            RETURN LirSelect ( src^.DefinedBy )
        END

        srcreg = LirSelect ( src^.DefinedBy )

    ELSE
        srcreg = LirGetRegister ( src )
    END

    // Generate a fox32 reg-to-reg MOV instruction.

    defreg := LirGetRegister ( def )

    lirinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOV, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Source1 = srcreg

    lirinst^.Body.Machine.Fox.DestAccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FoxLirInfo : LirTargetInfoRecord = {
    [SelectionTable] = {
        [IR_LOAD] = &FoxSelectLoad,
        [IR_MOVE] = &FoxSelectMove,
    },
}

FN (AsmEmitF) FoxEmitFunction (
    IN funcsym : ^LexSymbol,
)

    // Emit the final assembly language for a function.

    TlInternalError ( "TODO FoxEmitFunction", 0, 0, 0 )
END

FoxAsmEmitter : AsmEmitterRecord = {
    [EmitFunc] = &FoxEmitFunction
}

FN (JklTargetF) FoxCompile ()
    
    // Compile the program for the fox32 architecture.

    // Perform instruction selection on each function.

    funcsym := PrsFunctionListHead

    WHILE funcsym DO
        LirSelectForFunction (
            funcsym, // funcsym
        )

        funcsym = funcsym^.NextFunction
    END

    // Do regalloc over the low level IR (LIR).

    funcsym = PrsFunctionListHead

    WHILE funcsym DO
        LirAllocateRegistersForFunction (
            funcsym, // funcsym
        )

        funcsym = funcsym^.NextFunction
    END

    // Emit the final assembly language.

    XrAsmEmit (
        &FoxAsmEmitter, // emitter
    )
END