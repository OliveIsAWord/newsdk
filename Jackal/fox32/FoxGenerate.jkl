//
// Implements the fox32 code generator.
//

#INCLUDE "<inc>/Target.hjk"

#MACRO FoxSetIfUnknown ( inst ) [
    IF (inst)^.Body.Machine.Fox.BitSize == FOX_BITS_UNKNOWN THEN
        (inst)^.Body.Machine.Fox.BitSize = FOX_BITS_32
    END
]

// FORWARD
EXTERN FN (JklTargetF) FoxCompile ()

// FORWARD
EXTERN FoxLirInfo : LirTargetInfoRecord

FoxSp : LirRegister
FoxFp : LirRegister

FoxTargetInfo : JklTargetInfoRecord = {
    [Name] = "fox32",
    [EntryFunc] = &FoxCompile,
    [LirInfo] = &FoxLirInfo,
    [StackAlignment] = 4,
    [PointerAlignment] = 4,
    [PointerSize] = 4,
    [LargestPrimitive] = PRIM_TYPE_ULONG,
    [LargestSignedPrimitive] = PRIM_TYPE_LONG,
    [SupportedTypes] = {
        [PRIM_TYPE_VOID] = TRUE,
        [PRIM_TYPE_UBYTE] = TRUE,
        [PRIM_TYPE_UINT] = TRUE,
        [PRIM_TYPE_ULONG] = TRUE,
        [PRIM_TYPE_UQUAD] = FALSE,
        [PRIM_TYPE_BYTE] = TRUE,
        [PRIM_TYPE_INT] = TRUE,
        [PRIM_TYPE_LONG] = TRUE,
        [PRIM_TYPE_QUAD] = FALSE,
    },
    [PrimitiveAlignment] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
    [PrimitiveSize] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
}

ENUM FoxInstructionTypes : UBYTE
    FOX_ADD,
    FOX_MUL,
    FOX_AND,
    FOX_SLA,
    FOX_SRA,
    FOX_BSE,
    FOX_CMP,
    FOX_JMP,
    FOX_RJMP,
    FOX_PUSH,
    FOX_INC,
    FOX_OR,
    FOX_IMUL,
    FOX_SRL,
    FOX_BCL,
    FOX_MOV,
    FOX_CALL,
    FOX_RCALL,
    FOX_POP,
    FOX_BRK,
    FOX_SUB,
    FOX_DIV,
    FOX_XOR,
    FOX_ROL,
    FOX_ROR,
    FOX_BTS,
    FOX_MOVZ,
    FOX_RET,
    FOX_DEC,
    FOX_REM,
    FOX_NOT,
    FOX_IDIV,
    FOX_IREM,

    FOX_MAX,
END

ENUM FoxConditionTypes : UBYTE
    FOX_COND_ALWAYS,
    FOX_COND_IFZ,
    FOX_COND_IFNZ,
    FOX_COND_IFLT,
    FOX_COND_IFGTEQ,
    FOX_COND_IFGT,
    FOX_COND_IFLTEQ,

    FOX_COND_MAX,
END

ENUM FoxBits : UBYTE
    FOX_BITS_8,
    FOX_BITS_16,
    FOX_BITS_32,

    FOX_BITS_MAX,

    FOX_BITS_UNKNOWN,
END

ENUM FoxAccessType : UBYTE
    FOX_ACCESS_REGISTER,
    FOX_ACCESS_REG_PTR,
    FOX_ACCESS_IMM,
    FOX_ACCESS_IMM_NAME,
    FOX_ACCESS_IMM_PTR,
    FOX_ACCESS_IMM_PTR_NAME,
    FOX_ACCESS_IMM_STRING,
    FOX_ACCESS_IMM_LABEL,
END

ENUM FoxRegisters : UBYTE
    FOX_NULL,

    FOX_T0,
    FOX_T1,
    FOX_T2,
    FOX_T3,
    FOX_T4,
    FOX_T5,
    FOX_T6,
    FOX_A0,
    FOX_A1,
    FOX_A2,
    FOX_A3,
    FOX_S0,
    FOX_S1,
    FOX_S2,
    FOX_S3,
    FOX_S4,
    FOX_S5,
    FOX_S6,
    FOX_S7,
    FOX_S8,
    FOX_S9,
    FOX_S10,
    FOX_S11,
    FOX_S12,
    FOX_S13,
    FOX_S14,
    FOX_S15,
    FOX_S16,
    FOX_S17,

    FOX_R31,
    FOX_SP,
    FOX_FP,

    FOX_REG_MAX,
END

FoxRegisterNames : ^UBYTE[FOX_REG_MAX] = {
    [FOX_T0] = "t0",
    [FOX_T1] = "t1",
    [FOX_T2] = "t2",
    [FOX_T3] = "t3",
    [FOX_T4] = "t4",
    [FOX_T5] = "t5",
    [FOX_T6] = "t6",
    [FOX_A0] = "a0",
    [FOX_A1] = "a1",
    [FOX_A2] = "a2",
    [FOX_A3] = "a3",
    [FOX_S0] = "s0",
    [FOX_S1] = "s1",
    [FOX_S2] = "s2",
    [FOX_S3] = "s3",
    [FOX_S4] = "s4",
    [FOX_S5] = "s5",
    [FOX_S6] = "s6",
    [FOX_S7] = "s7",
    [FOX_S8] = "s8",
    [FOX_S9] = "s9",
    [FOX_S10] = "s10",
    [FOX_S11] = "s11",
    [FOX_S12] = "s12",
    [FOX_S13] = "s13",
    [FOX_S14] = "s14",
    [FOX_S15] = "s15",
    [FOX_S16] = "s16",
    [FOX_S17] = "s17",
    [FOX_R31] = "r31",
    [FOX_SP] = "sp",
    [FOX_FP] = "fp",
}

FoxInstructionNames : ^UBYTE[FOX_MAX] = {
    [FOX_ADD] = "add",
    [FOX_MUL] = "mul",
    [FOX_AND] = "and",
    [FOX_SLA] = "sla",
    [FOX_SRA] = "sra",
    [FOX_BSE] = "bse",
    [FOX_CMP] = "cmp",
    [FOX_RJMP] = "rjmp",
    [FOX_PUSH] = "push",
    [FOX_INC] = "inc",
    [FOX_OR] = "or",
    [FOX_IMUL] = "imul",
    [FOX_SRL] = "srl",
    [FOX_BCL] = "bcl",
    [FOX_MOV] = "mov",
    [FOX_CALL] = "call",
    [FOX_POP] = "pop",
    [FOX_BRK] = "brk",
    [FOX_SUB] = "sub",
    [FOX_DIV] = "div",
    [FOX_XOR] = "xor",
    [FOX_ROL] = "rol",
    [FOX_ROR] = "ror",
    [FOX_BTS] = "bts",
    [FOX_MOVZ] = "movz",
    [FOX_RET] = "ret",
    [FOX_DEC] = "dec",
    [FOX_REM] = "rem",
    [FOX_NOT] = "not",
    [FOX_IDIV] = "idiv",
    [FOX_IREM] = "irem",
}

FoxConditionNames : ^UBYTE[FOX_COND_MAX] = {
    [FOX_COND_ALWAYS] = "",
    [FOX_COND_IFZ] = "ifz ",
    [FOX_COND_IFNZ] = "ifnz ",
    [FOX_COND_IFLT] = "iflt ",
    [FOX_COND_IFGTEQ] = "ifgteq ",
    [FOX_COND_IFGT] = "ifgt ",
    [FOX_COND_IFLTEQ] = "iflteq ",
}

FoxBitsNames : ^UBYTE[FOX_BITS_MAX] = {
    [FOX_BITS_8] = ".8",
    [FOX_BITS_16] = ".16",
    [FOX_BITS_32] = "",
}

FoxPrimTypeToBits : UBYTE[PRIM_TYPE_MAX] = {
    [PRIM_TYPE_BYTE] = FOX_BITS_8,
    [PRIM_TYPE_INT] = FOX_BITS_16,
    [PRIM_TYPE_LONG] = FOX_BITS_32,

    [PRIM_TYPE_UBYTE] = FOX_BITS_8,
    [PRIM_TYPE_UINT] = FOX_BITS_16,
    [PRIM_TYPE_ULONG] = FOX_BITS_32,

    [PRIM_TYPE_POINTER] = FOX_BITS_32,
}

FoxBranchToCondition : UBYTE[IR_BRANCH_HIGH_NUMBER] = {
    [IR_BRANCH_EQUALS] = FOX_COND_IFZ,
    [IR_BRANCH_NOT_EQUALS] = FOX_COND_IFNZ,

    [IR_BRANCH_LESS_THAN] = FOX_COND_IFLT,
    [IR_BRANCH_GREATER_THAN] = FOX_COND_IFGT,
    [IR_BRANCH_LTEQ] = FOX_COND_IFLTEQ,
    [IR_BRANCH_GTEQ] = FOX_COND_IFGTEQ,

    [IR_BRANCH_LESS_THAN_SIGNED] = FOX_COND_IFLT,
    [IR_BRANCH_GREATER_THAN_SIGNED] = FOX_COND_IFGT,
    [IR_BRANCH_LTEQ_SIGNED] = FOX_COND_IFLTEQ,
    [IR_BRANCH_GTEQ_SIGNED] = FOX_COND_IFGTEQ,
}

FN FoxFillOperandForAccess (
    IN lirinst : ^LirInstruction,
    IN operand : ^LirFoxOperand,
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Caller should have made sure the instruction is the right width,
    // otherwise an intermediate access is required.

    lirinst^.Body.Machine.Fox.BitSize =
        FoxPrimTypeToBits[inst^.Body.LoadStore.Type]

    src2 := inst^.Source1

    inst2 := src2^.DefinedBy

    IF NOT inst2 THEN
        // Not a temporary, just trust this named local.

        operand^.AccessType = FOX_ACCESS_REG_PTR
        operand^.Constant = 0

        RETURN LirGetRegister ( src2 )
    END

    IF inst2^.Type == IR_STACK_ADDR THEN
        // It's on the stack frame, this is an SP + OFF. 

        symbol := inst2^.Body.Addr.Symbol

        off := IrGetStackOffset (
            LirCurrentFunction, // func
            symbol, // symbol
        )

        IF off < 256 THEN
            // Great! We can do this directly.

            operand^.AccessType = FOX_ACCESS_REG_PTR
            operand^.Constant = off

            RETURN &FoxSp
        END

    ELSEIF inst2^.Type == IR_ADDR THEN
        // Gotta be a named imm.
        // TODO investigate intentionally sharing common constants to
        //      reduce code size.

        operand^.AccessType = FOX_ACCESS_IMM_PTR_NAME
        operand^.Constant = CAST inst2^.Body.Addr.Symbol TO UWORD

        RETURN NULLPTR

    ELSEIF inst2^.Type == IR_CONSTANT THEN
        // Numeric imm.
        // TODO investigate intentionally sharing common constants to
        //      reduce code size.

        operand^.AccessType = FOX_ACCESS_IMM_PTR
        operand^.Constant = inst2^.Body.Constant.Constant

        RETURN NULLPTR

    ELSEIF inst2^.Type == IR_ADD THEN
        // If this is plus a constant less than 256, we can do an
        // offsetted load. We don't have to check for a constant in the
        // left side because the simplification pass moved them all to
        // the right side.

        src3 := inst2^.Source2

        inst3 := src3^.DefinedBy

        IF inst3 AND
            inst3^.Type == IR_CONSTANT AND
            inst3^.Body.Constant.Constant < 256 THEN

            // Neat! Get the register for the left side.

            // Fill in the LIR instruction.

            operand^.AccessType = FOX_ACCESS_REG_PTR
            operand^.Constant = inst3^.Body.Constant.Constant

            RETURN LirSelectOrGetRegister ( inst2^.Source1 )
        END
    END

    // In any load case not covered above, select.

    operand^.AccessType = FOX_ACCESS_REG_PTR
    operand^.Constant = 0

    RETURN LirSelect ( inst2 )
END

FN FoxFillOperand (
    IN lirinst : ^LirInstruction,
    IN operand : ^LirFoxOperand,
    IN var : ^IrVariable,
) : ^LirRegister

    // Fill the source fields of the instruction appropriately.
    // Caller should make sure the BitSize field was set on the LIR instruction.

    // Fox32 allows these source modes on all instructions:
    //
    // REG [REG] [REG + OFF] IMM

    inst := var^.DefinedBy

    IF NOT inst THEN
        // It's a named local.

        operand^.AccessType = FOX_ACCESS_REGISTER

        RETURN LirGetRegister ( var )
    END

    // Var is a temporary. Check for cases.

    IF inst^.Type == IR_LOAD THEN
        // It's one of the load ones.

        // TODO If it's used more than once, share instead of selecting over it,
        //      or we will generate lots of extra loads.

        // We can only select over this if the load width matches.

        bitsize := lirinst^.Body.Machine.Fox.BitSize

        IF bitsize == FOX_BITS_UNKNOWN OR
            bitsize == FoxPrimTypeToBits[inst^.Body.LoadStore.Type] THEN

            RETURN FoxFillOperandForAccess (
                lirinst, // lirinst
                operand, // operand
                inst, // inst
            )
        END

    ELSEIF inst^.Type == IR_ADDR THEN
        // Gotta be a named imm.
        // TODO investigate sharing to reduce code size

        operand^.AccessType = FOX_ACCESS_IMM_NAME
        operand^.Constant = CAST inst^.Body.Addr.Symbol TO UWORD

        RETURN NULLPTR

    ELSEIF inst^.Type == IR_CONSTANT THEN
        // Gotta be a numeric imm.
        // TODO investigate sharing to reduce code size

        operand^.AccessType = FOX_ACCESS_IMM_PTR
        operand^.Constant = inst^.Body.Constant.Constant

        RETURN NULLPTR
    END

    // If we got here we've decided to use reg.

    operand^.AccessType = FOX_ACCESS_REGISTER

    RETURN LirSelect ( inst )
END

FN (LirSelectF) FoxSelectLoad (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a fox32 mem-to-reg MOVZ instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOVZ, // machtype
    )

    lirinst^.Defines = defreg

    lirinst^.Source2 = FoxFillOperandForAccess (
        lirinst, // lirinst
        &lirinst^.Body.Machine.Fox.Op2, // operand
        inst, // inst
    )

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a fox32 imm-to-reg MOV instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOV, // machtype
    )

    lirinst^.Defines = defreg

    IF inst^.Type == IR_ADDR THEN
        lirinst^.Body.Machine.Fox.Op2.Constant =
            CAST inst^.Body.Addr.Symbol TO UWORD
    
        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM_NAME

    ELSEIF inst^.Type == IR_STRING_ADDR THEN
        // This will get resolved to a label pointing to a string during
        // code emission.

        lirinst^.Body.Machine.Fox.Op2.Constant =
            CAST inst^.Body.String.String TO UWORD

        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM_STRING
    
    ELSEIF inst^.Type == IR_CONSTANT THEN
        lirinst^.Body.Machine.Fox.Op2.Constant = inst^.Body.Constant.Constant

        lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    END

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    RETURN defreg
END

FN (LirSelectF) FoxSelectStackAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a MOV instruction from SP to a temporary. Then generate an add
    // instruction to create the stack address.

    symbol := inst^.Body.Addr.Symbol

    off := IrGetStackOffset (
        LirCurrentFunction, // func
        symbol, // symbol
    )

    defreg := LirGetRegister ( inst^.Defines )

    movinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOV, // machtype
    )

    movinst^.Defines = defreg
    movinst^.Source2 = &FoxSp

    movinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    movinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( movinst )

    addinst := LirCreateInstruction (
        LIR_BINARY, // type
        FOX_ADD, // machtype
    )

    // Note that for the sake of regalloc we put the defined register as both
    // used and defined here (because that's the sitch -- fox32 can only add
    // onto a register), but in the final assembly it will just be
    //
    //  add defreg, IMM
    //
    // We put an actual source register in Source2 instead.

    addinst^.Defines = defreg
    addinst^.Source1 = defreg

    addinst^.Body.Machine.Fox.Op2.Constant = off
    addinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    addinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    addinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    addinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( addinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectMove (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Select the most appropriate instruction.

    def := inst^.Defines
    src := inst^.Source1
    srcreg : ^LirRegister

    IF src^.DefinedBy THEN
        // The source is a temporary.

        IF src^.Opt.Dve.References == 1 THEN
            // This is the only reference to the temporary, so don't bother
            // sharing; twiddle its defining instruction to define us and then
            // generate that instead.

            src^.DefinedBy^.Defines = def

            RETURN LirSelect ( src^.DefinedBy )
        END

        srcreg = LirSelect ( src^.DefinedBy )

    ELSE
        srcreg = LirGetRegister ( src )
    END

    // Generate a fox32 reg-to-reg MOV instruction.

    defreg := LirGetRegister ( def )

    lirinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOV, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Source2 = srcreg

    lirinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectReturn (
    IN inst : ^IrInstruction,
) : ^LirRegister

    srcreg := LirSelectOrGetRegister ( inst^.Source1 )

    // Hint for regalloc to assign it to a3 (per our ABI). If it doesn't, we
    // will have to manually move it there during code emission.

    srcreg^.Hint = FOX_A3

    // Add a LIR return instruction. We can't directly generate a jump to the
    // epilogue or something because we don't know how to return this value
    // until after regalloc; so, we don't generate that jump until emission.

    lirinst := LirCreateInstruction (
        LIR_RETURN, // type
        0, // machtype
    )

    lirinst^.Source2 = srcreg

    LirInsertInstructionTail ( lirinst )

    RETURN NULLPTR
END

FN FoxGenerateFalseBranch (
    IN inst : ^IrInstruction,
)

    IF inst^.Body.Branch.FalseLabel == inst^.Next THEN
        // The false label is the fall-through, don't generate the false branch.

        LEAVE
    END

    // Generate the false branch.

    jmpinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_RJMP, // machtype
    )

    jmpinst^.Body.Machine.Fox.Op1.Constant =
        CAST LirGetLabel ( inst^.Body.Branch.FalseLabel ) TO UWORD

    jmpinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_IMM_LABEL
    jmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    jmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( jmpinst )
END

FN (LirSelectF) FoxSelectZeroBranch (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF IrIsUselessBranch ( inst ) THEN
        RETURN NULLPTR
    END

    // Output CMP with IMM 0 and then IFNZ JMP.

    cmpinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_CMP, // machtype
    )

    cmpinst^.Body.Machine.Fox.Op2.Constant = 0
    cmpinst^.Body.Machine.Fox.Op2.AccessType = FOX_ACCESS_IMM
    cmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    cmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_UNKNOWN

    cmpinst^.Source1 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op1, // operand
        inst^.Source1, // var
    )

    FoxSetIfUnknown ( cmpinst )

    LirInsertInstructionTail ( cmpinst )

    jmpinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_RJMP, // machtype
    )

    jmpinst^.Body.Machine.Fox.Op1.Constant =
        CAST LirGetLabel ( inst^.Body.Branch.TrueLabel ) TO UWORD

    jmpinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_IMM_LABEL

    IF inst^.Type == IR_BRANCH_NONZERO THEN
        jmpinst^.Body.Machine.Fox.Condition = FOX_COND_IFNZ

    ELSE
        jmpinst^.Body.Machine.Fox.Condition = FOX_COND_IFZ
    END

    jmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( jmpinst )

    // Generate an unconditional branch to the false label if required.

    FoxGenerateFalseBranch ( inst )

    RETURN NULLPTR
END

FN (LirSelectF) FoxSelectBranch (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF IrIsUselessBranch ( inst ) THEN
        RETURN NULLPTR
    END

    // Output CMP and then JMP.

    cmpinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_CMP, // machtype
    )

    cmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    cmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_UNKNOWN

    cmpinst^.Source1 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op1, // operand
        inst^.Source1, // var
    )

    cmpinst^.Source2 = FoxFillOperand (
        cmpinst, // lirinst
        &cmpinst^.Body.Machine.Fox.Op2, // operand
        inst^.Source2, // var
    )

    FoxSetIfUnknown ( cmpinst )

    LirInsertInstructionTail ( cmpinst )

    jmpinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_RJMP, // machtype
    )

    jmpinst^.Body.Machine.Fox.Op1.Constant =
        CAST LirGetLabel ( inst^.Body.Branch.TrueLabel ) TO UWORD

    jmpinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_IMM_LABEL
    jmpinst^.Body.Machine.Fox.Condition = FoxBranchToCondition[inst^.Type]
    jmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( jmpinst )

    // Generate an unconditional branch to the false label if required.

    FoxGenerateFalseBranch ( inst )

    RETURN NULLPTR
END

FN (LirSelectF) FoxSelectJump (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF inst^.Body.Jump.Label == inst^.Next THEN
        // Don't generate the jump; allow fall-through.

        RETURN NULLPTR
    END

    jmpinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_RJMP, // machtype
    )

    jmpinst^.Body.Machine.Fox.Op1.Constant =
        CAST LirGetLabel ( inst^.Body.Jump.Label ) TO UWORD

    jmpinst^.Body.Machine.Fox.Op1.AccessType = FOX_ACCESS_IMM_LABEL
    jmpinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    jmpinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( jmpinst )

    RETURN NULLPTR
END

FN (LirSelectF) FoxSelectCall (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // We generate the call instruction and all of its arguments but we don't
    // worry at all about the ABI; we need the register allocator to run first.

    defreg : ^LirRegister = NULLPTR

    IF inst^.Defines THEN
        defreg = LirGetRegister ( inst^.Defines )

        defreg^.Hint = FOX_A3
    END

    callinst := LirCreateInstruction (
        LIR_CALL, // type
        FOX_CALL, // machtype
    )

    callinst^.Defines = defreg
    callinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    callinst^.Body.Machine.Fox.BitSize = FOX_BITS_UNKNOWN

    callinst^.Source1 = FoxFillOperand (
        callinst, // lirinst
        &callinst^.Body.Machine.Fox.Op1, // operand
        inst^.Source1, // var
    )

    arglisttail : ^LirArgument = NULLPTR
    callinst^.ArgListHead = NULLPTR

    arg := inst^.Body.Call.ArgListHead

    count := 0

    WHILE arg DO
        lirarg : ^LirArgument

        status := TlBumpAlloc (
            SIZEOF LirArgument, // bytes
            lirarg, // OUT ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate LIR argument", 0, 0, 0 )
        END

        lirarg^.Register = LirSelectOrGetRegister ( arg^.Variable )

        IF count < 3 THEN
            lirarg^.Register^.Hint = FOX_A0 + count
        END

        lirarg^.Next = NULLPTR

        IF arglisttail THEN
            arglisttail^.Next = lirarg

        ELSE
            callinst^.ArgListHead = lirarg
        END

        arglisttail = lirarg

        count += 1

        arg = arg^.Next
    END

    LirInsertInstructionTail ( callinst )

    RETURN defreg
END

FoxLirInfo : LirTargetInfoRecord = {
    [SelectionTable] = {
        [IR_LOAD] = &FoxSelectLoad,
        [IR_ADDR] = &FoxSelectAddr,
        [IR_STRING_ADDR] = &FoxSelectAddr,
        [IR_STACK_ADDR] = &FoxSelectStackAddr,
        [IR_CONSTANT] = &FoxSelectAddr,
        [IR_MOVE] = &FoxSelectMove,

        [IR_RETURN] = &FoxSelectReturn,

        [IR_BRANCH_NONZERO] = &FoxSelectZeroBranch,
        [IR_BRANCH_ZERO] = &FoxSelectZeroBranch,

        [IR_BRANCH_EQUALS] = &FoxSelectBranch,
        [IR_BRANCH_NOT_EQUALS] = &FoxSelectBranch,
        [IR_BRANCH_LESS_THAN] = &FoxSelectBranch,
        [IR_BRANCH_GREATER_THAN] = &FoxSelectBranch,
        [IR_BRANCH_LTEQ] = &FoxSelectBranch,
        [IR_BRANCH_GTEQ] = &FoxSelectBranch,
        [IR_BRANCH_LESS_THAN_SIGNED] = &FoxSelectBranch,
        [IR_BRANCH_GREATER_THAN_SIGNED] = &FoxSelectBranch,
        [IR_BRANCH_LTEQ_SIGNED] = &FoxSelectBranch,
        [IR_BRANCH_GTEQ_SIGNED] = &FoxSelectBranch,

        [IR_JUMP] = &FoxSelectJump,

        [IR_CALL] = &FoxSelectCall,
    },
}

FN (AsmEmitF) FoxEmitFunction (
    IN funcsym : ^LexSymbol,
)

    // Emit the final assembly language for a function.

    // First add a prologue and epilogue.

    // Now loop to emit the text.

    TlInternalError ( "TODO FoxEmitFunction", 0, 0, 0 )
END

FoxAsmEmitter : AsmEmitterRecord = {
    [EmitFunc] = &FoxEmitFunction
}

FN (JklTargetF) FoxCompile ()
    
    // Compile the program for the fox32 architecture.

    // Initialize the SP and FP registers.

    FoxSp.Type = LIR_MACHINE_REG
    FoxSp.MachineRegister = FOX_SP

    FoxFp.Type = LIR_MACHINE_REG
    FoxFp.MachineRegister = FOX_FP

    // Perform instruction selection on each function.

    funcsym := PrsFunctionListHead

    WHILE funcsym DO
        LirSelectForFunction (
            funcsym, // funcsym
        )

        funcsym = funcsym^.NextFunction
    END

    // Do regalloc over the low level IR (LIR).

    funcsym = PrsFunctionListHead

    WHILE funcsym DO
        LirAllocateRegistersForFunction (
            funcsym, // funcsym
        )

        funcsym = funcsym^.NextFunction
    END

    // Emit the final assembly language.

    XrAsmEmit (
        &FoxAsmEmitter, // emitter
    )
END