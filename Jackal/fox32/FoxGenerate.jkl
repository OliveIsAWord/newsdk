//
// Implements the fox32 code generator.
//

#INCLUDE "<inc>/Target.hjk"

// FORWARD
EXTERN FN (JklTargetF) FoxCompile ()

// FORWARD
EXTERN FoxLirInfo : LirTargetInfoRecord

FoxSp : LirRegister
FoxFp : LirRegister

FoxTargetInfo : JklTargetInfoRecord = {
    [Name] = "fox32",
    [EntryFunc] = &FoxCompile,
    [LirInfo] = &FoxLirInfo,
    [StackAlignment] = 4,
    [PointerAlignment] = 4,
    [PointerSize] = 4,
    [LargestPrimitive] = PRIM_TYPE_ULONG,
    [LargestSignedPrimitive] = PRIM_TYPE_LONG,
    [SupportedTypes] = {
        [PRIM_TYPE_VOID] = TRUE,
        [PRIM_TYPE_UBYTE] = TRUE,
        [PRIM_TYPE_UINT] = TRUE,
        [PRIM_TYPE_ULONG] = TRUE,
        [PRIM_TYPE_UQUAD] = FALSE,
        [PRIM_TYPE_BYTE] = TRUE,
        [PRIM_TYPE_INT] = TRUE,
        [PRIM_TYPE_LONG] = TRUE,
        [PRIM_TYPE_QUAD] = FALSE,
    },
    [PrimitiveAlignment] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
    [PrimitiveSize] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
}

ENUM FoxInstructionTypes : UBYTE
    FOX_ADD,
    FOX_MUL,
    FOX_AND,
    FOX_SLA,
    FOX_SRA,
    FOX_BSE,
    FOX_CMP,
    FOX_JMP,
    FOX_RJMP,
    FOX_PUSH,
    FOX_INC,
    FOX_OR,
    FOX_IMUL,
    FOX_SRL,
    FOX_BCL,
    FOX_MOV,
    FOX_CALL,
    FOX_RCALL,
    FOX_POP,
    FOX_BRK,
    FOX_SUB,
    FOX_DIV,
    FOX_XOR,
    FOX_ROL,
    FOX_ROR,
    FOX_BTS,
    FOX_MOVZ,
    FOX_RET,
    FOX_DEC,
    FOX_REM,
    FOX_NOT,
    FOX_IDIV,
    FOX_IREM,

    FOX_MAX,
END

ENUM FoxConditionTypes : UBYTE
    FOX_COND_ALWAYS,
    FOX_COND_IFZ,
    FOX_COND_IFNZ,
    FOX_COND_IFLT,
    FOX_COND_IFGTEQ,
    FOX_COND_IFGT,
    FOX_COND_IFLTEQ,

    FOX_COND_MAX,
END

ENUM FoxBits : UBYTE
    FOX_BITS_8,
    FOX_BITS_16,
    FOX_BITS_32,

    FOX_BITS_MAX,

    FOX_BITS_UNKNOWN,
END

ENUM FoxAccessType : UBYTE
    FOX_ACCESS_IMM,
    FOX_ACCESS_IMM_NAME,
    FOX_ACCESS_REGISTER,
    FOX_ACCESS_REG_PTR,
    FOX_ACCESS_IMM_PTR,
    FOX_ACCESS_IMM_PTR_NAME,
    FOX_ACCESS_STRING,
END

ENUM FoxRegisters : UBYTE
    FOX_T0 = 0,
    FOX_T1 = 1,
    FOX_T2 = 2,
    FOX_T3 = 3,
    FOX_T4 = 4,
    FOX_T5 = 5,
    FOX_T6 = 6,
    FOX_A0 = 7,
    FOX_A1 = 8,
    FOX_A2 = 9,
    FOX_A3 = 10,
    FOX_S0 = 11,
    FOX_S1 = 12,
    FOX_S2 = 13,
    FOX_S3 = 14,
    FOX_S4 = 15,
    FOX_S5 = 16,
    FOX_S6 = 17,
    FOX_S7 = 18,
    FOX_S8 = 19,
    FOX_S9 = 20,
    FOX_S10 = 21,
    FOX_S11 = 22,
    FOX_S12 = 23,
    FOX_S13 = 24,
    FOX_S14 = 25,
    FOX_S15 = 26,
    FOX_S16 = 27,
    FOX_S17 = 28,

    FOX_R31 = 31,
    FOX_SP = 32,
    FOX_FP = 34,

    FOX_REG_MAX,
END

FoxRegisterNames : ^UBYTE[FOX_REG_MAX] = {
    [FOX_T0] = "t0",
    [FOX_T1] = "t1",
    [FOX_T2] = "t2",
    [FOX_T3] = "t3",
    [FOX_T4] = "t4",
    [FOX_T5] = "t5",
    [FOX_T6] = "t6",
    [FOX_A0] = "a0",
    [FOX_A1] = "a1",
    [FOX_A2] = "a2",
    [FOX_A3] = "a3",
    [FOX_S0] = "s0",
    [FOX_S1] = "s1",
    [FOX_S2] = "s2",
    [FOX_S3] = "s3",
    [FOX_S4] = "s4",
    [FOX_S5] = "s5",
    [FOX_S6] = "s6",
    [FOX_S7] = "s7",
    [FOX_S8] = "s8",
    [FOX_S9] = "s9",
    [FOX_S10] = "s10",
    [FOX_S11] = "s11",
    [FOX_S12] = "s12",
    [FOX_S13] = "s13",
    [FOX_S14] = "s14",
    [FOX_S15] = "s15",
    [FOX_S16] = "s16",
    [FOX_S17] = "s17",
    [FOX_R31] = "r31",
    [FOX_SP] = "sp",
    [FOX_FP] = "fp",
}

FoxInstructionNames : ^UBYTE[FOX_MAX] = {
    [FOX_ADD] = "add",
    [FOX_MUL] = "mul",
    [FOX_AND] = "and",
    [FOX_SLA] = "sla",
    [FOX_SRA] = "sra",
    [FOX_BSE] = "bse",
    [FOX_CMP] = "cmp",
    [FOX_RJMP] = "rjmp",
    [FOX_PUSH] = "push",
    [FOX_INC] = "inc",
    [FOX_OR] = "or",
    [FOX_IMUL] = "imul",
    [FOX_SRL] = "srl",
    [FOX_BCL] = "bcl",
    [FOX_MOV] = "mov",
    [FOX_CALL] = "call",
    [FOX_POP] = "pop",
    [FOX_BRK] = "brk",
    [FOX_SUB] = "sub",
    [FOX_DIV] = "div",
    [FOX_XOR] = "xor",
    [FOX_ROL] = "rol",
    [FOX_ROR] = "ror",
    [FOX_BTS] = "bts",
    [FOX_MOVZ] = "movz",
    [FOX_RET] = "ret",
    [FOX_DEC] = "dec",
    [FOX_REM] = "rem",
    [FOX_NOT] = "not",
    [FOX_IDIV] = "idiv",
    [FOX_IREM] = "irem",
}

FoxConditionNames : ^UBYTE[FOX_COND_MAX] = {
    [FOX_COND_ALWAYS] = "",
    [FOX_COND_IFZ] = "ifz ",
    [FOX_COND_IFNZ] = "ifnz ",
    [FOX_COND_IFLT] = "iflt ",
    [FOX_COND_IFGTEQ] = "ifgteq ",
    [FOX_COND_IFGT] = "ifgt ",
    [FOX_COND_IFLTEQ] = "iflteq ",
}

FoxBitsNames : ^UBYTE[FOX_BITS_MAX] = {
    [FOX_BITS_8] = ".8",
    [FOX_BITS_16] = ".16",
    [FOX_BITS_32] = "",
}

FoxPrimTypeToBits : UBYTE[PRIM_TYPE_MAX] = {
    [PRIM_TYPE_BYTE] = FOX_BITS_8,
    [PRIM_TYPE_INT] = FOX_BITS_16,
    [PRIM_TYPE_LONG] = FOX_BITS_32,

    [PRIM_TYPE_UBYTE] = FOX_BITS_8,
    [PRIM_TYPE_UINT] = FOX_BITS_16,
    [PRIM_TYPE_ULONG] = FOX_BITS_32,

    [PRIM_TYPE_POINTER] = FOX_BITS_32,
}

FN FoxFillSourceForLoad (
    IN lirinst : ^LirInstruction,
    IN inst : ^IrInstruction,
)

    // Caller should have made sure the instruction is the right width,
    // otherwise an intermediate load is required.

    lirinst^.Body.Machine.Fox.BitSize =
        FoxPrimTypeToBits[inst^.Body.LoadStore.Type]

    src2 := inst^.Source1

    inst2 := src2^.DefinedBy

    IF NOT inst2 THEN
        // Not a temporary, just trust this named local.

        lirinst^.Source2 = LirGetRegister ( src2 )
        lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REG_PTR
        lirinst^.Body.Machine.Fox.Constant2 = 0

        LEAVE
    END

    IF inst2^.Type == IR_STACK_ADDR THEN
        // It's on the stack frame, this is an SP + OFF. 

        symbol := inst2^.Body.Addr.Symbol

        off := IrGetStackOffset (
            LirCurrentFunction, // func
            symbol, // symbol
        )

        IF off < 256 THEN
            // Great! We can do this directly.

            lirinst^.Source2 = &FoxSp
            lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REG_PTR
            lirinst^.Body.Machine.Fox.Constant2 = off

            LEAVE
        END

    ELSEIF inst2^.Type == IR_ADDR THEN
        // Gotta be a named imm.
        // TODO investigate intentionally sharing common constants to
        //      reduce code size.

        lirinst^.Body.Machine.Fox.SrcAccessType =
            FOX_ACCESS_IMM_PTR_NAME

        lirinst^.Body.Machine.Fox.Constant2 =
            CAST inst2^.Body.Addr.Symbol TO UWORD

        LEAVE

    ELSEIF inst2^.Type == IR_CONSTANT THEN
        // Numeric imm.
        // TODO investigate intentionally sharing common constants to
        //      reduce code size.

        lirinst^.Source2 = NULLPTR

        lirinst^.Body.Machine.Fox.SrcAccessType =
            FOX_ACCESS_IMM_PTR

        lirinst^.Body.Machine.Fox.Constant2 =
            inst2^.Body.Constant.Constant

        LEAVE

    ELSEIF inst2^.Type == IR_ADD THEN
        // If this is plus a constant less than 256, we can do an
        // offsetted load. We don't have to check for a constant in the
        // left side because the simplification pass moved them all to
        // the right side.

        src3 := inst2^.Source2

        inst3 := src3^.DefinedBy

        IF inst3 AND
            inst3^.Type == IR_CONSTANT AND
            inst3^.Body.Constant.Constant < 256 THEN

            // Neat! Get the register for the left side.

            // Fill in the LIR instruction.

            lirinst^.Source2 = LirSelectOrGetRegister ( inst2^.Source1 )

            lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REG_PTR

            lirinst^.Body.Machine.Fox.Constant2 =
                inst3^.Body.Constant.Constant

            LEAVE
        END
    END

    // In any load case not covered above, select.

    lirinst^.Source2 = LirSelect ( inst2 )
    lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REG_PTR
    lirinst^.Body.Machine.Fox.Constant2 = 0
END

FN FoxFillSource (
    IN lirinst : ^LirInstruction,
    IN var : ^IrVariable,
)

    // Fill the source fields of the instruction appropriately.
    // Caller should make sure the BitSize field was set on the LIR instruction.

    // Fox32 allows these source modes on all instructions:
    //
    // REG [REG] [REG + OFF] IMM

    srcreg : ^LirRegister

    inst := var^.DefinedBy

    IF NOT inst THEN
        // It's a named local.

        lirinst^.Source2 = LirGetRegister ( var )
        lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REGISTER

        LEAVE
    END

    // Var is a temporary. Check for cases.

    IF inst^.Type == IR_LOAD THEN
        // It's one of the load ones.

        // TODO If it's used more than once, share instead of selecting over it,
        //      or we will generate lots of extra loads.

        // We can only select over this if the load width matches.

        bitsize := lirinst^.Body.Machine.Fox.BitSize

        IF bitsize == FOX_BITS_UNKNOWN OR
            bitsize == FoxPrimTypeToBits[inst^.Body.LoadStore.Type] THEN

            FoxFillSourceForLoad (
                lirinst, // lirinst
                inst, // inst
            )

            LEAVE
        END

    ELSEIF inst^.Type == IR_ADDR THEN
        // Gotta be a named imm.
        // TODO investigate sharing to reduce code size

        lirinst^.Body.Machine.Fox.SrcAccessType =
            FOX_ACCESS_IMM_NAME

        lirinst^.Body.Machine.Fox.Constant2 =
            CAST inst^.Body.Addr.Symbol TO UWORD

        LEAVE

    ELSEIF inst^.Type == IR_CONSTANT THEN
        // Gotta be a numeric imm.
        // TODO investigate sharing to reduce code size

        lirinst^.Body.Machine.Fox.SrcAccessType =
            FOX_ACCESS_IMM_PTR

        lirinst^.Body.Machine.Fox.Constant2 =
            inst^.Body.Constant.Constant

        LEAVE
    END

    // If we got here we've decided to use reg.

    lirinst^.Source1 = LirSelect ( inst )
    lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REGISTER
END

FN (LirSelectF) FoxSelectLoad (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a fox32 mem-to-reg MOVZ instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOVZ, // machtype
    )

    lirinst^.Defines = defreg

    FoxFillSourceForLoad (
        lirinst, // lirinst
        inst, // inst
    )

    lirinst^.Body.Machine.Fox.DestAccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a fox32 imm-to-reg MOV instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOV, // machtype
    )

    lirinst^.Defines = defreg

    IF inst^.Type == IR_ADDR THEN
        lirinst^.Body.Machine.Fox.Constant2 =
            CAST inst^.Body.Addr.Symbol TO UWORD
    
            lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_IMM_NAME

    ELSEIF inst^.Type == IR_STRING_ADDR THEN
        // This will get resolved to a label pointing to a string during
        // code emission.

        lirinst^.Body.Machine.Fox.Constant2 =
            CAST inst^.Body.String.String TO UWORD

        lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_STRING
    
    ELSEIF inst^.Type == IR_CONSTANT THEN
        lirinst^.Body.Machine.Fox.Constant2 = inst^.Body.Constant.Constant

        lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_IMM
    END

    lirinst^.Body.Machine.Fox.DestAccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    RETURN defreg
END

FN (LirSelectF) FoxSelectStackAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a MOV instruction from SP to a temporary. Then generate an add
    // instruction to create the stack address.

    symbol := inst^.Body.Addr.Symbol

    off := IrGetStackOffset (
        LirCurrentFunction, // func
        symbol, // symbol
    )

    defreg := LirGetRegister ( inst^.Defines )

    movinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOV, // machtype
    )

    movinst^.Defines = defreg
    movinst^.Source2 = &FoxSp

    movinst^.Body.Machine.Fox.DestAccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    movinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( movinst )

    addinst := LirCreateInstruction (
        LIR_BINARY, // type
        FOX_ADD, // machtype
    )

    // Note that for the sake of regalloc we put the defined register as both
    // used and defined here (because that's the sitch -- fox32 can only add
    // onto a register), but in the final assembly it will just be
    //
    //  add defreg, IMM
    //
    // We put an actual source register in Source2 instead.

    addinst^.Defines = defreg
    addinst^.Source1 = defreg

    addinst^.Body.Machine.Fox.Constant2 = off
    addinst^.Body.Machine.Fox.DestAccessType = FOX_ACCESS_REGISTER
    addinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_IMM
    addinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    addinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( addinst )

    RETURN defreg
END

FN (LirSelectF) FoxSelectMove (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Select the most appropriate instruction.

    def := inst^.Defines
    src := inst^.Source1
    srcreg : ^LirRegister

    IF src^.DefinedBy THEN
        // The source is a temporary.

        IF src^.Opt.Dve.References == 1 THEN
            // This is the only reference to the temporary, so don't bother
            // sharing; twiddle its defining instruction to define us and then
            // generate that instead.

            src^.DefinedBy^.Defines = def

            RETURN LirSelect ( src^.DefinedBy )
        END

        srcreg = LirSelect ( src^.DefinedBy )

    ELSE
        srcreg = LirGetRegister ( src )
    END

    // Generate a fox32 reg-to-reg MOV instruction.

    defreg := LirGetRegister ( def )

    lirinst := LirCreateInstruction (
        LIR_UNARY, // type
        FOX_MOV, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Source1 = srcreg

    lirinst^.Body.Machine.Fox.DestAccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.SrcAccessType = FOX_ACCESS_REGISTER
    lirinst^.Body.Machine.Fox.Condition = FOX_COND_ALWAYS
    lirinst^.Body.Machine.Fox.BitSize = FOX_BITS_32

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FoxLirInfo : LirTargetInfoRecord = {
    [SelectionTable] = {
        [IR_LOAD] = &FoxSelectLoad,
        [IR_ADDR] = &FoxSelectAddr,
        [IR_STRING_ADDR] = &FoxSelectAddr,
        [IR_STACK_ADDR] = &FoxSelectStackAddr,
        [IR_CONSTANT] = &FoxSelectAddr,
        [IR_MOVE] = &FoxSelectMove,
    },
}

FN (AsmEmitF) FoxEmitFunction (
    IN funcsym : ^LexSymbol,
)

    // Emit the final assembly language for a function.

    // First add a prologue and epilogue.

    // Now loop to emit the text.

    TlInternalError ( "TODO FoxEmitFunction", 0, 0, 0 )
END

FoxAsmEmitter : AsmEmitterRecord = {
    [EmitFunc] = &FoxEmitFunction
}

FN (JklTargetF) FoxCompile ()
    
    // Compile the program for the fox32 architecture.

    // Initialize the SP and FP registers.

    FoxSp.Type = LIR_MACHINE_REG
    FoxSp.MachineRegister = FOX_SP

    FoxFp.Type = LIR_MACHINE_REG
    FoxFp.MachineRegister = FOX_FP

    // Perform instruction selection on each function.

    funcsym := PrsFunctionListHead

    WHILE funcsym DO
        LirSelectForFunction (
            funcsym, // funcsym
        )

        funcsym = funcsym^.NextFunction
    END

    // Do regalloc over the low level IR (LIR).

    funcsym = PrsFunctionListHead

    WHILE funcsym DO
        LirAllocateRegistersForFunction (
            funcsym, // funcsym
        )

        funcsym = funcsym^.NextFunction
    END

    // Emit the final assembly language.

    XrAsmEmit (
        &FoxAsmEmitter, // emitter
    )
END