//
// Implements linear scan register allocation.
//

#INCLUDE "<inc>/Target.hjk"

LirDefinedYetListHead : TlListEntry
LirIntervalListHead : TlListEntry

LirSortedIntervalListHead : TlListEntry

LirFirstBlock := FALSE

FN LirInsertionSortInterval (
    IN reg : ^LirRegister,
)

    // Insertion sort this interval into the sorted-by-start list, for which we
    // reuse IntervalListEntry. This should be average O(1) because they are
    // almost always in reverse order in the original list.

    head := &LirSortedIntervalListHead
    entry := head^.Next

    WHILE TRUE DO
        IF entry == head THEN
            TlInsertAtTailList (
                head, // head
                &reg^.IntervalListEntry, // entry
            )

            BREAK
        END

        otherreg := CONTAINEROF entry TO LirRegister.IntervalListEntry

        IF otherreg^.LivenessStart >= reg^.LivenessStart THEN
            // Insert ourselves before this guy.

            TlInsertAtTailList (
                entry, // head
                &reg^.IntervalListEntry, // entry
            )

            BREAK
        END

        entry = entry^.Next
    END
END

FN LirFlushDefinedYet ()

    // Flush the defined-yet list.

    head := &LirDefinedYetListHead
    entry := head^.Next

    WHILE entry != head DO
        reg := CONTAINEROF entry TO LirRegister.DefinedYetListEntry

        reg^.DefinedYet = FALSE

        TlRemoveEntryList ( entry )

        entry = entry^.Next
    END
END

FN LirRegFirstSighting (
    IN reg : ^LirRegister,
    IN firstinst : ^LirInstruction,
    IN inst : ^LirInstruction,
    IN instnum : ULONG,
)

    // Insert in interval list.

    // Insert at the head so that we end up with a mostly backwards sorted
    // list. This will make it faster to insertion sort it forwards in a
    // bit.

    TlInsertAtHeadList (
        &LirIntervalListHead, // head
        &reg^.IntervalListEntry, // entry
    )

    sym := reg^.Symbol

    paramtype := ARG_NULL

    IF sym THEN
        paramtype = sym^.ParameterType
    END

    IF paramtype == ARG_OUT THEN
        // OUT parameter. Live until end of function.

        IF NOT reg^.LivenessStart THEN
            reg^.LivenessFirst = inst
            reg^.LivenessStart = instnum
        END

        reg^.LivenessEnd = CAST -1 TO ULONG

    ELSEIF paramtype == ARG_IN THEN
        // IN parameter. Live from start of function.

        IF NOT reg^.LivenessStart THEN
            reg^.LivenessEnd = instnum
        END

        reg^.LivenessFirst = firstinst
        reg^.LivenessStart = 1

        IF LirFirstBlock THEN
            // Defined already.

            reg^.DefinedYet = TRUE

            TlInsertAtHeadList (
                &LirDefinedYetListHead, // head
                &reg^.DefinedYetListEntry, // entry
            )
        END

    ELSE
        // Otherwise.

        IF NOT reg^.LivenessStart THEN
            reg^.LivenessFirst = inst
            reg^.LivenessStart = instnum
            reg^.LivenessEnd = instnum
        END
    END
END

FN LirUseRegister (
    IN reg : ^LirRegister,
    IN firstinst : ^LirInstruction,
    IN inst : ^LirInstruction,
    IN instnum : ULONG,
)

    IF NOT reg^.LivenessStart THEN
        LirRegFirstSighting (
            reg, // reg
            firstinst, // firstinst
            inst, // inst
            instnum - 1, // instnum
        )
    END

    IF NOT reg^.DefinedYet THEN
        IF reg^.Type == LIR_PREALLOCATED_REG THEN
            reg^.DefinedYet = TRUE

            TlInsertAtHeadList (
                &LirDefinedYetListHead, // head
                &reg^.DefinedYetListEntry, // entry
            )
        
        ELSE
            // Use before def. Cover entire function.

            reg^.LivenessFirst = firstinst
            reg^.LivenessStart = 1
            reg^.LivenessEnd = CAST -1 TO ULONG
        END

    ELSEIF instnum > reg^.LivenessEnd THEN
        // Extend liveness range.

        reg^.LivenessEnd = instnum - 1
    END
END

FN LirDefRegister (
    IN reg : ^LirRegister,
    IN firstinst : ^LirInstruction,
    IN inst : ^LirInstruction,
    IN instnum : ULONG,
)

    IF NOT reg^.LivenessStart THEN
        LirRegFirstSighting (
            reg, // reg
            firstinst, // firstinst
            inst, // inst
            instnum, // instnum
        )
    END

    IF NOT reg^.DefinedYet THEN
        reg^.DefinedYet = TRUE

        TlInsertAtHeadList (
            &LirDefinedYetListHead, // head
            &reg^.DefinedYetListEntry, // entry
        )
    END
END

FN LirLivenessForFunction (
    IN irfunc : ^IrFunction,
)

    // Do a very simple liveness analysis with the following rules:
    //
    //  1. If a register is ever used before its first definition in a basic
    //     block, assume it is live across the entire function.
    //  2. Otherwise, its liveness interval is the region between its first
    //     definition and last use over the entire IR.
    //  3. If a register is an IN parameter, the above rules apply, except its
    //     liveness region must begin at the start of the function.
    //  4. If a register is an OUT parameter, the above rules apply, except its
    //     liveness region must conclude at the end of the function.
    //
    // The technical term for this is "god awful liveness analysis". Patent
    // pending.

    inst := irfunc^.LirHead
    instnum := 1

    LirFirstBlock = TRUE

    WHILE inst DO
        def := inst^.Defines
        src1 := inst^.Source1
        src2 := inst^.Source2

        IF src1 THEN
            LirUseRegister (
                src1, // reg
                irfunc^.LirHead, // firstinst
                inst, // inst
                instnum, // instnum
            )
        END

        IF src2 THEN
            LirUseRegister (
                src2, // reg
                irfunc^.LirHead, // firstinst
                inst, // inst
                instnum, // instnum
            )
        END

        IF def THEN
            LirDefRegister (
                def, // reg
                irfunc^.LirHead, // firstinst
                inst, // inst
                instnum, // instnum
            )
        END

        IF inst^.Type == LIR_BRANCH THEN
            // Since we're here, refcount labels.

            inst^.TypeBody.Branch.Label^.Body.Label.References += 1
        END

        IF inst^.Type == LIR_BRANCH OR inst^.Type == LIR_LABEL THEN
            // End of the basic block, empty the defined list.

            LirFlushDefinedYet ()
            LirFirstBlock = FALSE
        END

        inst = inst^.Next
        instnum += 1
    END

    // For each liveness interval, check if it's live across a function call.

    head := &LirIntervalListHead
    entry := head^.Next

    WHILE entry != head DO
        reg := CONTAINEROF entry TO LirRegister.IntervalListEntry

        liveinst := reg^.LivenessFirst

        count : UWORD

        IF reg^.LivenessEnd == -1 THEN
            count = -1

        ELSE
            count = reg^.LivenessEnd - reg^.LivenessStart + 1
        END

        i := 0

        WHILE liveinst AND count DO
            IF liveinst^.Type == LIR_CALL THEN
                reg^.LiveAcrossCall = TRUE

                BREAK
            END

            liveinst = liveinst^.Next
            count -= 1
            i += 1
        END

        // While we're at it, insertion sort this entry.

        nextentry := entry^.Next

        LirInsertionSortInterval ( reg )

        entry = nextentry
    END
END

FN LirResetRegPool ()

    // Reset the register allocation map.

    lirinfo := JklTargetInfo^.LirInfo

    i := 0
    max := lirinfo^.MaximumRegister
    statmap := &lirinfo^.RegisterAllocationStatus[0]
    everalloced := &LirCurrentFunction^.RegisterAllocationStatus[0]
    abimap := &lirinfo^.RegisterAbiUsage[0]

    WHILE i < max DO
        IF abimap[i] == LIR_REG_UNUSABLE THEN
            statmap[i] = TRUE

        ELSE
            statmap[i] = FALSE
        END

        everalloced[i] = FALSE

        i += 1
    END
END

FN LirAllocateRegister (
    IN calleesavedonly : UBYTE,
    IN hint : UBYTE,
) : UWORD

    // Allocate a machine register. Returns -1 on failure.

    lirinfo := JklTargetInfo^.LirInfo

    statmap := &lirinfo^.RegisterAllocationStatus[0]
    abimap := &lirinfo^.RegisterAbiUsage[0]
    everalloced := &LirCurrentFunction^.RegisterAllocationStatus[0]

    IF hint AND
        NOT statmap[hint] AND
        (NOT calleesavedonly OR abimap[hint] == LIR_REG_CALLEE_SAVED) THEN

        // Take the hint.

        statmap[hint] = TRUE
        everalloced[hint] = TRUE

        RETURN hint
    END

    i := 0
    max := lirinfo^.MaximumRegister

    WHILE i < max DO
        IF NOT statmap[i] THEN
            IF NOT calleesavedonly OR abimap[i] == LIR_REG_CALLEE_SAVED THEN
                statmap[i] = TRUE
                everalloced[i] = TRUE

                RETURN i
            END
        END

        i += 1
    END

    RETURN -1
END

FN LirFreeRegister (
    IN reg : UBYTE,
)

    lirinfo := JklTargetInfo^.LirInfo

    statmap := &lirinfo^.RegisterAllocationStatus[0]
    abimap := &lirinfo^.RegisterAbiUsage[0]

    // An unusable reg might get freed when a preallocated machine reg's live
    // interval expires, so prevent that. We never ever allocate unusable regs,
    // those are entirely the province of the target specific code.

    IF abimap[reg] != LIR_REG_UNUSABLE THEN
        statmap[reg] = FALSE
    END
END

LirActiveIntervalList : TlListEntry

FN LirAddToActiveList (
    IN reg : ^LirRegister,
)

    // Insertion sort into the active list by end point.

    head := &LirActiveIntervalList
    entry := head^.Next

    WHILE TRUE DO
        IF entry == head THEN
            TlInsertAtTailList (
                head, // head
                &reg^.DefinedYetListEntry, // entry
            )

            BREAK
        END

        otherreg := CONTAINEROF entry TO LirRegister.DefinedYetListEntry

        IF otherreg^.LivenessEnd >= reg^.LivenessEnd THEN
            // Insert ourselves before this guy.

            TlInsertAtTailList (
                entry, // head
                &reg^.DefinedYetListEntry, // entry
            )

            BREAK
        END

        entry = entry^.Next
    END
END

FN LirExpireOldIntervals (
    IN reg : ^LirRegister,
)

    head := &LirActiveIntervalList
    entry := head^.Next

    WHILE head != entry DO
        otherreg := CONTAINEROF entry TO LirRegister.DefinedYetListEntry

        IF otherreg^.LivenessEnd >= reg^.LivenessStart THEN
            LEAVE
        END

        LirFreeRegister ( otherreg^.MachineRegister )

        TlRemoveEntryList ( entry )

        entry = entry^.Next
    END
END

FN LirSpillAtInterval (
    IN reg : ^LirRegister,
)

    // Look at the last entry in the active list.

    head := &LirActiveIntervalList
    spillentry := head^.Prev

    WHILE spillentry != head DO
        spillreg := CONTAINEROF spillentry TO LirRegister.DefinedYetListEntry

        IF spillreg^.Type == LIR_PREALLOCATED_REG THEN
            spillentry = spillentry^.Prev

            CONTINUE
        END

        IF spillreg^.LivenessEnd > reg^.LivenessEnd THEN
            // Spill that register and steal its machine reg.

            reg^.MachineRegister = spillreg^.MachineRegister
            reg^.Type = LIR_MACHINE_REG

            TlRemoveEntryList ( spillentry )

            spillreg^.Type = LIR_SPILLED_REG

            // Insert this reg into the active list.

            LirAddToActiveList ( reg )

        ELSE
            // Spill this register.

            reg^.Type = LIR_SPILLED_REG
        END

        LEAVE
    END

    TlInternalError (
        "LirSpillAtInterval: Too many preallocated registers", 0, 0, 0 )
END

FN LirPreallocateRegister (
    IN reg : UBYTE,
)

    // Pre-allocate a machine reg.

    lirinfo := JklTargetInfo^.LirInfo

    statmap := &lirinfo^.RegisterAllocationStatus[0]
    abimap := &lirinfo^.RegisterAbiUsage[0]

    IF abimap[reg] == LIR_REG_UNUSABLE THEN
        // Don't care. Nobody else can be using it.

        LEAVE
    END

    IF NOT statmap[reg] THEN
        // Nobody was using it; good.

        statmap[reg] = TRUE

        LEAVE
    END

    // Scan the active list.

    head := &LirActiveIntervalList
    entry := head^.Next

    WHILE head != entry DO
        otherreg := CONTAINEROF entry TO LirRegister.DefinedYetListEntry

        IF otherreg^.MachineRegister == reg THEN
            // Found the sucker.

            IF otherreg^.Type == LIR_PREALLOCATED_REG THEN
                TlInternalError ( "Can't steal from preallocated reg",
                    otherreg^.MachineRegister, 0, 0 )
            END

            newreg := LirAllocateRegister (
                otherreg^.LiveAcrossCall, // calleesavedonly
                0, // hint
            )

            IF newreg == -1 THEN
                // Sucks for him, spill him.

                otherreg^.Type = LIR_SPILLED_REG

                TlRemoveEntryList ( entry )

            ELSE
                // Give him this new machine register.

                otherreg^.MachineRegister = reg
            END

            LEAVE
        END

        entry = entry^.Next
    END
END

FN LirLinearScan ()

    // Linear scan register allocation.

    // First reset the regalloc pool.

    LirResetRegPool ()

    // Reset the active list.

    TlInitializeList ( &LirActiveIntervalList )

    head := &LirSortedIntervalListHead
    entry := head^.Next

    WHILE head != entry DO
        reg := CONTAINEROF entry TO LirRegister.IntervalListEntry

        LirExpireOldIntervals ( reg )

        IF reg^.Type == LIR_VIRTUAL_REG THEN
            machinereg := LirAllocateRegister (
                reg^.LiveAcrossCall, // calleesavedonly
                reg^.Hint, // hint
            )

            IF machinereg == -1 THEN
                LirSpillAtInterval ( reg )

            ELSE
                reg^.MachineRegister = machinereg
                reg^.Type = LIR_MACHINE_REG

                LirAddToActiveList ( reg )
            END

        ELSEIF reg^.Type == LIR_PREALLOCATED_REG THEN
            // Must be a pre-allocated machine reg. If someone else is using it
            // we have to kick their ass and make them grab another one, or
            // spill them.

            LirPreallocateRegister ( reg^.MachineRegister )

            LirAddToActiveList ( reg )
        
        ELSE
            TlInternalError ( "LirLinearScan: Incorrect reg type", 0, 0, 0 )
        END

        entry = entry^.Next
    END
END

FN LirAllocateRegistersForFunction (
    IN funcsym : ^LexSymbol,
)

    // Perform linear scan register allocation over the function LIR.

    irfunc := CAST funcsym^.InitialValue TO ^IrFunction

    // Initialize structures.

    TlInitializeList ( &LirDefinedYetListHead )

    TlInitializeList ( &LirIntervalListHead )

    TlInitializeList ( &LirSortedIntervalListHead )

    LirCurrentFunction = irfunc

    // First do a simple liveness analysis.

    LirLivenessForFunction ( irfunc )

    // Now do linear scan.

    LirLinearScan ()

    // TlInternalError ( "LirAllocateRegistersForFunction: TODO", 0, 0, 0 )
END