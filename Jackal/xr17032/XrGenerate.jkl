//
// Implements the XR/17032 code generator.
//

#INCLUDE "<inc>/Target.hjk"
#INCLUDE "<inc>/XrSdkAsm.hjk"

// FORWARD
EXTERN FN (JklTargetF) XrCompile ()

// FORWARD
EXTERN FN (JklValueNumberF) XrValueNumber (
    IN constant : UWORD,
) : UBYTE

// FORWARD
EXTERN XrLirInfo : LirTargetInfoRecord

PUBLIC XrTargetInfo : JklTargetInfoRecord = {
    [Name] = "xr17032",
    [EntryFunc] = &XrCompile,
    [ValueNumberConstantFunc] = &XrValueNumber,
    [FoldStackAddr] = TRUE,
    [LirInfo] = &XrLirInfo,
    [ConstantMask] = 0xFFFFFFFF,
    [StackAlignment] = 4,
    [PointerAlignment] = 4,
    [PointerSize] = 4,
    [CodeAlignment] = 1,
    [LargestPrimitive] = PRIM_TYPE_ULONG,
    [LargestSignedPrimitive] = PRIM_TYPE_LONG,
    [SupportedTypes] = {
        [PRIM_TYPE_VOID] = TRUE,
        [PRIM_TYPE_UBYTE] = TRUE,
        [PRIM_TYPE_UINT] = TRUE,
        [PRIM_TYPE_ULONG] = TRUE,
        [PRIM_TYPE_UQUAD] = FALSE,
        [PRIM_TYPE_BYTE] = TRUE,
        [PRIM_TYPE_INT] = TRUE,
        [PRIM_TYPE_LONG] = TRUE,
        [PRIM_TYPE_QUAD] = FALSE,
    },
    [PrimitiveAlignment] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
    [PrimitiveSize] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
}

ENUM XrRegisters : UBYTE
    XR_NULL,

    XR_ZERO,
    XR_T0,
    XR_T1,
    XR_T2,
    XR_T3,
    XR_T4,
    XR_T5,
    XR_A0,
    XR_A1,
    XR_A2,
    XR_A3,
    XR_S0,
    XR_S1,
    XR_S2,
    XR_S3,
    XR_S4,
    XR_S5,
    XR_S6,
    XR_S7,
    XR_S8,
    XR_S9,
    XR_S10,
    XR_S11,
    XR_S12,
    XR_S13,
    XR_S14,
    XR_S15,
    XR_S16,
    XR_S17,

    XR_SP,
    XR_LR,

    XR_REG_MAX,
END

XrRegisterNames : ^UBYTE[XR_REG_MAX] = {
    [XR_ZERO] = "zero",
    [XR_T0] = "t0",
    [XR_T1] = "t1",
    [XR_T2] = "t2",
    [XR_T3] = "t3",
    [XR_T4] = "t4",
    [XR_T5] = "t5",
    [XR_A0] = "a0",
    [XR_A1] = "a1",
    [XR_A2] = "a2",
    [XR_A3] = "a3",
    [XR_S0] = "s0",
    [XR_S1] = "s1",
    [XR_S2] = "s2",
    [XR_S3] = "s3",
    [XR_S4] = "s4",
    [XR_S5] = "s5",
    [XR_S6] = "s6",
    [XR_S7] = "s7",
    [XR_S8] = "s8",
    [XR_S9] = "s9",
    [XR_S10] = "s10",
    [XR_S11] = "s11",
    [XR_S12] = "s12",
    [XR_S13] = "s13",
    [XR_S14] = "s14",
    [XR_S15] = "s15",
    [XR_S16] = "s16",
    [XR_S17] = "s17",
    [XR_SP] = "sp",
    [XR_LR] = "lr",
}

// Note that these have little relation to machine instructions but rather to
// the assembler's set of "pseudo-instructions".

ENUM XrInstructionTypes : UBYTE
    XR_INST_NULL,

    XR_B,
    XR_RET,
    XR_JR,
    XR_MOV_REG,
    XR_LI,
    XR_LA,
    XR_LSHI,
    XR_RSHI,
    XR_ASHI,
    XR_SEQ,
    XR_SEQI,
    XR_SNE,
    XR_SNEI,
    XR_JAL,
    XR_J,
    XR_BEQ,
    XR_BNE,
    XR_BLT,
    XR_BGT,
    XR_BLE,
    XR_BGE,
    XR_BPE,
    XR_BPO,
    XR_ADDI,
    XR_SUBI,
    XR_SLTI,
    XR_SLTI_SIGNED,
    XR_ANDI,
    XR_XORI,
    XR_ORI,
    XR_LUI,
    XR_JALR,
    XR_ADD,
    XR_SUB,
    XR_SLT,
    XR_SLT_SIGNED,
    XR_AND,
    XR_XOR,
    XR_OR,
    XR_MOV_LOAD,
    XR_MOV_LOAD_INLINED,
    XR_MOV_STORE,
    XR_MOV_STORE_INLINED,
    XR_LSH,
    XR_RSH,
    XR_ASH,
    XR_MUL,
    XR_DIV,
    XR_DIV_SIGNED,
    XR_MOD,
    XR_NOR,

    XR_INST_MAX,
END

XrInstructionNames : ^UBYTE[XR_INST_MAX] = {
    [XR_B] = "b",
    [XR_RET] = "ret",
    [XR_JR] = "jr",
    [XR_MOV_REG] = "mov",
    [XR_LI] = "li",
    [XR_LA] = "la",
    [XR_LSHI] = "lshi",
    [XR_RSHI] = "rshi",
    [XR_ASHI] = "ashi",
    [XR_SEQ] = "seq",
    [XR_SEQI] = "seqi",
    [XR_SNE] = "sne",
    [XR_SNEI] = "snei",
    [XR_JAL] = "jal",
    [XR_J] = "j",
    [XR_BEQ] = "beq",
    [XR_BNE] = "bne",
    [XR_BLT] = "blt",
    [XR_BGT] = "bgt",
    [XR_BLE] = "ble",
    [XR_BPE] = "bpe",
    [XR_BPO] = "bpo",
    [XR_ADDI] = "addi",
    [XR_SUBI] = "subi",
    [XR_SLTI] = "slti",
    [XR_SLTI_SIGNED] = "slti signed",
    [XR_ANDI] = "andi",
    [XR_XORI] = "xori",
    [XR_ORI] = "ori",
    [XR_LUI] = "lui",
    [XR_JALR] = "jalr",
    [XR_ADD] = "add",
    [XR_SUB] = "sub",
    [XR_SLT] = "slt",
    [XR_SLT_SIGNED] = "slt signed",
    [XR_AND] = "and",
    [XR_XOR] = "xor",
    [XR_OR] = "or",
    [XR_MOV_LOAD] = "mov",
    [XR_MOV_LOAD_INLINED] = "mov",
    [XR_MOV_STORE] = "mov",
    [XR_MOV_STORE_INLINED] = "mov",
    [XR_LSH] = "lsh",
    [XR_RSH] = "rsh",
    [XR_ASH] = "ash",
    [XR_MUL] = "mul",
    [XR_DIV] = "div",
    [XR_DIV_SIGNED] = "div signed",
    [XR_MOD] = "mod",
    [XR_NOR] = "nor",
}

ENUM XrBits : UBYTE
    XR_BITS_8,
    XR_BITS_16,
    XR_BITS_32,

    XR_BITS_MAX,
END

ENUM XrAccessType : UBYTE
    XR_ACCESS_NONE,
    XR_ACCESS_REGISTER,
    XR_ACCESS_ZERO,
    XR_ACCESS_IMM,
    XR_ACCESS_IMM_NAME,
    XR_ACCESS_IMM_STRING,
    XR_ACCESS_IMM_LABEL,
END

XrPrimTypeToBits : UBYTE[PRIM_TYPE_MAX] = {
    [PRIM_TYPE_BYTE] = XR_BITS_8,
    [PRIM_TYPE_INT] = XR_BITS_16,
    [PRIM_TYPE_LONG] = XR_BITS_32,

    [PRIM_TYPE_UBYTE] = XR_BITS_8,
    [PRIM_TYPE_UINT] = XR_BITS_16,
    [PRIM_TYPE_ULONG] = XR_BITS_32,

    [PRIM_TYPE_POINTER] = XR_BITS_32,
}

XrBitsToMaximumOffset : UWORD[XR_BITS_MAX] = {
    [XR_BITS_8] = 65536,
    [XR_BITS_16] = 131072,
    [XR_BITS_32] = 262144,
}

ENUM XrShiftTypes : UBYTE
    XR_SHIFT_LSH,
    XR_SHIFT_RSH,
    XR_SHIFT_ASH,

    XR_SHIFT_MAX,
END

XrShiftTypeNames : ^UBYTE[XR_SHIFT_MAX] = {
    [XR_SHIFT_LSH] = "LSH",
    [XR_SHIFT_RSH] = "RSH",
    [XR_SHIFT_ASH] = "ASH",
}

XrTmps : LirRegister[3]
XrSp : LirRegister
XrLr : LirRegister
XrCalleeSaved : LirRegister[XR_S17 - XR_S0 + 1]
XrArg : LirRegister[XR_A3 - XR_A0 + 1]

FN XrCreateInstruction (
    IN type : LirInstructionType,
    IN machtype : UBYTE,
) : ^LirInstruction

    inst := LirCreateInstruction (
        type, // type
        machtype, // machtype
    )

    inst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_NONE
    inst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_NONE
    inst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_NONE

    inst^.Body.Machine.Xr.Op1.Constant = 0
    inst^.Body.Machine.Xr.Op2.Constant = 0
    inst^.Body.Machine.Xr.Op3.Constant = 0

    inst^.Body.Machine.Xr.ShiftAmount = 0
    inst^.Body.Machine.Xr.BitSize = XR_BITS_32

    RETURN inst
END

FN XrFillAccess (
    IN inst : ^IrInstruction,
    IN lirinst : ^LirInstruction,
)

    // Fill Source2 and Source3 of the lirinst instruction with relevant
    // junk for this access. It's always in that spot for both loads and stores.
    // Source1 is the value to store, if relevant.

    bits := XrPrimTypeToBits[inst^.Body.LoadStore.Type]

    lirinst^.Body.Machine.Xr.BitSize = bits

    // Base is always a register.

    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    srcvar := inst^.Source1
    srcinst := srcvar^.DefinedBy

    IF NOT srcinst THEN
        // Just fill it with a zero offset.

        lirinst^.Source2 = LirGetRegister ( inst^.Source1 )
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_ZERO

        LEAVE
    END

    IF srcinst^.Type == IR_STACK_ADDR THEN
        // It's on the stack frame, this is an SP + OFF. 

        symbol := srcinst^.Body.Addr.Symbol

        off := srcinst^.Body.Addr.Offset + IrGetStackOffset (
            LirCurrentFunction, // func
            symbol, // symbol
        ) + LirCurrentFunction^.ScratchAreaSize

        IF off < XrBitsToMaximumOffset[bits] THEN
            // Great! We can do this directly.

            lirinst^.Body.Machine.Xr.Op3.Constant = off
            lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

            lirinst^.Source2 = LirCreatePreallocatedRegister ( XR_SP )

            LEAVE
        END

    ELSEIF srcinst^.Type == IR_ADDR THEN
        // Gotta be a named imm.
        // If the refcount on the variable is low, we can inline this by a
        // pseudo-instruction. Above two uses of it, it's more worthwhile to
        // allow XrSelectAddr to calculate the address into a reusable temporary
        // register.

        IF srcvar^.Opt.Dve.References < 3 THEN
            lirinst^.Body.Machine.Xr.Op2.Constant =
                CAST srcinst^.Body.Addr.Symbol TO UWORD

            lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM_NAME

            IF lirinst^.MachineInstruction == XR_MOV_STORE THEN
                lirinst^.MachineInstruction = XR_MOV_STORE_INLINED

                // Inlined stores require a temp register to trash.

                lirinst^.Defines = LirCreateRegister ()

            ELSE
                lirinst^.MachineInstruction = XR_MOV_LOAD_INLINED
            END

            LEAVE
        END

    ELSEIF srcinst^.Type == IR_ADD THEN
        // TODO NEXT: `add` cases; shifts; etc

    END

    // Just fill it with a zero offset from the register.

    lirinst^.Source2 = LirSelect ( srcinst )

    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_ZERO
END

FN (LirSelectF) XrSelectLoad (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a mem-to-reg MOV instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_LOAD, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    XrFillAccess (
        inst, // inst
        lirinst, // lirinst
    )

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

XrLirInfo : LirTargetInfoRecord = {
    [SelectionTable] = {
        [IR_LOAD] = &XrSelectLoad,
#IF 0
        [IR_ADDR] = &XrSelectAddr,
        [IR_STRING_ADDR] = &XrSelectAddr,
        [IR_STACK_ADDR] = &XrSelectStackAddr,
        [IR_CONSTANT] = &XrSelectAddr,
        [IR_MOVE] = &XrSelectMove,

        [IR_RETURN] = &XrSelectReturn,

        [IR_BRANCH_NONZERO] = &XrSelectZeroBranch,
        [IR_BRANCH_ZERO] = &XrSelectZeroBranch,

        [IR_BRANCH_EQUALS] = &XrSelectBranch,
        [IR_BRANCH_NOT_EQUALS] = &XrSelectBranch,
        [IR_BRANCH_LESS_THAN] = &XrSelectBranch,
        [IR_BRANCH_GREATER_THAN] = &XrSelectBranch,
        [IR_BRANCH_LTEQ] = &XrSelectBranch,
        [IR_BRANCH_GTEQ] = &XrSelectBranch,
        [IR_BRANCH_LESS_THAN_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_GREATER_THAN_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_LTEQ_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_GTEQ_SIGNED] = &XrSelectBranch,
        [IR_JUMP] = &XrSelectJump,

        [IR_CALL] = &XrSelectCall,
        [IR_STORE] = &XrSelectStore,

        [IR_COMPARE_EQUALS] = &XrSelectCompare,
        [IR_COMPARE_NOT_EQUALS] = &XrSelectCompare,
        [IR_COMPARE_LESS_THAN] = &XrSelectCompare,
        [IR_COMPARE_GREATER_THAN] = &XrSelectCompare,
        [IR_COMPARE_LTEQ] = &XrSelectCompare,
        [IR_COMPARE_GTEQ] = &XrSelectCompare,
        [IR_COMPARE_LESS_THAN_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_GREATER_THAN_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_LTEQ_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_GTEQ_SIGNED] = &XrSelectCompare,

        [IR_NOT] = &XrSelectNot,

        [IR_BIT_AND] = &XrSelectArithmetic,
        [IR_BIT_OR] = &XrSelectArithmetic,
        [IR_ADD] = &XrSelectArithmetic,
        [IR_SUBTRACT] = &XrSelectArithmetic,
        [IR_DIVIDE] = &XrSelectArithmetic,
        [IR_DIVIDE_SIGNED] = &XrSelectArithmetic,
        [IR_MODULO] = &XrSelectArithmetic,
        [IR_BIT_XOR] = &XrSelectArithmetic,
        [IR_LEFT_SHIFT] = &XrSelectArithmetic,
        [IR_RIGHT_SHIFT] = &XrSelectArithmetic,
        [IR_MULTIPLY] = &XrSelectArithmetic,

        [IR_BIT_NOT] = &XrSelectBitNot,
#END
    },
    [RegisterAbiUsage] = {
        [XR_T0] = LIR_REG_CALLER_SAVED,
        [XR_T1] = LIR_REG_CALLER_SAVED,
        [XR_T2] = LIR_REG_CALLER_SAVED,
        [XR_A0] = LIR_REG_CALLER_SAVED,
        [XR_A1] = LIR_REG_CALLER_SAVED,
        [XR_A2] = LIR_REG_CALLER_SAVED,
        [XR_A3] = LIR_REG_CALLER_SAVED,
        [XR_S0] = LIR_REG_CALLEE_SAVED,
        [XR_S1] = LIR_REG_CALLEE_SAVED,
        [XR_S2] = LIR_REG_CALLEE_SAVED,
        [XR_S3] = LIR_REG_CALLEE_SAVED,
        [XR_S4] = LIR_REG_CALLEE_SAVED,
        [XR_S5] = LIR_REG_CALLEE_SAVED,
        [XR_S6] = LIR_REG_CALLEE_SAVED,
        [XR_S7] = LIR_REG_CALLEE_SAVED,
        [XR_S8] = LIR_REG_CALLEE_SAVED,
        [XR_S9] = LIR_REG_CALLEE_SAVED,
        [XR_S10] = LIR_REG_CALLEE_SAVED,
        [XR_S11] = LIR_REG_CALLEE_SAVED,
        [XR_S12] = LIR_REG_CALLEE_SAVED,
        [XR_S13] = LIR_REG_CALLEE_SAVED,
        [XR_S14] = LIR_REG_CALLEE_SAVED,
        [XR_S15] = LIR_REG_CALLEE_SAVED,
        [XR_S16] = LIR_REG_CALLEE_SAVED,
        [XR_S17] = LIR_REG_CALLEE_SAVED,
    },
    [MaximumRegister] = XR_REG_MAX,
}

FN XrHintFunction (
    IN funcsym : ^LexSymbol,
)

    // Hint the first four arguments to a0-a3.

    functype := funcsym^.SemanticType

    arg := functype^.Body.Function.ArgListHead

    incount := 0
    outcount := 0

    WHILE arg DO
        symbol := arg^.Symbol

        irvar := CAST symbol^.IrContext TO ^IrVariable

        IF irvar THEN
            irreg := LirGetRegister ( irvar )

            IF arg^.InOut == ARG_IN AND incount < 4 THEN
                irreg^.Hint = XR_A0 + incount

            ELSEIF arg^.InOut == ARG_OUT AND outcount < 3 THEN
                irreg^.Hint = XR_A2 - outcount
            END
        END

        IF arg^.InOut == ARG_IN THEN
            incount += 1

        ELSE
            outcount += 1
        END

        arg = arg^.Next
    END

    IF functype^.Body.Function.IsVarArg THEN
        // Hint the vartable and argcount symbols.

        i := 0

        WHILE incount < 4 DO
            symbol : ^LexSymbol

            IF NOT i THEN
                symbol = functype^.Body.Function.VarArgTable

            ELSE
                symbol = functype^.Body.Function.VarArgCount
            END

            irvar := CAST symbol^.IrContext TO ^IrVariable

            IF irvar THEN
                irreg := LirGetRegister ( irvar )

                irreg^.Hint = XR_A0 + incount
            END

            incount += 1
            i += 1
        END
    END
END

FN XrGenerateSpills (
    IN irfunc : ^IrFunction,
)

    TlInternalError ( "TODO XrGenerateSpills", 0, 0, 0 )
END

FN XrGenerateAbiStuff (
    IN funcsym : ^LexSymbol,
    IN irfunc : ^IrFunction,
)

    TlInternalError ( "TODO XrGenerateAbiStuff", 0, 0, 0 )
END

XrNextBranchNumber := 0

FN XrEmitInstruction (
    IN lirinst : ^LirInstruction,
)

    IF lirinst^.Type == LIR_MACH_INST OR
        lirinst^.Type == LIR_CALL OR
        lirinst^.Type == LIR_BRANCH OR
        lirinst^.Type == LIR_RETURN THEN

        TlInternalError ( "TODO XrEmitInstruction", 0, 0, 0 )

    ELSEIF lirinst^.Type == LIR_LABEL THEN
        num := lirinst^.Body.Label.Number

        IF num == 0xFFFFFFFF THEN
            num = XrNextBranchNumber
            lirinst^.Body.Label.Number = num

            XrNextBranchNumber += 1
        END

        XrAsmInsertString ( ".L" )
        XrAsmInsertNumber ( num )
        XrAsmInsertString ( ":\n" )

    ELSE
        TlInternalError ( "Xr: Weird LIR type", lirinst^.Type, 0, 0 )
    END
END

FN XrElideUselessJump (
    IN inst : ^LirInstruction,
) : UWORD

    // Check if this branch instruction is followed by both its true and false
    // label. We walk along each label until we reach the first non-label
    // instruction so that we catch all the cases.

    next := inst^.Next

    WHILE next AND next^.Type == LIR_LABEL DO
        IF inst^.TypeBody.Branch.Label == next THEN
            next^.Body.Label.References -= 1

            RETURN TRUE
        END

        next = next^.Next
    END

    RETURN FALSE
END

FN (AsmEmitF) XrEmitFunction (
    IN funcsym : ^LexSymbol,
)

    // Emit the final assembly language for a function.

    irfunc := CAST funcsym^.InitialValue TO ^IrFunction

    inst := irfunc^.LirHead

    WHILE inst DO
        IF inst^.Type == LIR_LABEL AND NOT inst^.Body.Label.References THEN
            inst = inst^.Next

            CONTINUE
        END

        IF inst^.Type == LIR_BRANCH AND XrElideUselessJump ( inst ) THEN
            inst = inst^.Next

            CONTINUE
        END

        XrEmitInstruction ( inst )

        inst = inst^.Next
    END
END

XrAsmEmitter : AsmEmitterRecord = {
    [EmitFunc] = &XrEmitFunction,
}

FN (JklValueNumberF) XrValueNumber (
    IN constant : UWORD,
) : UBYTE

    // Return whether to value number this constant.
    // Doing this too much could create too many callee-saved registers if the
    // constant is live over a function call. Doing it too little will
    // recompute large constants too much.

    IF constant < 65536 THEN
        // It probably fits in an instruction, don't bother.

        RETURN FALSE
    END

    IF constant >= 0xFFFF0001 THEN
        // It can be loaded with a single SUBI instruction, don't bother.

        RETURN FALSE
    END

    IF constant & 0xFFFF == 0 THEN
        // It can be loaded with a single LUI instruction, don't bother.

        RETURN FALSE
    END

    // Takes two instructions to load. Bother.

    RETURN TRUE
END

FN (JklTargetF) XrCompile ()
    
    // Compile the program for the XR/17032 architecture.

    XrTmps[0].Type = LIR_PREALLOCATED_REG
    XrTmps[0].MachineRegister = XR_T3

    XrTmps[1].Type = LIR_PREALLOCATED_REG
    XrTmps[1].MachineRegister = XR_T4

    XrTmps[2].Type = LIR_PREALLOCATED_REG
    XrTmps[2].MachineRegister = XR_T5

    XrSp.Type = LIR_PREALLOCATED_REG
    XrSp.MachineRegister = XR_SP

    XrLr.Type = LIR_PREALLOCATED_REG
    XrLr.MachineRegister = XR_LR

    i := 0

    WHILE i < (XR_S17 - XR_S0 + 1) DO
        XrCalleeSaved[i].Type = LIR_PREALLOCATED_REG
        XrCalleeSaved[i].MachineRegister = XR_S0 + i

        i += 1
    END

    i = 0

    WHILE i < (XR_A3 - XR_A0 + 1) DO
        XrArg[i].Type = LIR_PREALLOCATED_REG
        XrArg[i].MachineRegister = XR_A0 + i

        i += 1
    END

    // Perform instruction selection on each function.

    funcsym := PrsFunctionListHead

    WHILE funcsym DO
        // Calculate the scratch area size.

        irfunc := CAST funcsym^.InitialValue TO ^IrFunction

        inscratch := 0

        IF irfunc^.MaximumInCount > 4 THEN
            inscratch = (irfunc^.MaximumInCount - 4) * 4
        END

        outscratch := 0

        IF irfunc^.MaximumOutCount > 3 THEN
            outscratch = (irfunc^.MaximumOutCount - 3) * 4
        END

        IF inscratch > outscratch THEN
            irfunc^.ScratchAreaSize = inscratch
        
        ELSE
            irfunc^.ScratchAreaSize = outscratch
        END

        LirSelectForFunction ( funcsym )

        funcsym = funcsym^.NextFunction
    END

    // Do regalloc over the low level IR (LIR).

    funcsym = PrsFunctionListHead

    WHILE funcsym DO
        // Apply hints to the formal parameters.

        XrHintFunction ( funcsym )

        // Do regalloc.

        LirAllocateRegistersForFunction ( funcsym )

        // Generate spill code.

        irfunc := CAST funcsym^.InitialValue TO ^IrFunction

        XrGenerateSpills ( irfunc )

        // Generate the prologue and epilogue.

        XrGenerateAbiStuff ( funcsym, irfunc )

        funcsym = funcsym^.NextFunction
    END

    // Emit the final assembly language.

    XrAsmEmit (
        &XrAsmEmitter, // emitter
    )
END