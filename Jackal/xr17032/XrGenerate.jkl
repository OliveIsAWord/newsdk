//
// Implements the XR/17032 code generator.
//

#INCLUDE "<inc>/Target.hjk"
#INCLUDE "<inc>/XrSdkAsm.hjk"

// FORWARD
EXTERN FN (JklTargetF) XrCompile ()

// FORWARD
EXTERN FN (JklValueNumberF) XrValueNumber (
    IN constant : UWORD,
) : UBYTE

// FORWARD
EXTERN XrLirInfo : LirTargetInfoRecord

PUBLIC XrTargetInfo : JklTargetInfoRecord = {
    [Name] = "xr17032",
    [EntryFunc] = &XrCompile,
    [ValueNumberConstantFunc] = &XrValueNumber,
    [FoldStackAddr] = TRUE,
    [LirInfo] = &XrLirInfo,
    [ConstantMask] = 0xFFFFFFFF,
    [StackAlignment] = 4,
    [PointerAlignment] = 4,
    [PointerSize] = 4,
    [CodeAlignment] = 1,
    [LargestPrimitive] = PRIM_TYPE_ULONG,
    [LargestSignedPrimitive] = PRIM_TYPE_LONG,
    [SupportedTypes] = {
        [PRIM_TYPE_VOID] = TRUE,
        [PRIM_TYPE_UBYTE] = TRUE,
        [PRIM_TYPE_UINT] = TRUE,
        [PRIM_TYPE_ULONG] = TRUE,
        [PRIM_TYPE_UQUAD] = FALSE,
        [PRIM_TYPE_BYTE] = TRUE,
        [PRIM_TYPE_INT] = TRUE,
        [PRIM_TYPE_LONG] = TRUE,
        [PRIM_TYPE_QUAD] = FALSE,
    },
    [PrimitiveAlignment] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
    [PrimitiveSize] = {
        [PRIM_TYPE_VOID] = 0,
        [PRIM_TYPE_UBYTE] = 1,
        [PRIM_TYPE_UINT] = 2,
        [PRIM_TYPE_ULONG] = 4,
        [PRIM_TYPE_UQUAD] = 8,
        [PRIM_TYPE_BYTE] = 1,
        [PRIM_TYPE_INT] = 2,
        [PRIM_TYPE_LONG] = 4,
        [PRIM_TYPE_QUAD] = 8,
    },
}

ENUM XrRegisters : UBYTE
    XR_NULL,

    XR_ZERO,
    XR_T0,
    XR_T1,
    XR_T2,
    XR_T3,
    XR_T4,
    XR_T5,
    XR_A0,
    XR_A1,
    XR_A2,
    XR_A3,
    XR_S0,
    XR_S1,
    XR_S2,
    XR_S3,
    XR_S4,
    XR_S5,
    XR_S6,
    XR_S7,
    XR_S8,
    XR_S9,
    XR_S10,
    XR_S11,
    XR_S12,
    XR_S13,
    XR_S14,
    XR_S15,
    XR_S16,
    XR_S17,

    XR_SP,
    XR_LR,

    XR_REG_MAX,
END

XrRegisterNames : ^UBYTE[XR_REG_MAX] = {
    [XR_ZERO] = "zero",
    [XR_T0] = "t0",
    [XR_T1] = "t1",
    [XR_T2] = "t2",
    [XR_T3] = "t3",
    [XR_T4] = "t4",
    [XR_T5] = "t5",
    [XR_A0] = "a0",
    [XR_A1] = "a1",
    [XR_A2] = "a2",
    [XR_A3] = "a3",
    [XR_S0] = "s0",
    [XR_S1] = "s1",
    [XR_S2] = "s2",
    [XR_S3] = "s3",
    [XR_S4] = "s4",
    [XR_S5] = "s5",
    [XR_S6] = "s6",
    [XR_S7] = "s7",
    [XR_S8] = "s8",
    [XR_S9] = "s9",
    [XR_S10] = "s10",
    [XR_S11] = "s11",
    [XR_S12] = "s12",
    [XR_S13] = "s13",
    [XR_S14] = "s14",
    [XR_S15] = "s15",
    [XR_S16] = "s16",
    [XR_S17] = "s17",
    [XR_SP] = "sp",
    [XR_LR] = "lr",
}

// Note that these have little relation to machine instructions but rather to
// the assembler's set of "pseudo-instructions".

ENUM XrInstructionTypes : UBYTE
    XR_INST_NULL,

    XR_B,
    XR_RET,
    XR_JR,
    XR_MOV_REG,
    XR_LI,
    XR_LA,
    XR_LSHI,
    XR_RSHI,
    XR_ASHI,
    XR_SEQ,
    XR_SEQI,
    XR_SNE,
    XR_SNEI,
    XR_JAL,
    XR_J,
    XR_BEQ,
    XR_BNE,
    XR_BLT,
    XR_BGT,
    XR_BLE,
    XR_BGE,
    XR_BPE,
    XR_BPO,
    XR_ADDI,
    XR_SUBI,
    XR_SLTI,
    XR_SLTI_SIGNED,
    XR_ANDI,
    XR_XORI,
    XR_ORI,
    XR_LUI,
    XR_JALR,
    XR_ADD,
    XR_SUB,
    XR_SLT,
    XR_SLT_SIGNED,
    XR_AND,
    XR_XOR,
    XR_OR,
    XR_MOV_LOAD,
    XR_MOV_LOAD_INLINED,
    XR_MOV_STORE,
    XR_MOV_STORE_INLINED,
    XR_LSH,
    XR_RSH,
    XR_ASH,
    XR_MUL,
    XR_DIV,
    XR_DIV_SIGNED,
    XR_MOD,
    XR_NOR,

    XR_INST_MAX,
END

XrInstructionNames : ^UBYTE[XR_INST_MAX] = {
    [XR_B] = "b",
    [XR_RET] = "ret",
    [XR_JR] = "jr",
    [XR_MOV_REG] = "mov",
    [XR_LI] = "li",
    [XR_LA] = "la",
    [XR_LSHI] = "lshi",
    [XR_RSHI] = "rshi",
    [XR_ASHI] = "ashi",
    [XR_SEQ] = "seq",
    [XR_SEQI] = "seqi",
    [XR_SNE] = "sne",
    [XR_SNEI] = "snei",
    [XR_JAL] = "jal",
    [XR_J] = "j",
    [XR_BEQ] = "beq",
    [XR_BNE] = "bne",
    [XR_BLT] = "blt",
    [XR_BGT] = "bgt",
    [XR_BLE] = "ble",
    [XR_BPE] = "bpe",
    [XR_BPO] = "bpo",
    [XR_ADDI] = "addi",
    [XR_SUBI] = "subi",
    [XR_SLTI] = "slti",
    [XR_SLTI_SIGNED] = "slti signed",
    [XR_ANDI] = "andi",
    [XR_XORI] = "xori",
    [XR_ORI] = "ori",
    [XR_LUI] = "lui",
    [XR_JALR] = "jalr",
    [XR_ADD] = "add",
    [XR_SUB] = "sub",
    [XR_SLT] = "slt",
    [XR_SLT_SIGNED] = "slt signed",
    [XR_AND] = "and",
    [XR_XOR] = "xor",
    [XR_OR] = "or",
    [XR_MOV_LOAD] = "mov",
    [XR_MOV_LOAD_INLINED] = "mov",
    [XR_MOV_STORE] = "mov",
    [XR_MOV_STORE_INLINED] = "mov",
    [XR_LSH] = "lsh",
    [XR_RSH] = "rsh",
    [XR_ASH] = "ash",
    [XR_MUL] = "mul",
    [XR_DIV] = "div",
    [XR_DIV_SIGNED] = "div signed",
    [XR_MOD] = "mod",
    [XR_NOR] = "nor",
}

ENUM XrBits : UBYTE
    XR_BITS_8,
    XR_BITS_16,
    XR_BITS_32,

    XR_BITS_MAX,
END

ENUM XrAccessType : UBYTE
    XR_ACCESS_NONE,
    XR_ACCESS_REGISTER,
    XR_ACCESS_ZERO,
    XR_ACCESS_IMM,
    XR_ACCESS_IMM_NAME,
    XR_ACCESS_IMM_STRING,
    XR_ACCESS_IMM_LABEL,
END

XrPrimTypeToBits : UBYTE[PRIM_TYPE_MAX] = {
    [PRIM_TYPE_BYTE] = XR_BITS_8,
    [PRIM_TYPE_INT] = XR_BITS_16,
    [PRIM_TYPE_LONG] = XR_BITS_32,

    [PRIM_TYPE_UBYTE] = XR_BITS_8,
    [PRIM_TYPE_UINT] = XR_BITS_16,
    [PRIM_TYPE_ULONG] = XR_BITS_32,

    [PRIM_TYPE_POINTER] = XR_BITS_32,
}

XrBitsToMaximumOffset : UWORD[XR_BITS_MAX] = {
    [XR_BITS_8] = 65536,
    [XR_BITS_16] = 131072,
    [XR_BITS_32] = 262144,
}

XrBitsOffsetMask : UBYTE[XR_BITS_MAX] = {
    [XR_BITS_8] = 0,
    [XR_BITS_16] = 1,
    [XR_BITS_32] = 3,
}

ENUM XrShiftTypes : UBYTE
    XR_SHIFT_LSH,
    XR_SHIFT_RSH,
    XR_SHIFT_ASH,

    XR_SHIFT_MAX,
END

XrShiftTypeNames : ^UBYTE[XR_SHIFT_MAX] = {
    [XR_SHIFT_LSH] = "LSH",
    [XR_SHIFT_RSH] = "RSH",
    [XR_SHIFT_ASH] = "ASH",
}

XrInstToShiftType : XrShiftTypes[IR_MAX] = {
    [IR_LEFT_SHIFT] = XR_SHIFT_LSH,
    [IR_RIGHT_SHIFT] = XR_SHIFT_RSH,
    [IR_RIGHT_SHIFT_SIGNED] = XR_SHIFT_ASH,
}

XrIrToImmOp : UBYTE[IR_MAX] = {
    [IR_BIT_AND] = XR_ANDI,
    [IR_BIT_OR] = XR_ORI,
    [IR_ADD] = XR_ADDI,
    [IR_SUBTRACT] = XR_SUBI,
    [IR_DIVIDE] = XR_INST_NULL,
    [IR_DIVIDE_SIGNED] = XR_INST_NULL,
    [IR_MODULO] = XR_INST_NULL,
    [IR_BIT_XOR] = XR_XORI,
    [IR_LEFT_SHIFT] = XR_LSHI,
    [IR_RIGHT_SHIFT] = XR_RSHI,
    [IR_RIGHT_SHIFT_SIGNED] = XR_ASHI,
    [IR_MULTIPLY] = XR_INST_NULL,

    [IR_BRANCH_EQUALS] = XR_SUBI,
    [IR_BRANCH_NOT_EQUALS] = XR_SUBI,
    [IR_BRANCH_LESS_THAN] = XR_SLTI,
    [IR_BRANCH_GREATER_THAN] = XR_SLTI,
    [IR_BRANCH_LTEQ] = XR_SLTI,
    [IR_BRANCH_GTEQ] = XR_SLTI,
    [IR_BRANCH_LESS_THAN_SIGNED] = XR_SLTI_SIGNED,
    [IR_BRANCH_GREATER_THAN_SIGNED] = XR_SLTI_SIGNED,
    [IR_BRANCH_LTEQ_SIGNED] = XR_SLTI_SIGNED,
    [IR_BRANCH_GTEQ_SIGNED] = XR_SLTI_SIGNED,
}

XrIrToRegOp : UBYTE[IR_MAX] = {
    [IR_BIT_AND] = XR_AND,
    [IR_BIT_OR] = XR_OR,
    [IR_ADD] = XR_ADD,
    [IR_SUBTRACT] = XR_SUB,
    [IR_DIVIDE] = XR_DIV,
    [IR_DIVIDE_SIGNED] = XR_DIV_SIGNED,
    [IR_MODULO] = XR_MOD,
    [IR_BIT_XOR] = XR_XOR,
    [IR_LEFT_SHIFT] = XR_LSH,
    [IR_RIGHT_SHIFT] = XR_RSH,
    [IR_RIGHT_SHIFT_SIGNED] = XR_ASH,
    [IR_MULTIPLY] = XR_MUL,

    [IR_BRANCH_EQUALS] = XR_SUB,
    [IR_BRANCH_NOT_EQUALS] = XR_SUB,
    [IR_BRANCH_LESS_THAN] = XR_SLT,
    [IR_BRANCH_GREATER_THAN] = XR_SLT,
    [IR_BRANCH_LTEQ] = XR_SLT,
    [IR_BRANCH_GTEQ] = XR_SLT,
    [IR_BRANCH_LESS_THAN_SIGNED] = XR_SLT_SIGNED,
    [IR_BRANCH_GREATER_THAN_SIGNED] = XR_SLT_SIGNED,
    [IR_BRANCH_LTEQ_SIGNED] = XR_SLT_SIGNED,
    [IR_BRANCH_GTEQ_SIGNED] = XR_SLT_SIGNED,

    [IR_COMPARE_EQUALS] = XR_SUB,
    [IR_COMPARE_NOT_EQUALS] = XR_SUB,
    [IR_COMPARE_LESS_THAN] = XR_SLT,
    [IR_COMPARE_GREATER_THAN] = XR_SLT,
    [IR_COMPARE_LTEQ] = XR_SLT,
    [IR_COMPARE_GTEQ] = XR_SLT,
    [IR_COMPARE_LESS_THAN_SIGNED] = XR_SLT_SIGNED,
    [IR_COMPARE_GREATER_THAN_SIGNED] = XR_SLT_SIGNED,
    [IR_COMPARE_LTEQ_SIGNED] = XR_SLT_SIGNED,
    [IR_COMPARE_GTEQ_SIGNED] = XR_SLT_SIGNED,
}

#DEFINE XR_BRANCH_FLIP 1
#DEFINE XR_BRANCH_NEG 2

XrBranchFlags : UBYTE[IR_MAX] = {
    [IR_BRANCH_EQUALS] = XR_BRANCH_NEG,
    [IR_BRANCH_GREATER_THAN] = XR_BRANCH_FLIP,
    [IR_BRANCH_LTEQ] = XR_BRANCH_FLIP | XR_BRANCH_NEG,
    [IR_BRANCH_GTEQ] = XR_BRANCH_NEG,
    [IR_BRANCH_GREATER_THAN_SIGNED] = XR_BRANCH_FLIP,
    [IR_BRANCH_LTEQ_SIGNED] = XR_BRANCH_FLIP | XR_BRANCH_NEG,
    [IR_BRANCH_GTEQ_SIGNED] = XR_BRANCH_NEG,

    [IR_COMPARE_EQUALS] = XR_BRANCH_NEG,
    [IR_COMPARE_GREATER_THAN] = XR_BRANCH_FLIP,
    [IR_COMPARE_LTEQ] = XR_BRANCH_FLIP | XR_BRANCH_NEG,
    [IR_COMPARE_GTEQ] = XR_BRANCH_NEG,
    [IR_COMPARE_GREATER_THAN_SIGNED] = XR_BRANCH_FLIP,
    [IR_COMPARE_LTEQ_SIGNED] = XR_BRANCH_FLIP | XR_BRANCH_NEG,
    [IR_COMPARE_GTEQ_SIGNED] = XR_BRANCH_NEG,
}

XrTmps : LirRegister[2]
XrSp : LirRegister
XrLr : LirRegister
XrCalleeSaved : LirRegister[XR_S17 - XR_S0 + 1]
XrArg : LirRegister[XR_A3 - XR_A0 + 1]

FN XrCreateInstruction (
    IN type : LirInstructionType,
    IN machtype : UBYTE,
) : ^LirInstruction

    inst := LirCreateInstruction (
        type, // type
        machtype, // machtype
    )

    inst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_NONE
    inst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_NONE
    inst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_NONE

    inst^.Body.Machine.Xr.Op1.Constant = 0
    inst^.Body.Machine.Xr.Op2.Constant = 0
    inst^.Body.Machine.Xr.Op3.Constant = 0

    inst^.Body.Machine.Xr.ShiftAmount = 0
    inst^.Body.Machine.Xr.BitSize = XR_BITS_32

    RETURN inst
END

FN XrFillAccess (
    IN inst : ^IrInstruction,
    IN lirinst : ^LirInstruction,
)

    // Fill Source2 and Source3 of the lirinst instruction with relevant
    // junk for this access. It's always in that spot for both loads and stores.
    // Source1 is the value to store, if relevant.

    bits := XrPrimTypeToBits[inst^.Body.LoadStore.Type]

    lirinst^.Body.Machine.Xr.BitSize = bits

    // Base is always a register.

    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    srcvar := inst^.Source1
    srcinst := srcvar^.DefinedBy

    IF NOT srcinst THEN
        // Just fill it with a zero offset.

        lirinst^.Source2 = LirGetRegister ( inst^.Source1 )
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_ZERO

        LEAVE
    END

    IF srcinst^.Type == IR_STACK_ADDR THEN
        // It's on the stack frame, this is an SP + OFF. 

        symbol := srcinst^.Body.Addr.Symbol

        off := srcinst^.Body.Addr.Offset + IrGetStackOffset (
            LirCurrentFunction, // func
            symbol, // symbol
        ) + LirCurrentFunction^.ScratchAreaSize

        IF off < XrBitsToMaximumOffset[bits] AND
            off & XrBitsOffsetMask[bits] == 0 THEN

            // Great! We can do this directly.

            lirinst^.Body.Machine.Xr.Op3.Constant = off
            lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

            lirinst^.Source2 = LirCreatePreallocatedRegister ( XR_SP )

            LEAVE
        END

    ELSEIF srcinst^.Type == IR_ADDR THEN
        // Gotta be a named imm.
        // If the refcount on the variable is low, we can inline this by a
        // pseudo-instruction. Above two uses of it, it's more worthwhile to
        // allow XrSelectAddr to calculate the address into a reusable temporary
        // register.

        IF srcvar^.Opt.Dve.References < 3 THEN
            lirinst^.Body.Machine.Xr.Op2.Constant =
                CAST srcinst^.Body.Addr.Symbol TO UWORD

            lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM_NAME

            IF lirinst^.MachineInstruction == XR_MOV_STORE THEN
                lirinst^.MachineInstruction = XR_MOV_STORE_INLINED

                // Inlined stores require a temp register to trash.

                lirinst^.Defines = LirCreateRegister ()

            ELSE
                lirinst^.MachineInstruction = XR_MOV_LOAD_INLINED
            END

            LEAVE
        END

    ELSEIF srcinst^.Type == IR_ADD THEN
        // This is an offset by a base. Fill in the base register.

        lirinst^.Source2 = LirSelectOrGetRegister ( srcinst^.Source1 )

        inst2 := srcinst^.Source2^.DefinedBy

        IF inst2 THEN
            IF inst2^.Type == IR_CONSTANT AND
                inst2^.Body.Constant.Constant < XrBitsToMaximumOffset[bits] AND
                inst2^.Body.Constant.Constant & XrBitsOffsetMask[bits] == 0 THEN

                // Great! We can do this constant offset directly.

                lirinst^.Body.Machine.Xr.Op3.Constant =
                    inst2^.Body.Constant.Constant

                lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

                LEAVE

            ELSEIF inst2^.Type == IR_LEFT_SHIFT OR
                inst2^.Type == IR_RIGHT_SHIFT OR
                inst2^.Type == IR_RIGHT_SHIFT_SIGNED THEN

                // If the right side of the shift is a constant less than 32,
                // we can perform it directly in the instruction.

                IF inst2^.Source2^.DefinedBy AND
                    inst2^.Source2^.DefinedBy^.Type == IR_CONSTANT AND
                    inst2^.Source2^.DefinedBy^.Body.Constant.Constant < 32 THEN

                    lirinst^.Source3 =
                        LirSelectOrGetRegister ( inst2^.Source1 )

                    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

                    lirinst^.Body.Machine.Xr.ShiftType =
                        XrInstToShiftType[inst2^.Type]

                    lirinst^.Body.Machine.Xr.ShiftAmount =
                        inst2^.Source2^.DefinedBy^.Body.Constant.Constant

                    LEAVE
                END
            END
        END

        // Just offset by a register.

        lirinst^.Source3 = LirSelectOrGetRegister ( srcinst^.Source2 )
        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

        LEAVE
    END

    // Just fill it with a zero offset from the register.

    lirinst^.Source2 = LirSelect ( srcinst )

    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_ZERO
END

FN (LirSelectF) XrSelectLoad (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a mem-to-reg MOV instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_LOAD, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    XrFillAccess (
        inst, // inst
        lirinst, // lirinst
    )

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectStore (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate a reg-to-mem MOV instruction.

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_STORE, // machtype
    )

    // If the source is an imm between -16 and 15, we can do it in the
    // instruction.

    defby := inst^.Source2^.DefinedBy

    IF defby AND
        defby^.Type == IR_CONSTANT AND
        (defby^.Body.Constant.Constant & 0xFFFFFFFF >= 0xFFFFFFF0 OR
        defby^.Body.Constant.Constant < 16) THEN

        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_IMM

        lirinst^.Body.Machine.Xr.Op1.Constant =
            defby^.Body.Constant.Constant & 0xFFFFFFFF

    ELSE
        lirinst^.Source1 = LirSelectOrGetRegister ( inst^.Source2 )
        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
    END

    XrFillAccess (
        inst, // inst
        lirinst, // lirinst
    )

    LirInsertInstructionTail ( lirinst )

    RETURN NULLPTR
END

FN XrFillConstant (
    IN lirinst : ^LirInstruction,
    IN const : UWORD,
)

    // Make the given LIR instruction load the given constant.

    const &= 0xFFFFFFFF

    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM

    IF const < 65536 THEN
        lirinst^.MachineInstruction = XR_LI
        lirinst^.Body.Machine.Xr.Op2.Constant = const

    ELSEIF const >= 0xFFFF0001 THEN
        lirinst^.MachineInstruction = XR_SUBI
        lirinst^.Body.Machine.Xr.Op2.Constant = (~const + 1) & 0xFFFFFFFF

    ELSEIF const & 0xFFFF == 0 THEN
        lirinst^.MachineInstruction = XR_LUI
        lirinst^.Body.Machine.Xr.Op2.Constant = const

    ELSE
        lirinst^.MachineInstruction = XR_LA
        lirinst^.Body.Machine.Xr.Op2.Constant = const
    END
END

FN XrGenerateConstant (
    IN tmp : ^LirRegister,
    IN const : UWORD,
    IN afterinst : ^LirInstruction,
    IN beforeinst : ^LirInstruction,
) : ^LirRegister

    // Create an instruction to load the given constant.

    IF NOT tmp THEN
        tmp = LirCreateRegister ()
    END

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_INST_NULL, // machtype
    )

    lirinst^.Defines = tmp
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    XrFillConstant (
        lirinst, // lirinst
        const, // const
    )

    IF afterinst THEN
        LirInsertInstructionAfter (
            afterinst, // afterinst
            lirinst, // inst
        )

    ELSEIF beforeinst THEN
        LirInsertInstructionBefore (
            beforeinst, // beforeinst
            lirinst, // inst
        )

    ELSE
        LirInsertInstructionTail ( lirinst )
    END

    RETURN tmp
END

FN (LirSelectF) XrSelectAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate an imm-to-reg MOV instruction.

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_INST_NULL, // machtype
    )

    lirinst^.Defines = defreg

    IF inst^.Type == IR_ADDR THEN
        lirinst^.MachineInstruction = XR_LA

        lirinst^.Body.Machine.Xr.Op2.Constant =
            CAST inst^.Body.Addr.Symbol TO UWORD
    
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM_NAME

    ELSEIF inst^.Type == IR_STRING_ADDR THEN
        // This will get resolved to a label pointing to a string during
        // code emission.

        lirinst^.MachineInstruction = XR_LA

        lirinst^.Body.Machine.Xr.Op2.Constant =
            CAST inst^.Body.String.String TO UWORD

        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_IMM_STRING
    
    ELSEIF inst^.Type == IR_CONSTANT THEN
        XrFillConstant (
            lirinst, // lirinst
            inst^.Body.Constant.Constant, // const
        )
    END

    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectStackAddr (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Generate an ADDI DEST, SP, OFF instruction.

    symbol := inst^.Body.Addr.Symbol

    off := IrGetStackOffset (
        LirCurrentFunction, // func
        symbol, // symbol
    ) + inst^.Body.Addr.Offset + LirCurrentFunction^.ScratchAreaSize

    defreg := LirGetRegister ( inst^.Defines )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_INST_NULL, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source2 = LirCreatePreallocatedRegister ( XR_SP )
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    IF off < 65536 THEN
        lirinst^.MachineInstruction = XR_ADDI

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        lirinst^.Body.Machine.Xr.Op3.Constant = off

    ELSE
        lirinst^.MachineInstruction = XR_ADD

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source3 = XrGenerateConstant (
            NULLPTR, // tmp
            off, // const
            NULLPTR, // afterinst
            NULLPTR, // beforeinst
        )
    END

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectMove (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Select the most appropriate instruction.

    def := inst^.Defines
    src := inst^.Source1
    srcreg : ^LirRegister

    IF src^.DefinedBy THEN
        // The source is a temporary.

        IF src^.Opt.Dve.References == 1 THEN
            // This is the only reference to the temporary, so don't bother
            // sharing; twiddle its defining instruction to define us and then
            // generate that instead.

            src^.DefinedBy^.Defines = def

            RETURN LirSelect ( src^.DefinedBy )
        END

        srcreg = LirSelect ( src^.DefinedBy )

    ELSE
        srcreg = LirGetRegister ( src )
    END

    // Generate an XR/17032 reg-to-reg MOV instruction.

    defreg := LirGetRegister ( def )

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_REG, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Source2 = srcreg

    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN XrGeneratePreallocatedMov (
    IN srcreg : ^LirRegister,
    IN machreg : UBYTE,
    IN from : UBYTE,
) : ^LirRegister

    // Hint.

    srcreg^.Hint = machreg

    // Generate MOV to preallocated reg.

    movinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_REG, // machtype
    )

    retval := LirCreatePreallocatedRegister ( machreg )

    IF from THEN
        movinst^.Source2 = retval
        movinst^.Defines = srcreg

    ELSE
        movinst^.Defines = retval
        movinst^.Source2 = srcreg
    END

    movinst^.Body.Machine.Fox.Op1.AccessType = XR_ACCESS_REGISTER
    movinst^.Body.Machine.Fox.Op2.AccessType = XR_ACCESS_REGISTER

    LirInsertInstructionTail ( movinst )

    IF from THEN
        RETURN srcreg

    ELSE
        RETURN retval
    END
END

FN (LirSelectF) XrSelectReturn (
    IN inst : ^IrInstruction,
) : ^LirRegister

    retval : ^LirRegister = NULLPTR

    IF inst^.Source1 THEN
        srcreg := LirSelectOrGetRegister ( inst^.Source1 )

        retval = XrGeneratePreallocatedMov (
            srcreg, // srcreg
            XR_A3, // machreg
            FALSE, // from
        )
    END

    // Add an unconditional branch to the epilogue.

    lirinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_B, // machtype
    )

    lirinst^.TypeBody.Branch.Label =
        LirGetLabel ( LirCurrentFunction^.EpilogueLabel )

    LirInsertInstructionTail ( lirinst )

    RETURN NULLPTR
END

FN XrGenerateFalseBranch (
    IN inst : ^IrInstruction,
)

    IF inst^.Body.Branch.FalseLabel == inst^.Next THEN
        // The false label is the fall-through, don't generate the false branch.

        LEAVE
    END

    // Generate the false branch.

    jmpinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_B, // machtype
    )

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Branch.FalseLabel )

    LirInsertInstructionTail ( jmpinst )
END

FN (LirSelectF) XrSelectZeroBranch (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF IrIsUselessBranch ( inst ) THEN
        RETURN NULLPTR
    END

    jmpinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_INST_NULL, // machtype
    )

    IF inst^.Type == IR_BRANCH_NONZERO THEN
        jmpinst^.MachineInstruction = XR_BNE

    ELSE
        jmpinst^.MachineInstruction = XR_BEQ
    END

    jmpinst^.Source1 = LirSelectOrGetRegister ( inst^.Source1 )
    jmpinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Branch.TrueLabel )

    LirInsertInstructionTail ( jmpinst )

    // Generate an unconditional branch to the false label if required.

    XrGenerateFalseBranch ( inst )

    RETURN NULLPTR
END

FN XrGenerateArithmetic (
    IN defreg : ^LirRegister,
    IN src1 : ^IrVariable,
    IN src2 : ^IrVariable,
    IN immop : XrInstructionTypes,
    IN regop : XrInstructionTypes,
)

    // Creates a LIR instruction that performs the given arithmetic operation.
    // Tries to fit a right-side constant in, if immop is non-null.

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_INST_NULL, // machtype
    )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source2 = LirSelectOrGetRegister ( src1 )
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    IF immop AND
        src2^.DefinedBy AND
        src2^.DefinedBy^.Type == IR_CONSTANT AND
        src2^.DefinedBy^.Body.Constant.Constant < 65536 THEN

        lirinst^.MachineInstruction = immop

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM

        lirinst^.Body.Machine.Xr.Op3.Constant =
            src2^.DefinedBy^.Body.Constant.Constant

    ELSE
        lirinst^.MachineInstruction = regop

        lirinst^.Source3 = LirSelectOrGetRegister ( src2 )

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER
    END

    LirInsertInstructionTail ( lirinst )
END

FN (LirSelectF) XrSelectArithmetic (
    IN inst : ^IrInstruction,
) : ^LirRegister

    defreg := LirGetRegister ( inst^.Defines )

    XrGenerateArithmetic (
        defreg, // defreg
        inst^.Source1, // src1
        inst^.Source2, // src2
        XrIrToImmOp[inst^.Type], // immop
        XrIrToRegOp[inst^.Type], // regop
    )

    RETURN defreg
END

FN (LirSelectF) XrSelectNot (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Output:
    //
    //  SLTI RD, RA, 1

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_SLTI, // machtype
    )

    defreg := LirGetRegister ( inst^.Defines )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source2 = LirSelectOrGetRegister ( inst^.Source1 )
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
    lirinst^.Body.Machine.Xr.Op3.Constant = 1

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectBitNot (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // Output:
    //
    //  NOR RD, RA, RA

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_NOR, // machtype
    )

    defreg := LirGetRegister ( inst^.Defines )

    lirinst^.Defines = defreg
    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source2 = LirSelectOrGetRegister ( inst^.Source1 )
    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    lirinst^.Source3 = lirinst^.Source2
    lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER

    LirInsertInstructionTail ( lirinst )

    RETURN defreg
END

FN (LirSelectF) XrSelectBranch (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF IrIsUselessBranch ( inst ) THEN
        RETURN NULLPTR
    END

    tmp := LirCreateRegister ()

    flags := XrBranchFlags[inst^.Type]

    src1 := inst^.Source1
    src2 := inst^.Source2

    IF flags & XR_BRANCH_FLIP THEN
        tmpsrc := src1

        src1 = src2
        src2 = tmpsrc
    END

    XrGenerateArithmetic (
        tmp, // defreg
        src1, // src1
        src2, // src2
        XrIrToImmOp[inst^.Type], // immop
        XrIrToRegOp[inst^.Type], // regop
    )

    jmpinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_INST_NULL, // machtype
    )

    IF flags & XR_BRANCH_NEG THEN
        jmpinst^.MachineInstruction = XR_BEQ

    ELSE
        jmpinst^.MachineInstruction = XR_BNE
    END

    jmpinst^.Source1 = tmp
    jmpinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Branch.TrueLabel )

    LirInsertInstructionTail ( jmpinst )

    // Generate an unconditional branch to the false label if required.

    XrGenerateFalseBranch ( inst )

    RETURN NULLPTR
END

FN (LirSelectF) XrSelectCompare (
    IN inst : ^IrInstruction,
) : ^LirRegister

    defreg := LirGetRegister ( inst^.Defines )

    flags := XrBranchFlags[inst^.Type]

    src1 := inst^.Source1
    src2 := inst^.Source2

    IF flags & XR_BRANCH_FLIP THEN
        tmpsrc := src1

        src1 = src2
        src2 = tmpsrc
    END

    XrGenerateArithmetic (
        defreg, // defreg
        src1, // src1
        src2, // src2
        XrIrToImmOp[inst^.Type], // immop
        XrIrToRegOp[inst^.Type], // regop
    )

    IF flags & XR_BRANCH_NEG THEN
        lirinst := XrCreateInstruction (
            LIR_MACH_INST, // type
            XR_SLTI, // machtype
        )

        lirinst^.Defines = defreg
        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source2 = defreg
        lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        lirinst^.Body.Machine.Xr.Op3.Constant = 1

        LirInsertInstructionTail ( lirinst )
    END

    RETURN defreg
END

FN (LirSelectF) XrSelectJump (
    IN inst : ^IrInstruction,
) : ^LirRegister

    IF inst^.Body.Jump.Label == inst^.Next THEN
        // Don't generate the jump; allow fall-through.

        RETURN NULLPTR
    END

    jmpinst := XrCreateInstruction (
        LIR_BRANCH, // type
        XR_B, // machtype
    )

    jmpinst^.TypeBody.Branch.Label = LirGetLabel ( inst^.Body.Jump.Label )

    LirInsertInstructionTail ( jmpinst )

    RETURN NULLPTR
END

FN XrFillForStackAccess (
    IN tmp : ^LirRegister,
    IN beforeinst : ^LirInstruction,
    IN afterinst : ^LirInstruction,
    IN lirinst : ^LirInstruction,
    IN off : ULONG,
)

    IF beforeinst OR afterinst THEN
        lirinst^.Source2 = &XrSp

    ELSE
        lirinst^.Source2 = LirCreatePreallocatedRegister ( XR_SP )
    END

    lirinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER

    IF off < 262144 AND off & 3 == 0 THEN
        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        lirinst^.Body.Machine.Xr.Op3.Constant = off
    
    ELSE
        // The offset is GINORMOUS (or unaligned for some reason).
        // Load it into a constant.

        lirinst^.Source3 = XrGenerateConstant (
            tmp, // tmp
            off, // const
            afterinst, // afterinst
            beforeinst, // beforeinst
        )

        lirinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_REGISTER
    END
END

FN XrGenerateStoreToStack (
    IN srcreg : ^LirRegister,
    IN srcvar : ^IrVariable,
    IN off : ULONG,
)

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_STORE, // machtype
    )

    IF NOT srcreg THEN
        defby := srcvar^.DefinedBy

        IF defby AND
            defby^.Type == IR_CONSTANT AND
            (defby^.Body.Constant.Constant & 0xFFFFFFFF >= 0xFFFFFFF0 OR
            defby^.Body.Constant.Constant < 16) THEN

            lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_IMM

            lirinst^.Body.Machine.Xr.Op1.Constant =
                defby^.Body.Constant.Constant & 0xFFFFFFFF

        ELSE
            srcreg = LirSelectOrGetRegister ( srcvar )
        END
    END

    IF srcreg THEN
        lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER

        lirinst^.Source1 = srcreg
    END

    XrFillForStackAccess (
        NULLPTR, // tmp
        NULLPTR, // beforeinst
        NULLPTR, // afterinst
        lirinst, // lirinst
        off, // off
    )

    LirInsertInstructionTail ( lirinst )
END

FN XrGenerateLoadFromStack (
    IN defreg : ^LirRegister,
    IN off : ULONG,
)

    lirinst := XrCreateInstruction (
        LIR_MACH_INST, // type
        XR_MOV_LOAD, // machtype
    )

    XrFillForStackAccess (
        NULLPTR, // tmp
        NULLPTR, // beforeinst
        NULLPTR, // afterinst
        lirinst, // lirinst
        off, // off
    )

    lirinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
    lirinst^.Defines = defreg

    LirInsertInstructionTail ( lirinst )
END

FN (LirSelectF) XrSelectCall (
    IN inst : ^IrInstruction,
) : ^LirRegister

    // We generate the call instruction and all of its arguments.

    callinst := XrCreateInstruction (
        LIR_CALL, // type
        XR_INST_NULL, // machtype
    )

    defreg : ^LirRegister = NULLPTR

    IF inst^.Defines THEN
        defreg = LirGetRegister ( inst^.Defines )

        // Hint the return value to machine reg a3 since that is what it is
        // passed back in.

        defreg^.Hint = XR_A3
    END

    // Now fill the call.

    IF inst^.Source1^.DefinedBy AND
        inst^.Source1^.DefinedBy^.Type == IR_ADDR THEN

        callinst^.MachineInstruction = XR_JAL

        callinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_IMM_NAME

        callinst^.Body.Machine.Xr.Op1.Constant =
            CAST inst^.Source1^.DefinedBy^.Body.Addr.Symbol TO UWORD

    ELSE
        callinst^.MachineInstruction = XR_JALR

        callinst^.Body.Machine.Xr.Op1.AccessType = XR_ACCESS_REGISTER
        callinst^.Source1 = LirCreatePreallocatedRegister ( XR_LR )

        callinst^.Body.Machine.Xr.Op2.AccessType = XR_ACCESS_REGISTER
        callinst^.Source2 = LirSelectOrGetRegister ( inst^.Source1 )

        callinst^.Body.Machine.Xr.Op3.AccessType = XR_ACCESS_IMM
        callinst^.Body.Machine.Xr.Op3.Constant = 0
    END

    // First generate all of the arguments.

    arglisttail : ^LirArgument = NULLPTR
    callinst^.TypeBody.Call.ArgListHead = NULLPTR

    arg := inst^.Body.Call.ArgListHead
    count := 0
    stackoff := 0

    WHILE arg DO
        lirarg : ^LirArgument

        status := TlBumpAlloc (
            SIZEOF LirArgument, // bytes
            OUT lirarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate LIR argument", 0, 0, 0 )
        END

        IF count < 4 THEN
            lirarg^.Register = LirSelectOrGetRegister ( arg^.Variable )

        ELSE
            XrGenerateStoreToStack (
                NULLPTR, // srcreg
                arg^.Variable, // srcvar
                stackoff, // off
            )

            stackoff += 4
        END

        lirarg^.Next = NULLPTR

        IF arglisttail THEN
            arglisttail^.Next = lirarg

        ELSE
            callinst^.TypeBody.Call.ArgListHead = lirarg
        END

        arglisttail = lirarg

        count += 1

        arg = arg^.Next
    END

    // Finally, generate MOVs to A0-A3.

    lirarg := callinst^.TypeBody.Call.ArgListHead
    count = 0

    WHILE lirarg DO
        IF count >= 4 THEN
            BREAK
        END

        XrGeneratePreallocatedMov (
            lirarg^.Register, // reg
            XR_A0 + count, // machreg
            FALSE, // from
        )

        count += 1
        lirarg = lirarg^.Next
    END

    // Now insert the CALL instruction.

    LirInsertInstructionTail ( callinst )

    // Now generate a mov from A3 to the destination.

    IF defreg THEN
        XrGeneratePreallocatedMov (
            defreg, // reg
            XR_A3, // machreg
            TRUE, // from
        )
    END

    outlisttail : ^LirArgument = NULLPTR
    callinst^.TypeBody.Call.OutListHead = NULLPTR

    arg = inst^.Body.Call.OutListHead
    count = 0

    stackoff = 0

    WHILE arg DO
        status := TlBumpAlloc (
            SIZEOF LirArgument, // bytes
            OUT lirarg, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate LIR argument", 0, 0, 0 )
        END

        IF arg^.Variable^.Opt.Dve.References != 0 THEN
            lirarg^.Register = LirGetRegister ( arg^.Variable )

            IF count < 3 THEN
                // First three OUT values are hinted to a0-a2 since they're
                // passed to the caller in those registers. a3 is the primary
                // return value. We allocate them "backwards" in the hope that
                // leaving the lower ones free will help keep the IN arguments
                // in the other regs.

                XrGeneratePreallocatedMov (
                    lirarg^.Register, // reg
                    XR_A2 - count, // machreg
                    TRUE, // from
                )
            
            ELSE
                XrGenerateLoadFromStack (
                    lirarg^.Register, // defreg
                    stackoff, // off
                )
            END
        END

        IF count >= 3 THEN
            stackoff += 4
        END

        lirarg^.Next = NULLPTR

        IF outlisttail THEN
            outlisttail^.Next = lirarg

        ELSE
            callinst^.TypeBody.Call.OutListHead = lirarg
        END

        outlisttail = lirarg

        count += 1

        arg = arg^.Next
    END

    RETURN defreg
END

XrLirInfo : LirTargetInfoRecord = {
    [SelectionTable] = {
        [IR_LOAD] = &XrSelectLoad,
        [IR_ADDR] = &XrSelectAddr,
        [IR_STRING_ADDR] = &XrSelectAddr,
        [IR_CONSTANT] = &XrSelectAddr,
        [IR_STACK_ADDR] = &XrSelectStackAddr,

        [IR_MOVE] = &XrSelectMove,

        [IR_RETURN] = &XrSelectReturn,

        [IR_BRANCH_NONZERO] = &XrSelectZeroBranch,
        [IR_BRANCH_ZERO] = &XrSelectZeroBranch,

        [IR_BIT_AND] = &XrSelectArithmetic,
        [IR_BIT_OR] = &XrSelectArithmetic,
        [IR_ADD] = &XrSelectArithmetic,
        [IR_SUBTRACT] = &XrSelectArithmetic,
        [IR_DIVIDE] = &XrSelectArithmetic,
        [IR_DIVIDE_SIGNED] = &XrSelectArithmetic,
        [IR_MODULO] = &XrSelectArithmetic,
        [IR_BIT_XOR] = &XrSelectArithmetic,
        [IR_LEFT_SHIFT] = &XrSelectArithmetic,
        [IR_RIGHT_SHIFT] = &XrSelectArithmetic,
        [IR_RIGHT_SHIFT_SIGNED] = &XrSelectArithmetic,
        [IR_MULTIPLY] = &XrSelectArithmetic,

        [IR_NOT] = &XrSelectNot,
        [IR_BIT_NOT] = &XrSelectBitNot,

        [IR_BRANCH_EQUALS] = &XrSelectBranch,
        [IR_BRANCH_NOT_EQUALS] = &XrSelectBranch,
        [IR_BRANCH_LESS_THAN] = &XrSelectBranch,
        [IR_BRANCH_GREATER_THAN] = &XrSelectBranch,
        [IR_BRANCH_LTEQ] = &XrSelectBranch,
        [IR_BRANCH_GTEQ] = &XrSelectBranch,
        [IR_BRANCH_LESS_THAN_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_GREATER_THAN_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_LTEQ_SIGNED] = &XrSelectBranch,
        [IR_BRANCH_GTEQ_SIGNED] = &XrSelectBranch,

        [IR_JUMP] = &XrSelectJump,

        [IR_CALL] = &XrSelectCall,

        [IR_STORE] = &XrSelectStore,

        [IR_COMPARE_EQUALS] = &XrSelectCompare,
        [IR_COMPARE_NOT_EQUALS] = &XrSelectCompare,
        [IR_COMPARE_LESS_THAN] = &XrSelectCompare,
        [IR_COMPARE_GREATER_THAN] = &XrSelectCompare,
        [IR_COMPARE_LTEQ] = &XrSelectCompare,
        [IR_COMPARE_GTEQ] = &XrSelectCompare,
        [IR_COMPARE_LESS_THAN_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_GREATER_THAN_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_LTEQ_SIGNED] = &XrSelectCompare,
        [IR_COMPARE_GTEQ_SIGNED] = &XrSelectCompare,
    },
    [RegisterAbiUsage] = {
        [XR_T0] = LIR_REG_CALLER_SAVED,
        [XR_T1] = LIR_REG_CALLER_SAVED,
        [XR_T2] = LIR_REG_CALLER_SAVED,
        [XR_T3] = LIR_REG_CALLER_SAVED,
        [XR_A0] = LIR_REG_CALLER_SAVED,
        [XR_A1] = LIR_REG_CALLER_SAVED,
        [XR_A2] = LIR_REG_CALLER_SAVED,
        [XR_A3] = LIR_REG_CALLER_SAVED,
        [XR_S0] = LIR_REG_CALLEE_SAVED,
        [XR_S1] = LIR_REG_CALLEE_SAVED,
        [XR_S2] = LIR_REG_CALLEE_SAVED,
        [XR_S3] = LIR_REG_CALLEE_SAVED,
        [XR_S4] = LIR_REG_CALLEE_SAVED,
        [XR_S5] = LIR_REG_CALLEE_SAVED,
        [XR_S6] = LIR_REG_CALLEE_SAVED,
        [XR_S7] = LIR_REG_CALLEE_SAVED,
        [XR_S8] = LIR_REG_CALLEE_SAVED,
        [XR_S9] = LIR_REG_CALLEE_SAVED,
        [XR_S10] = LIR_REG_CALLEE_SAVED,
        [XR_S11] = LIR_REG_CALLEE_SAVED,
        [XR_S12] = LIR_REG_CALLEE_SAVED,
        [XR_S13] = LIR_REG_CALLEE_SAVED,
        [XR_S14] = LIR_REG_CALLEE_SAVED,
        [XR_S15] = LIR_REG_CALLEE_SAVED,
        [XR_S16] = LIR_REG_CALLEE_SAVED,
        [XR_S17] = LIR_REG_CALLEE_SAVED,
    },
    [MaximumRegister] = XR_REG_MAX,
}

FN XrHintFunction (
    IN funcsym : ^LexSymbol,
)

    // Hint the first four arguments to a0-a3.

    functype := funcsym^.SemanticType

    arg := functype^.Body.Function.ArgListHead

    incount := 0
    outcount := 0

    WHILE arg DO
        symbol := arg^.Symbol

        irvar := CAST symbol^.IrContext TO ^IrVariable

        IF irvar THEN
            irreg := LirGetRegister ( irvar )

            IF arg^.InOut == ARG_IN AND incount < 4 THEN
                irreg^.Hint = XR_A0 + incount

            ELSEIF arg^.InOut == ARG_OUT AND outcount < 3 THEN
                irreg^.Hint = XR_A2 - outcount
            END
        END

        IF arg^.InOut == ARG_IN THEN
            incount += 1

        ELSE
            outcount += 1
        END

        arg = arg^.Next
    END

    IF functype^.Body.Function.IsVarArg THEN
        // Hint the vartable and argcount symbols.

        i := 0

        WHILE incount < 4 DO
            symbol : ^LexSymbol

            IF NOT i THEN
                symbol = functype^.Body.Function.VarArgTable

            ELSE
                symbol = functype^.Body.Function.VarArgCount
            END

            irvar := CAST symbol^.IrContext TO ^IrVariable

            IF irvar THEN
                irreg := LirGetRegister ( irvar )

                irreg^.Hint = XR_A0 + incount
            END

            incount += 1
            i += 1
        END
    END
END

FN XrGenerateSpills (
    IN irfunc : ^IrFunction,
)

    TlInternalError ( "TODO XrGenerateSpills", 0, 0, 0 )
END

FN XrGenerateAbiStuff (
    IN funcsym : ^LexSymbol,
    IN irfunc : ^IrFunction,
)

    TlInternalError ( "TODO XrGenerateAbiStuff", 0, 0, 0 )
END

XrNextBranchNumber := 0

FN XrEmitInstruction (
    IN lirinst : ^LirInstruction,
)

    IF lirinst^.Type == LIR_MACH_INST OR
        lirinst^.Type == LIR_CALL OR
        lirinst^.Type == LIR_BRANCH OR
        lirinst^.Type == LIR_RETURN THEN

        TlInternalError ( "TODO XrEmitInstruction", 0, 0, 0 )

    ELSEIF lirinst^.Type == LIR_LABEL THEN
        num := lirinst^.Body.Label.Number

        IF num == 0xFFFFFFFF THEN
            num = XrNextBranchNumber
            lirinst^.Body.Label.Number = num

            XrNextBranchNumber += 1
        END

        XrAsmInsertString ( ".L" )
        XrAsmInsertNumber ( num )
        XrAsmInsertString ( ":\n" )

    ELSE
        TlInternalError ( "Xr: Weird LIR type", lirinst^.Type, 0, 0 )
    END
END

FN XrElideUselessJump (
    IN inst : ^LirInstruction,
) : UWORD

    // Check if this branch instruction is followed by both its true and false
    // label. We walk along each label until we reach the first non-label
    // instruction so that we catch all the cases.

    next := inst^.Next

    WHILE next AND next^.Type == LIR_LABEL DO
        IF inst^.TypeBody.Branch.Label == next THEN
            next^.Body.Label.References -= 1

            RETURN TRUE
        END

        next = next^.Next
    END

    RETURN FALSE
END

FN (AsmEmitF) XrEmitFunction (
    IN funcsym : ^LexSymbol,
)

    // Emit the final assembly language for a function.

    irfunc := CAST funcsym^.InitialValue TO ^IrFunction

    inst := irfunc^.LirHead

    WHILE inst DO
        IF inst^.Type == LIR_LABEL AND NOT inst^.Body.Label.References THEN
            inst = inst^.Next

            CONTINUE
        END

        IF inst^.Type == LIR_BRANCH AND XrElideUselessJump ( inst ) THEN
            inst = inst^.Next

            CONTINUE
        END

        XrEmitInstruction ( inst )

        inst = inst^.Next
    END
END

XrAsmEmitter : AsmEmitterRecord = {
    [EmitFunc] = &XrEmitFunction,
}

FN (JklValueNumberF) XrValueNumber (
    IN constant : UWORD,
) : UBYTE

    // Return whether to value number this constant.
    // Doing this too much could create too many callee-saved registers if the
    // constant is live over a function call. Doing it too little will
    // recompute large constants too much.

    // We rarely have to generate constants on XR/17032, and when we do, we'd
    // better reuse them. Always TRUE.

    RETURN TRUE
END

FN (JklTargetF) XrCompile ()
    
    // Compile the program for the XR/17032 architecture.

    XrTmps[0].Type = LIR_PREALLOCATED_REG
    XrTmps[0].MachineRegister = XR_T4

    XrTmps[1].Type = LIR_PREALLOCATED_REG
    XrTmps[1].MachineRegister = XR_T5

    XrSp.Type = LIR_PREALLOCATED_REG
    XrSp.MachineRegister = XR_SP

    XrLr.Type = LIR_PREALLOCATED_REG
    XrLr.MachineRegister = XR_LR

    i := 0

    WHILE i < (XR_S17 - XR_S0 + 1) DO
        XrCalleeSaved[i].Type = LIR_PREALLOCATED_REG
        XrCalleeSaved[i].MachineRegister = XR_S0 + i

        i += 1
    END

    i = 0

    WHILE i < (XR_A3 - XR_A0 + 1) DO
        XrArg[i].Type = LIR_PREALLOCATED_REG
        XrArg[i].MachineRegister = XR_A0 + i

        i += 1
    END

    // Perform instruction selection on each function.

    funcsym := PrsFunctionListHead

    WHILE funcsym DO
        // Calculate the scratch area size.

        irfunc := CAST funcsym^.InitialValue TO ^IrFunction

        inscratch := 0

        IF irfunc^.MaximumInCount > 4 THEN
            inscratch = (irfunc^.MaximumInCount - 4) * 4
        END

        outscratch := 0

        IF irfunc^.MaximumOutCount > 3 THEN
            outscratch = (irfunc^.MaximumOutCount - 3) * 4
        END

        IF inscratch > outscratch THEN
            irfunc^.ScratchAreaSize = inscratch
        
        ELSE
            irfunc^.ScratchAreaSize = outscratch
        END

        LirSelectForFunction ( funcsym )

        funcsym = funcsym^.NextFunction
    END

    // Do regalloc over the low level IR (LIR).

    funcsym = PrsFunctionListHead

    WHILE funcsym DO
        // Apply hints to the formal parameters.

        XrHintFunction ( funcsym )

        // Do regalloc.

        LirAllocateRegistersForFunction ( funcsym )

        // Generate spill code.

        irfunc := CAST funcsym^.InitialValue TO ^IrFunction

        XrGenerateSpills ( irfunc )

        // Generate the prologue and epilogue.

        XrGenerateAbiStuff ( funcsym, irfunc )

        funcsym = funcsym^.NextFunction
    END

    // Emit the final assembly language.

    XrAsmEmit (
        &XrAsmEmitter, // emitter
    )
END