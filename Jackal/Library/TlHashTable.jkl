//
// Simple hash table implementation for faster symbol lookup.
//

#INCLUDE "<inc>/Runtime.jh"

FN TlHashTableInitialize (
	IN hashtable : ^TlHashTable,
) : TlStatus

	TlFillMemoryWithByte (
		&hashtable^.BucketHeads, // ptr
		SIZEOFVALUE hashtable^.BucketHeads, // sz
		0, // byte
	)

	RETURN JKL_SUCCESS
END

FN TlHashTableInsert (
	IN hashtable : ^TlHashTable,
	IN entry : ^TlHashTableEntry,
	IN key : ^UBYTE,
)

	// Caller needs to guarantee that the memory in which the key resides sticks
	// around until such time as the entry is removed from the hash table.

	hash := TlHashString ( key )

	head := hashtable^.BucketHeads[hash]

	entry^.HashTable = hashtable
	entry^.Key = key
	entry^.Hash = hash

	// Insert entry into doubly linked hash bucket list, at the head.

	entry^.Prev = 0
	entry^.Next = head

	IF head THEN
		head^.Prev = entry
	END

	hashtable^.BucketHeads[hash] = entry
END

FN TlHashTableLookup (
	IN hashtable : ^TlHashTable,
	IN key : ^UBYTE,
) : ^TlHashTableEntry

	hash := TlHashString ( key )

	entry := hashtable^.BucketHeads[hash]

	WHILE entry DO
		IF TlStringCompare ( key, entry^.Key ) == 0 THEN
			RETURN entry
		END

		entry = entry^.Next
	END

	RETURN 0
END

FN TlHashTableRemove (
	IN entry : ^TlHashTableEntry,
)

	hashtable := entry^.HashTable
	hash := entry^.Hash

	// Remove entry from doubly linked hash bucket list.

	p := entry^.Prev

	IF p THEN
		p^.Next = entry^.Next
	ELSE // no prev means we were the head
		hashtable^.BucketHeads[hash] = entry^.Next
	END

	p = entry^.Next

	IF p THEN
		p^.Prev = entry^.Prev
	END
END

FN TlHashTableEnumerate (
	IN hashtable : ^TlHashTable,
	IN enumfunc : TlHashTableEnumF,
)

	i := 0

	WHILE i < JKL_HASH_SIZE DO
		entry := hashtable^.BucketHeads[i]

		WHILE entry DO
			// Capture the next entry now since the enumeration function might
			// destroy this entry.

			nextentry := entry^.Next

			enumfunc ( entry )

			entry = nextentry
		END

		i += 1
	END
END

FN TlHashString (
	IN str : ^UBYTE,
) : ULONG

	hash : ULONG = 0

	WHILE str^ DO
		hash += str^
		hash += hash << 10
		hash $= hash >> 6

		str += 1
	END

	hash += hash << 3
	hash $= hash >> 11
	hash += hash << 15

	hash $= hash >> 24 & 0xFF
	hash $= hash >> 16 & 0xFF
	hash $= hash >> 8 & 0xFF

	hash %= JKL_HASH_SIZE

	RETURN hash
END