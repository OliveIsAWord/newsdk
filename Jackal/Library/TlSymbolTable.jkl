//
// Generic scoped symbol table implementation.
// Does not care what the "symbol" structure contains, as long as it has a
// TlHashTableEntry as a header. This is used for both the parser and also for
// macro expansion, where a concept of "scope" is useful for macro function
// arguments and nested expansion.
//

#INCLUDE "<inc>/Runtime.jh"

FN TlSymbolTableInitialize (
	IN symboltable : ^TlSymbolTable,
	IN deletefunc : TlHashTableEnumF,
) : TlStatus

	symboltable^.PrevScope = 0
	symboltable^.DeleteRoutine = deletefunc

	RETURN TlHashTableInitialize ( &symboltable^.HashTable )
END

FN TlSymbolTableCreate (
	IN outerscope : ^TlSymbolTable,
	IN deletefunc : TlHashTableEnumF,
	OUT symboltable : ^^TlSymbolTable,
) : TlStatus

	status := TlAlloc (
		SIZEOF TlSymbolTable, // bytes
		symboltable, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = TlSymbolTableInitialize (
		symboltable^, // symboltable
		deletefunc, // deletefunc
	)

	IF status THEN
		TlFree ( symboltable^ )
	END

	RETURN status
END

FN TlSymbolTableDelete (
	IN symboltable : ^TlSymbolTable,
) : ^TlSymbolTable

	outerscope := symboltable^.PrevScope

	TlHashTableEnumerate (
		&symboltable^.HashTable, // hashtable
		symboltable^.DeleteRoutine, // deletefunc
	)

	TlFree ( symboltable )

	RETURN outerscope
END

FN TlSymbolTableLookup (
	IN symboltable : ^TlSymbolTable,
	IN name : ^UBYTE,
) : ^TlHashTableEntry

	WHILE symboltable DO
		entry := TlHashTableLookup (
			&symboltable^.HashTable, // hashtable
			name, // key
		)

		IF entry THEN
			RETURN entry
		END

		symboltable = symboltable^.PrevScope
	END

	RETURN 0
END

FN TlSymbolTableInsert (
	IN symboltable : ^TlSymbolTable,
	IN entry : ^TlHashTableEntry,
	IN name : ^UBYTE,
)

	TlHashTableInsert (
		&symboltable^.HashTable, // hashtable
		entry, // entry
		name, // key
	)
END

FN TlSymbolTableRemove (
	IN entry : ^TlHashTableEntry,
)

	TlHashTableRemove ( entry )
END