//
// Generic scoped symbol table implementation.
// Does not care what the "symbol" structure contains, as long as it has a
// TlHashTableEntry as a header. This is used for both the parser and also for
// macro expansion, where a concept of "scope" is useful for macro function
// arguments and nested expansion.
//

#INCLUDE "<inc>/Runtime.jh"

FN TlInitializeSymbolTable (
	IN symboltable : ^TlSymbolTable,
	IN deletefunc : TlHashTableEnumeratorF,
) : TlStatus

	symboltable^.PrevScope = NULLPTR
	symboltable^.DeleteRoutine = deletefunc

	RETURN TlInitializeHashTable ( &symboltable^.HashTable )
END

FN TlCreateSymbolTable (
	IN outerscope : ^TlSymbolTable,
	IN deletefunc : TlHashTableEnumeratorF,
	OUT symboltable : ^^TlSymbolTable,
) : TlStatus

	status := TlAlloc (
		SIZEOF TlSymbolTable, // bytes
		symboltable, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = TlInitializeSymbolTable (
		symboltable^, // symboltable
		deletefunc, // deletefunc
	)

	IF status THEN
		TlFree ( symboltable^ )
	END

	RETURN status
END

FN TlDeleteSymbolTable (
	IN symboltable : ^TlSymbolTable,
) : ^TlSymbolTable

	outerscope := symboltable^.PrevScope

	TlEnumerateHashTable (
		&symboltable^.HashTable, // hashtable
		symboltable^.DeleteRoutine, // deletefunc
	)

	TlFree ( symboltable )

	RETURN outerscope
END

FN TlLookupSymbolTable (
	IN symboltable : ^TlSymbolTable,
	IN name : ^UBYTE,
) : ^TlHashTableEntry

	WHILE symboltable DO
		entry := TlLookupHashTable (
			&symboltable^.HashTable, // hashtable
			name, // key
		)

		IF entry THEN
			RETURN entry
		END

		symboltable = symboltable^.PrevScope
	END

	RETURN 0
END

FN TlInsertSymbolTable (
	IN symboltable : ^TlSymbolTable,
	IN entry : ^TlHashTableEntry,
	IN name : ^UBYTE,
)

	TlInsertHashTable (
		&symboltable^.HashTable, // hashtable
		entry, // entry
		name, // key
	)
END

FN TlRemoveSymbolTable (
	IN entry : ^TlHashTableEntry,
)

	TlRemoveHashTable ( entry )
END