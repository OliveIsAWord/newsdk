//
// Implements stream objects for the lexer.
//

#INCLUDE "<inc>/Lexer.jh"

FN LexInitializeStream (
    IN stream : ^LexStream,
    IN ismacro : UBYTE,
)

    // Initialize a stream structure.

    stream^.Previous = NULLPTR
    stream^.FileBlock = NULLPTR
    stream^.FileHandle = NULLPTR

    stream^.Buffer = NULLPTR
    stream^.BufferSize = 0
    stream^.ValidLength = 0
    stream^.LineNumber = 1
    stream^.LinePosition = 1
    stream^.BufferPosition = 0
    stream^.IsMacro = ismacro
    stream^.LastWasNewline = FALSE
END

FN LexUninitializeStream (
    IN stream : ^LexStream,
)

    // Generic uninitialization for any stream type.

    IF NOT stream^.IsMacro THEN
        // This is a file stream, free the buffer.
        // We don't delete the file block since it's still referenced by
        // tokens and in a hash table and whatnot.

        TlClose ( stream^.FileHandle )
        TlFree ( stream^.Buffer )
    END
END

FN LexFreeStream (
    IN stream : ^LexStream,
)

    LexUninitializeStream ( stream )
    TlFree ( stream )
END

FN LexPushStream (
    IN stream : ^LexStream,
)

    stream^.Previous = LexCurrentStream
    LexCurrentStream = stream
END

FN LexPopStream () : ^LexStream

    oldstream := LexCurrentStream
    LexCurrentStream = oldstream^.Previous

    RETURN oldstream
END

FN LexInitializeFileStream (
    IN stream : ^LexStream,
    IN fileblock : ^FeFileBlock,
    IN handle : ^VOID,
)

    // Initialize a file stream.

    LexInitializeStream (
        stream, // stream
        FALSE, // ismacro
    )

    // Allocate the lex buffer.

    buffer : ^UBYTE

    status := TlAlloc (
        LEX_BUFFER_SIZE, // bytes
        &buffer, // OUT ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate lex buffer", 0, 0, 0 )
    END

    stream^.FileBlock = fileblock
    stream^.FileHandle = handle

    // Set up the lex buffer.

    stream^.BufferSize = LEX_BUFFER_SIZE
    stream^.Buffer = buffer
END

FN LexCreateFileStream (
    IN fileblock : ^FeFileBlock,
    IN handle : ^VOID,
) : ^LexStream

    stream : ^LexStream

    status := TlAlloc (
        SIZEOF LexStream, // bytes
        &stream, // OUT ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate stream", 0, 0, 0 )
    END

    LexInitializeFileStream (
        stream, // stream
        fileblock, // fileblock
        handle, // handle
    )

    RETURN stream
END

FN (LexGetCharacterF) LexStreamNextCharacter () : UBYTE

    // Return the next byte from the stream on top of the stream stack. If the
    // stream has been emptied, it is popped from the stack and deleted, and
    // the byte from the next stream is returned instead. If it was the last
    // stream on the stack, then EOF has been reached and a null byte is
    // returned. If a file actually contains a null byte, this function will
    // print a diagnostic and the compiler will terminate. This will also be
    // done for a 0x0D byte, which usually appears in DOS line endings. We
    // explicitly do not support DOS line endings, because the MINTIA OS does
    // not use them.
    //
    // For macro streams, there is a buffer that we will return the character
    // directly from. For file streams, there is a buffer that contains some
    // file data. When this buffer runs dry, we have to read more data in.
    // When there is no more data in the file, the stream is considered empty.
    //
    // In any case, we have to maintain the LineNumber field of the stream, by
    // incrementing it each time we encounter a newline character.

    WHILE LexCurrentStream DO
        stream := LexCurrentStream

        byte : UBYTE

        IF stream^.BufferPosition < stream^.ValidLength THEN
            // There is at least one character in the buffer, so return it.

            byte = stream^.Buffer[stream^.BufferPosition]

            stream^.BufferPosition += 1

        ELSEIF stream^.IsMacro THEN
            // The macro stream has emptied.

            LexFreeStream ( LexPopStream () )

            CONTINUE

        ELSE
            // The remaining code deals with the file stream buffer refill case.

            stream^.ValidLength = TlReadFile (
                stream^.FileHandle, // handle
                stream^.BufferSize, // bytes
                stream^.Buffer, // buffer
            )

            IF NOT stream^.ValidLength THEN
                // The end of the file has been reached. If the final
                // character wasn't a newline, then present a fake final
                // newline to the upper layers of the lexer. This avoids some
                // nasty edge cases, and guarantees a token will always be
                // terminated by whitespace (never by EOF).

                IF NOT stream^.LastWasNewline THEN
                    stream^.LastWasNewline = TRUE

                    RETURN 0x0A
                END

                LexFreeStream ( LexPopStream () )

                CONTINUE
            END

            stream^.BufferPosition = 1

            byte = stream^.Buffer[0]
        END

        IF byte == 0x00 THEN
            LexStreamError (
                "An invalid byte was found in the source file.",
                byte, 0, 0 )

        ELSEIF byte == '\r' THEN
            LexStreamError (
                "DOS line endings were detected in the source file.",
                0, 0, 0 )

        ELSEIF byte == '\n' THEN
            stream^.LineNumber += 1
            stream^.LinePosition = 1
            stream^.LastWasNewline = TRUE

        ELSE
            stream^.LinePosition += 1
            stream^.LastWasNewline = FALSE
        END

        RETURN byte
    END

    RETURN 0
END