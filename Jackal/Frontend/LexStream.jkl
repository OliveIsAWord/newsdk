//
// Implements stream objects for the lexer.
//

#INCLUDE "<inc>/Frontend.jh"
#INCLUDE "<inc>/Runtime.jh"
#INCLUDE "<inc>/Lexer.jh"

FN LexStreamInitialize (
	IN stream : ^LexStream,
	IN ismacro : UBYTE,
) : TlStatus

	// Initialize a stream structure.

	stream^.Previous = NULLPTR
	stream^.FileBlock = NULLPTR

	stream^.Buffer = NULLPTR
	stream^.BufferSize = 0
	stream^.ValidLength = 0
	stream^.LineNumber = 1
	stream^.LinePosition = 1
	stream^.BufferPosition = 0
	stream^.IsMacro = ismacro
	stream^.LastWasNewline = FALSE

	RETURN TL_SUCCESS
END

FN LexStreamUninitialize (
	IN stream : ^LexStream,
)

	// Generic uninitialization for any stream type.

	IF NOT stream^.IsMacro THEN
		// This is a file stream, free the buffer.
		// We don't delete the file block since it's still referenced by
		// tokens and such.

		TlClose ( stream^.FileBlock^.Handle )

		TlFree ( stream^.Buffer )
	END
END

FN LexStreamFree (
	IN stream : ^LexStream,
)

	LexStreamUninitialize ( stream )
	TlFree ( stream )
END

FN LexStreamPush (
	IN stream : ^LexStream,
)

	stream^.Previous = LexCurrentStream
	LexCurrentStream = stream
END

FN LexStreamPop () : ^LexStream

	oldstream := LexCurrentStream
	LexCurrentStream = oldstream^.Previous

	RETURN oldstream
END

FN LexFileStreamInitialize (
	IN stream : ^LexStream,
	IN handle : ^VOID,
	IN filename : ^UBYTE,
) : TlStatus

	// Initialize a file stream.

	status := LexStreamInitialize (
		stream, // stream
		FALSE, // ismacro
	)

	IF status THEN
		RETURN status
	END

	// Allocate the file block and lex buffer.

	fileblock : ^FeFileBlock
	buffer : ^UBYTE

	status = TlBumpAlloc (
		SIZEOF FeFileBlock, // bytes
		&fileblock, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = TlAlloc (
		LEX_BUFFER_SIZE, // bytes
		&buffer, // OUT ptr
	)

	IF status THEN
		TlFree ( fileblock )

		RETURN status
	END

	// Initialize the file block.

	fileblock^.Handle = handle

	TlStringCopy (
		&fileblock^.Name[0], // dest
		filename, // src
		JKL_PATH_BUFFER_SIZE, // bufsize
	)

	stream^.FileBlock = fileblock

	// Set up the lex buffer.

	stream^.BufferSize = LEX_BUFFER_SIZE
	stream^.Buffer = buffer

	RETURN status
END

FN LexFileStreamCreate (
	IN handle : ^VOID,
	IN filename : ^UBYTE,
	OUT stream : ^^LexStream,
) : TlStatus

	status := TlAlloc (
		SIZEOF LexStream, // bytes
		stream, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = LexFileStreamInitialize (
		stream^, // stream
		handle, // handle
		filename, // filename
	)

	IF status THEN
		TlFree ( stream^ )
	END

	RETURN status
END

FN LexStreamNextCharacter () : UBYTE

	// Return the next byte from the stream on top of the stream stack. If the
	// stream has been emptied, it is popped from the stack and deleted, and
	// the byte from the next stream is returned instead. If it was the last
	// stream on the stack, then EOF has been reached and a null byte is
	// returned. If a file actually contains a null byte, this function will
	// print a diagnostic and the compiler will terminate. This will also be
	// done for a 0x0D byte, which usually appears in DOS line endings. We
	// explicitly do not support DOS line endings, because the MINTIA OS does
	// not use them.
	//
	// For macro streams, there is a buffer that we will return the character
	// directly from. For file streams, there is a buffer that contains some
	// file data. When this buffer runs dry, we have to read more data in.
	// When there is no more data in the file, the stream is considered empty.
	//
	// In any case, we have to maintain the LineNumber field of the stream, by
	// incrementing it each time we encounter a newline character.

	WHILE LexCurrentStream DO
		stream := LexCurrentStream

		byte : UBYTE

		IF stream^.BufferPosition < stream^.ValidLength THEN
			// There is at least one character in the buffer, so return it.

			byte = stream^.Buffer[stream^.BufferPosition]

			stream^.BufferPosition += 1

		ELSEIF stream^.IsMacro THEN
			// The macro stream has emptied.

			LexStreamFree ( LexStreamPop () )

			CONTINUE

		ELSE
			// The remaining code deals with the file stream buffer refill case.

			stream^.ValidLength = TlReadFile (
				stream^.FileBlock^.Handle, // handle
				stream^.BufferSize, // bytes
				stream^.Buffer, // buffer
			)

			IF NOT stream^.ValidLength THEN
				// The end of the file has been reached. If the final
				// character wasn't a newline, then present a fake final
				// newline to the upper layers of the lexer. This avoids some
				// nasty edge cases, and guarantees a token will always be
				// terminated by whitespace (never by EOF).

				IF NOT stream^.LastWasNewline THEN
					stream^.LastWasNewline = TRUE

					RETURN 0x0A
				END

				LexStreamFree ( LexStreamPop () )

				CONTINUE
			END

			stream^.BufferPosition = 1

			byte = stream^.Buffer[0]
		END

		IF byte == 0x00 THEN
			LexStreamError (
				"An invalid byte was found in the source file.",
				byte, 0, 0 )

		ELSEIF byte == '\r' THEN
			LexStreamError (
				"DOS line endings were detected in the source file.",
				0, 0, 0 )

		ELSEIF byte == '\n' THEN
			stream^.LineNumber += 1
			stream^.LinePosition = 1
			stream^.LastWasNewline = TRUE

		ELSE
			IF byte == '\t' THEN
				// Bump line position to next multiple of four.
				// Assumes 4-wide tabs, which is the only correct tab width,
				// as everybody knows.

				// Line position is incremented only by 3 because it is already
				// biased by 1.

				stream^.LinePosition += 3
				stream^.LinePosition &= ~3
				stream^.LinePosition += 1
			ELSE
				stream^.LinePosition += 1
			END

			stream^.LastWasNewline = FALSE
		END

		RETURN byte
	END

	RETURN 0
END