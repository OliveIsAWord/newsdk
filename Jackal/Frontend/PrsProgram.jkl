//
// Parses a Jackal program and constructs an abstract syntax tree.
//

#INCLUDE "<inc>/Parser.hjk"

PUBLIC PrsGlobalListHead : ^LexSymbol = NULLPTR
PUBLIC PrsGlobalListTail : ^LexSymbol = NULLPTR

PrsCurrentBlock : ^PrsBlock = NULLPTR
PrsCurrentFunction : ^LexSemanticType = NULLPTR

PrsBlockStack : TlDynamicBuffer

ENUM PrsBlockType : UBYTE
    BLOCK_NULL,

    // Controls the behavior of the terminator keywords.

    BLOCK_PLAIN_BODY, // END is legal to terminate the block.
    BLOCK_IF_BODY, // ELSEIF, ELSE, and END are legal to terminate the block.

    // Nothing is legal to terminate the block. The lexer pushes this when it
    // expands a macro and pops it when the macro is empty.

    BLOCK_MACRO_BODY,
END

PrsWhileDepth : ULONG = 0

CONST VAR_FLAG_EXTERN := 1
CONST VAR_FLAG_PUBLIC := 2
CONST VAR_FLAG_EXPORT := 4
CONST VAR_FLAG_FUNCTION := 8

FNPTR PrsOperatorF (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

STRUCT PrsOperatorRecord
    ParseFunc : PrsOperatorF,
    Precedence : ULONG,
    NoRightSide : UBYTE,
END

PrsLeftOperators : PrsOperatorRecord[TOKEN_SUBTYPE_MAX]
PrsOperators : PrsOperatorRecord[TOKEN_SUBTYPE_MAX]

FNPTR PrsDeclaratorF () : ^LexSymbol

STRUCT PrsDeclaratorRecord
    ParseFunc : PrsDeclaratorF,
END

PrsDeclarators : PrsDeclaratorRecord[TOKEN_SUBTYPE_MAX]

FNPTR PrsStatementF ()

STRUCT PrsStatementRecord
    ParseFunc : PrsStatementF,
END

PrsStatements : PrsStatementRecord[TOKEN_SUBTYPE_MAX]

FN PrsCreateType () : ^LexSemanticType

    // Create a type.

    type : ^LexSemanticType

    status := TlBumpAlloc (
        SIZEOF LexSemanticType, // bytes
        &type, // OUT ptr
    )

    IF status THEN
        TlInternalError ( "Failed to create type", 0, 0, 0 )
    END

    RETURN type
END

FN PrsEnterMacro ()

    // The lexer calls this when it enters a macro.
    // Pushing this to the block stack ensures that the scope can't leave the
    // macro scope.

    TlInsertDynamicBuffer (
        &PrsBlockStack, // array
        BLOCK_MACRO_BODY, // byte
    )
END

FN PrsLeaveMacro () : UBYTE

    // The lexer calls this when it leaves a macro.

    byte := TlPopDynamicBuffer ( &PrsBlockStack )

    RETURN byte == BLOCK_MACRO_BODY
END

FN PrsCreateAstNode (
    IN type : PrsAstType,
    IN token : ^LexToken,
) : ^PrsAstNode

    // Create an AST node.

    node : ^PrsAstNode

    status := TlBumpAlloc (
        SIZEOF PrsAstNode, // bytes
        &node, // OUT ptr
    )

    IF status THEN
        TlInternalError ( "Failed to create AST node", 0, 0, 0 )
    END

    node^.Type = type

    LexCopyToken (
        &node^.Token, // dest
        token, // src
    )

    RETURN node
END

FN PrsCreateIdentifierNode (
    IN token : ^LexToken,
) : ^PrsAstNode

    // Create an identifier node.
    // XXX Turn this into a macro when those work.

    RETURN PrsCreateAstNode (
        AST_IDENTIFIER, // type
        token, // token
    )
END

FN PrsInsertNodeIntoBlock (
    IN block : ^PrsBlock,
    IN node : ^PrsAstNode,
)

    // Insert the node into the given block.
    // XXX Turn this into a macro when those work.
    // XXX Better yet, just use the circular list macros when we have those.

    IF NOT block^.StatementListTail THEN
        block^.StatementListHead = node
    ELSE
        block^.StatementListTail^.Next = node
    END

    block^.StatementListTail = node
END

FN PrsPrintType (
    IN type : ^LexSemanticType,
)

    // Debug function that recursively prints a type.

    TlPrintString ( "Subtype: " )
    TlPrintNumber ( type^.Subtype )
    TlPrintString ( "\n" )

    IF type^.Subtype == TYPE_PRIMITIVE THEN
        TlPrintString ( "Primitive type: " )
        TlPrintNumber ( type^.Body.Primitive.Type )
        TlPrintString ( "\n" )

    ELSEIF type^.Subtype == TYPE_NAMED THEN
        TlPrintString ( "Type name: " )
        TlPrintString ( type^.Body.Named.Symbol^.Name )
        TlPrintString ( "\n" )

    ELSEIF type^.Subtype == TYPE_POINTER THEN
        TlPrintString ( "Pointer to:\n" )
        PrsPrintType ( type^.Body.Pointer.Base )

    ELSEIF type^.Subtype == TYPE_ARRAY THEN
        TlPrintString ( "Array with bound: " )

        IF type^.Body.Array.HasBound THEN
            TlPrintNumber ( type^.Body.Array.Bound )
            TlPrintString ( ", of:\n" )
        ELSE
            TlPrintString ( "Boundless, of:\n" )
        END

        PrsPrintType ( type^.Body.Array.Base )
    END
END

FN PrsIsCompileTime (
    IN node : ^PrsAstNode,
) : UBYTE

    // Evaluates whether the value of a node can be known at compile time.

    IF node^.Type == AST_CONSTANT THEN
        RETURN TRUE
    END

    IF node^.Type == AST_STRING THEN
        RETURN TRUE
    END

    IF node^.Type == AST_OPERATOR AND
        node^.Token.Subtype == TOKEN_ADDROF AND
        node^.Body.Operator.Left^.Type == AST_IDENTIFIER THEN

        RETURN TRUE
    END

    IF node^.Type == AST_INITIALIZER THEN
        RETURN TRUE
    END

    RETURN FALSE
END

FN PrsAtom () : ^PrsAstNode

    // Parse an atom. This is an "atomic" part of an expression, such as a
    // single constant number or identifier.

    atomnode : ^PrsAstNode

    token : LexToken

    LexGetToken ( &token )

    IF token.Type == TOKEN_NUMBER THEN
        // This is a constant number.

        atomnode = PrsCreateAstNode (
            AST_CONSTANT,
            &token, // token
        )

        atomnode^.Body.Constant.Value = CAST token.Payload TO TlMachineWord

    ELSEIF token.Type == TOKEN_IDENTIFIER THEN
        // This is an identifier. The symbol pointer and stuff stay in the token
        // payload.

        IF token.Subtype == TOKEN_IDENTIFIER_NEW THEN
            LexTokenError ( &token, "Use of undeclared symbol.", 0, 0, 0 )
        END

        symbol := CAST token.Payload TO ^LexSymbol

        IF symbol^.Type == SYM_CONSTANT THEN
            // This is a constant.

            atomnode = PrsCreateAstNode (
                AST_CONSTANT,
                &token, // token
            )

            atomnode^.Body.Constant.Value = symbol^.Value

        ELSEIF symbol^.Type == SYM_VAR THEN
            atomnode = PrsCreateIdentifierNode (
                &token, // token
            )

        ELSE
            LexTokenError ( &token, "Expected a variable.", 0, 0, 0 )
        END

    ELSEIF token.Type == TOKEN_STRING THEN
        // This is a literal string. The value of the string stays in the
        // token payload.

        atomnode = PrsCreateAstNode (
            AST_STRING,
            &token, // token
        )

    ELSEIF token.Type == TOKEN_OPER AND token.Subtype == TOKEN_LPAREN THEN
        // This is a parenthesized expression.

        atomnode = PrsExpression ( 0 )

        // Collect the right parenthesis.

        IF NOT LexMatchToken (
            &token, // token
            TOKEN_RPAREN, // type
            0, // subtype
        ) THEN
            LexTokenError ( &token, "Expected a right parenthesis.", 0, 0, 0 )
        END

    ELSEIF token.Type == TOKEN_OPER THEN
        // This must be a left-operator. Look it up in the table.
        // The operator type stays as the subtype of the token.

        operator := &PrsLeftOperators[token.Subtype]

        IF NOT operator^.Precedence THEN
            LexTokenError ( &token, "Expected a left operator.", 0, 0, 0 )
        END

        atomnode = PrsCreateAstNode (
            AST_OPERATOR, // type
            &token, // token
        )

        IF NOT operator^.NoRightSide THEN
            // Actually the left side but who's checking.

            atomnode^.Body.Operator.Left = PrsExpression ( operator^.Precedence )
        END

        IF operator^.ParseFunc THEN
            operator^.ParseFunc (
                operator, // operator
                atomnode, // node
            )
        END

    ELSEIF token.Type == TOKEN_VALUE THEN
        // This is a primitive value, such as NULLPTR, TRUE, or FALSE.
        // The value type stays as the subtype of the token.

        IF token.Subtype == TOKEN_TRUE THEN
            atomnode = PrsCreateAstNode (
                AST_CONSTANT,
                &token, // token
            )

            atomnode^.Body.Constant.Value = 1

        ELSEIF token.Subtype == TOKEN_FALSE THEN
            atomnode = PrsCreateAstNode (
                AST_CONSTANT,
                &token, // token
            )

            atomnode^.Body.Constant.Value = 0

        ELSE
            atomnode = PrsCreateAstNode (
                AST_PRIM_VALUE,
                &token, // token
            )
        END

    ELSE
        LexTokenError ( &token, "Expected an atom.", 0, 0, 0 )
    END

    RETURN atomnode
END

FN PrsExpression (
    IN minprecedence : ULONG,
) : ^PrsAstNode

    // Parse a expression. Pays attention to precedence.

    atomnode := PrsAtom ()

    optoken : LexToken

    WHILE LexMatchToken (
        &optoken, // token
        TOKEN_OPER, // type
        0, // subtype
    ) DO
        operator := &PrsOperators[optoken.Subtype]

        IF NOT operator^.Precedence THEN
            // This must have been a left operator, which we didn't expect.

            LexTokenError ( &optoken, "Unexpected left operator", 0, 0, 0 )
        END

        IF operator^.Precedence < minprecedence THEN
            // Put the operator token back.

            LexPutbackToken ( &optoken )

            BREAK
        END

        node := PrsCreateAstNode (
            AST_OPERATOR, // type
            &optoken, // token
        )

        node^.Body.Operator.Left = atomnode

        IF NOT operator^.NoRightSide THEN
            node^.Body.Operator.Right = PrsExpression ( minprecedence + 1 )
        END

        IF operator^.ParseFunc THEN
            operator^.ParseFunc (
                operator, // operator
                node, // node
            )
        END

        atomnode = node
    END

    RETURN atomnode
END

FN PrsParseInitializer () : ^PrsAstNode

    // Parse an initializer. This is either of the form { ... } or it's an
    // expression.

    IF NOT LexMatchToken (
        NULLPTR, // token
        TOKEN_LBRACE, // type
        0, // subtype
    ) THEN
        // It's an expression initializer.

        RETURN PrsExpression ( 0 )
    END

    // It's a fancy array or struct initializer.

    TlInternalError ( "TODO parse array initializer", 0, 0, 0 )

    RETURN NULLPTR
END

FN PrsCheckType (
    IN type1 : ^LexSemanticType,
    IN type2 : ^LexSemanticType,
) : UBYTE

    // Compare the two types.

    TlInternalError ( "TODO PrsCheckType", 0, 0, 0 )
END

FN PrsEvaluateType (
    IN node : ^PrsAstNode,
) : ^LexSemanticType

    // Evaluate the type that will be produced by an AST expression.

    TlInternalError ( "TODO PrsEvaluateType", 0, 0, 0 )
END

FN PrsType (
    IN type : ^LexSemanticType,
    IN depth : UBYTE,
)

    // Parse the type into the provided type structure.

    typetoken : LexToken

    LexGetToken ( &typetoken )

    // First check if it's a primitive type.

    IF typetoken.Type == TOKEN_PTYPE THEN
        // It's a primitive type, that was easy!

        type^.Subtype = TYPE_PRIMITIVE
        type^.Body.Primitive.Type = typetoken.TypeContext

    ELSEIF typetoken.Type == TOKEN_OPER AND typetoken.Subtype == TOKEN_CARET THEN
        // It's a pointer type! Allocate a base type.

        basetype := PrsCreateType ()

        // Parse the base type into it.

        PrsType (
            basetype, // type
            depth + 1, // depth
        )

        type^.Subtype = TYPE_POINTER
        type^.Body.Pointer.Base = basetype

    ELSEIF typetoken.Type == TOKEN_IDENTIFIER THEN
        // It's a named type!

        symbol := CAST typetoken.Payload TO ^LexSymbol

        IF typetoken.Subtype == TOKEN_IDENTIFIER_FOUND THEN
            // This symbol has already appeared, so verify that it's a type.

            IF symbol^.Type != SYM_TYPE AND
                symbol^.Type != SYM_FORWARD_TYPE THEN

                // Nope, that's bad :(

                LexTokenError ( &typetoken, "Symbol isn't a type", 0, 0, 0 )
            END
        ELSE
            // This is a new type, so forward declare it for now.

            symbol^.Type = SYM_FORWARD_TYPE
        END

        type^.Subtype = TYPE_NAMED
        type^.Body.Named.Symbol = symbol

    ELSE
        // Type didn't match with anything we expected.

        LexTokenError ( &typetoken,
            "Type must be primitive, pointer, or named.", 0, 0, 0 )
    END

    IF depth THEN
        // We don't collect the array components if the type is nested at all.

        LEAVE
    END

    // Collect array components, if any exist. This has to be done in a manner
    // such that the type structure we were passed in becomes the head of a
    // chain of array types, where the tail of the chain contains the original
    // type.

    IF NOT LexMatchToken (
        NULLPTR, // token
        TOKEN_OPER, // type
        TOKEN_LBRACKET, // subtype
    ) THEN
        // No array components.

        LEAVE
    END

    dimensions := 1
    boundless := FALSE

    // There are array components, so firstly we need to allocate a base type
    // and move whatever we created for this type into it.

    basetype := PrsCreateType ()

    TlCopyMemory (
        basetype, // dest
        type, // src
        SIZEOF LexSemanticType, // sz
    )

    arraytype := type

    arraytail : ^LexSemanticType = NULLPTR

    WHILE TRUE DO
        arraytype^.Subtype = TYPE_ARRAY

        IF arraytail THEN
            arraytail^.Body.Array.Base = arraytype
        END

        arraytail = arraytype

        IF LexMatchToken (
            NULLPTR, // token
            TOKEN_RBRACKET, // type
            0, // subtype
        ) THEN
            // The array is boundless.

            IF dimensions > 1 THEN
                LexTokenError ( &typetoken,
                    "Boundless arrays can't be multidimensional.", 0, 0, 0 )
            END

            boundless = TRUE

            arraytype^.Body.Array.HasBound = FALSE
        ELSE
            boundnode := PrsExpression ( 0 )

            IF boundnode^.Type != AST_CONSTANT THEN
                LexTokenError ( &typetoken,
                    "Expected a constant array bound", 0, 0, 0 )
            END

            arraytype^.Body.Array.Bound = boundnode^.Body.Constant.Value
            arraytype^.Body.Array.HasBound = TRUE

            rbrackettoken : LexToken

            IF NOT LexMatchToken (
                &rbrackettoken, // token
                TOKEN_RBRACKET, // type
                0, // subtype
            ) THEN
                LexTokenError ( &rbrackettoken,
                    "Array type must be terminated by right bracket.", 0, 0, 0 )
            END
        END

        IF NOT LexMatchToken (
            NULLPTR, // token
            TOKEN_OPER, // type
            TOKEN_LBRACKET, // subtype
        ) THEN
            // No more array components.

            BREAK
        END

        IF boundless THEN
            LexTokenError ( &typetoken,
                "Boundless arrays can't be multidimensional.", 0, 0, 0 )
        END

        dimensions += 1

        arraytype = PrsCreateType ()
    END

    arraytail^.Body.Array.Base = basetype
END

FN PrsFoundSymbol (
    IN token : ^LexToken,
    IN symbol : ^LexSymbol,
    IN flags : ULONG,
    IN global : UBYTE,
    IN newtype : ^LexSemanticType,
)

    // A symbol is being declared. Check for override and make sure stuff is
    // legal and whatever. This is its own function because it is common between
    // function and variable declarations.

    IF token^.Subtype == TOKEN_IDENTIFIER_FOUND THEN
        // This symbol has already appeared, so we want to find out if this is
        // a valid override.

        IF symbol^.Type != SYM_VAR THEN
            // This symbol isn't the expected type.

            LexTokenError ( token, "Symbol name already in use.", 0, 0, 0 )
        END

        IF flags & VAR_FLAG_EXTERN THEN
            // This is an attempt at an extern declaration. Externs can't
            // override anything.

            LexTokenError ( token, "Symbol already declared.", 0, 0, 0 )
        END

        IF NOT (symbol^.Flags & VAR_FLAG_EXTERN) THEN
            // Can only override externs.

            LexTokenError ( token, "Symbol already declared.", 0, 0, 0 )
        END

        IF NOT global THEN
            // Can't override externs from local scope.

            LexTokenError ( token,
                "Can't override extern from local scope.", 0, 0, 0 )
        END

        IF NOT PrsCheckType ( symbol^.SemanticType, newtype ) THEN
            LexTokenError ( token,
                "Can't override, types don't match.", 0, 0, 0 )
        END
    ELSE
        // Initialize the symbol.

        symbol^.Type = SYM_VAR

        IF global THEN
            // Add it to the list of globals, at the tail.

            tail := PrsGlobalListTail

            symbol^.Next = NULLPTR
            symbol^.Prev = tail

            IF tail THEN
                tail^.Next = symbol
            ELSE
                PrsGlobalListHead = symbol
            END

            PrsGlobalListTail = symbol
        END
    END

    symbol^.Flags = flags

    symbol^.SemanticType = newtype

    // We should see if there's a pending section override from the lexer, and
    // do it now if so.

    IF LexNextSymbolSection THEN
        // There was a single-symbol section override via SECTION directive.

        symbol^.Section = LexNextSymbolSection
        LexNextSymbolSection = NULLPTR
    ELSE
        symbol^.Section = LexCurrentSection
    END
END

FN PrsVariableDeclaration (
    IN token : ^LexToken,
    IN flags : ULONG,
    IN global : UBYTE,
) : ^LexSymbol

    // Parse a variable declaration of one of the following forms:
    //
    //  name : type = initial
    //  name : = initial
    //  name : type
    //
    // The colon has already been consumed (that's how the caller knew this is a
    // declaration and not an assignment).
    // Non-extern declarations may override extern declarations.
    // Extern declarations must not have an initial value, just a name and type.
    // The passed in token contains the relevant symbol already.
    // For local declarations, we should generate an AST assignment node.
    // For globals, we should just associate the initial value with the symbol,
    // and add the symbol to a list of globals for the whole program. The
    // initial value AST node is interpreted in the next phase of the compiler.

    symbol := CAST token^.Payload TO ^LexSymbol

    // Now we have to check if the next token is an equals sign. If so, the type
    // is inferred. Otherwise, we have to put the token back and parse the type.

    type : ^LexSemanticType = NULLPTR

    hasinitializer := TRUE

    IF NOT LexMatchToken (
        NULLPTR, // token
        TOKEN_ASSIGN, // type
        TOKEN_EQUALS, // subtype
    ) THEN
        // The type is explicit. Parse that now.

        type = PrsCreateType ()

        PrsType (
            type, // type
            0, // depth
        )

        PrsPrintType ( type )

        eqtoken : LexToken

        IF NOT LexMatchToken (
            &eqtoken, // token
            TOKEN_ASSIGN, // type
            TOKEN_EQUALS, // subtype
        ) THEN
            // This variable is uninitialized.

            hasinitializer = FALSE
        END
    END

    initialnode : ^PrsAstNode = NULLPTR

    IF hasinitializer THEN
        IF flags & VAR_FLAG_EXTERN THEN
            LexTokenError ( token,
                "EXTERN declarations must not have an initializer.", 0, 0, 0 )
        END

        // Parse the initializer.

        initialnode = PrsParseInitializer ()

        IF NOT type THEN
            // If the type was implicit, evaluate the type of the initial value.

            type = PrsEvaluateType ( initialnode )
        END
    END

    // Do general declaration processing of the symbol.

    PrsFoundSymbol (
        token, // token
        symbol, // symbol
        flags, // flags
        global, // global
        type, // newtype
    )

    IF NOT global THEN
        IF hasinitializer THEN
            // Create an AST node for the assignment of the initial value.

            idnode := PrsCreateIdentifierNode ( token )

            asgnnode := PrsCreateAstNode (
                AST_ASSIGN, // type
                token, // token
            )

            asgnnode^.Body.Assign.Left = idnode
            asgnnode^.Body.Assign.Right = initialnode

            // We can place it directly in the statement list for the current
            // block because the existence of a block is implied by the fact
            // this is a local declaration.

            PrsInsertNodeIntoBlock (
                PrsCurrentBlock, // block
                asgnnode, // node
            )
        END
    ELSEIF initialnode THEN
        // Statically evaluate the initial value. If it can't be statically
        // evaluated, that's an error, since this is a global. Note that we
        // might still leave it as a "complex" AST node if it's a pointer to
        // some other global or something because we don't know the value of
        // that immediately.

        // TODO only allow initializer if the type is an array, struct, or union
        //      type

        IF NOT PrsIsCompileTime ( initialnode ) THEN
            LexTokenError ( token,
                "Globals require a compile-time initial value.", 0, 0, 0 )
        END

        TlPrintNumber ( initialnode^.Body.Constant.Value )

        symbol^.InitialValue = initialnode
    ELSE
        // Uninitialized globals have a value of zero, always.
        // Backend may place this in BSS.

        initialnode = PrsCreateAstNode (
            AST_CONSTANT, // type
            token, // token
        )

        initialnode^.Body.Constant.Value = 0

        symbol^.InitialValue = initialnode
    END

    RETURN symbol
END

FN PrsGlobalDeclaration () : UBYTE

    // Parse the next global declaration. Return FALSE on EOF.

    token : LexToken

    LexGetToken ( &token )

    IF token.Type == TOKEN_EOF THEN
        RETURN FALSE
    END

    IF token.Type != TOKEN_IDENTIFIER AND token.Type != TOKEN_DECL THEN
        LexTokenError ( &token,
            "Expected identifier or declarative keyword", 0, 0, 0 )
    END

    IF token.Type == TOKEN_IDENTIFIER THEN
        // This is a non-public, non-extern variable declaration.
        // It may be overriding an extern declaration.

        colontoken : LexToken

        IF NOT LexMatchToken (
            &colontoken, // token
            TOKEN_COLON, // type
            TOKEN_SUBTYPE_ANY, // subtype
        ) THEN
            // There MUST be a colon for global declarations, otherwise it would
            // be a global assignment which makes no sense.

            LexTokenError ( &colontoken,
                "Expected a colon (indicating a declaration).", 0, 0, 0 )
        END

        PrsVariableDeclaration (
            &token, // token
            0, // flags
            TRUE, // global
        )

        RETURN TRUE
    END

    // This is a declarative keyword of some variety.

    PrsDeclarators[token.Subtype].ParseFunc ()

    RETURN TRUE
END

FN PrsParseBlock (
    OUT terminator : ^LexTokenSubtype,
) : ^PrsBlock

    // Parse a block. A block is composed of a sequence of statements, followed
    // by one of the allowed terminator keywords.

    block : ^PrsBlock

    status := TlBumpAlloc (
        SIZEOF PrsBlock, // bytes
        &block, // OUT ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate a block", 0, 0, 0 )
    END

    // Initialize the block.

    block^.StatementListHead = NULLPTR
    block^.StatementListTail = NULLPTR
    block^.StatementCount = 0

    // Save the old block and set the new.

    oldblock := PrsCurrentBlock
    PrsCurrentBlock = block

    WHILE TRUE DO
        token : LexToken

        IF LexMatchToken (
            &token, // token
            TOKEN_TERMINATOR, // type
            0, // subtype
        ) THEN
            // We found a terminator keyword. Check if this terminator is
            // allowed right now and break out.

            terminator^ = token.Subtype

            IF PrsBlockStack.Count == 0 THEN
                TlInternalError ( "Block stack was empty", 0, 0, 0 )
            END

            blockstate := PrsBlockStack.Buffer[PrsBlockStack.Count - 1]

            IF blockstate == BLOCK_MACRO_BODY THEN
                LexTokenError ( &token,
                    "Attempt to leave block from within macro", 0, 0, 0 )
            END

            IF blockstate == BLOCK_PLAIN_BODY THEN
                IF token.Subtype != TOKEN_END THEN
                    LexTokenError ( &token,
                        "Only END is allowed to terminate this block", 0, 0, 0 )
                END

                BREAK
            END

            IF blockstate == BLOCK_IF_BODY THEN
                BREAK
            END

            TlInternalError ( "PrsParseBlock Unreachable", blockstate, 0, 0 )
        END

        IF LexMatchToken (
            &token, // token
            TOKEN_STATEMENT, // type
            0, // subtype
        ) THEN
            // We found a statement keyword. Look up the table and call the
            // parse function for the statement.

            PrsStatements[token.Subtype].ParseFunc ()

            CONTINUE
        END

        // There are now three options:
        //
        // Declaration: IDENTIFIER : TYPE = INITIAL
        // Assignment: EXPR = EXPR
        // Expression w/ side effects: EXPR
        //
        // The only way to tell if it's a declaration is to look ahead by two
        // tokens. After we've ruled that out we can safely eat an expression.
        // Then we check if there's an equals sign; if so, it's an assignment,
        // otherwise, it's a free-floating expression (such as a function call).

        decl := FALSE

        LexGetToken ( &token )

        IF token.Type == TOKEN_IDENTIFIER THEN
            // Maybe a declaration? Check for the colon.

            colontoken : LexToken

            IF LexMatchToken (
                &colontoken, // token
                TOKEN_COLON, // type
                0, // subtype
            ) THEN
                // Yep!

                decl = TRUE
            END
        END

        IF decl THEN
            // It was a declaration, parse the rest.

            PrsVariableDeclaration (
                &token, // token
                0, // flags
                FALSE, // global
            )
        ELSE
            // Not a declaration. Put the token back and try the expression
            // cases.

            LexPutbackToken ( &token )

            leftexpr := PrsExpression ( 0 )

            // Check for an assign operator.

            assigntoken : LexToken

            IF LexMatchToken (
                &assigntoken, // token
                TOKEN_ASSIGN, // type
                0, // subtype
            ) THEN
                // Found an assign operator.

                asgnnode := PrsCreateAstNode (
                    AST_ASSIGN, // type
                    &token, // token
                )

                asgnnode^.Body.Assign.Left = leftexpr
                asgnnode^.Body.Assign.Right = PrsExpression ( 0 )

                PrsInsertNodeIntoBlock (
                    block, // block
                    asgnnode, // node
                )
            ELSE
                // Free floating expression.

                PrsInsertNodeIntoBlock (
                    block, // block
                    leftexpr, // node
                )
            END
        END
    END

    // Restore the old block.

    PrsCurrentBlock = oldblock

    RETURN block
END

// Special operator parse routines.

FN (PrsOperatorF) PrsParseCompoundTypeIndex (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    // Parse a compound type index. We need to evaluate the type of the left
    // side, and make sure it's really a compound type (i.e., a STRUCT or a
    // UNION). Then, we set the lexical scope to the one for the compound type's
    // field names, and collect the field name.

    TlInternalError ( "TODO PrsParseCompoundTypeIndex", 0, 0, 0 )
END

FN (PrsOperatorF) PrsParseArrayIndex (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    // Parse an array index. We have to collect the index itself and the right
    // bracket.

    node^.Body.Operator.Right = PrsExpression ( 0 )

    token : LexToken

    IF NOT LexMatchToken (
        &token, // token
        TOKEN_RBRACKET, // type
        0, // subtype
    ) THEN
        LexTokenError ( &token, "Expected a right bracket", 0, 0, 0 )
    END
END

FN (PrsOperatorF) PrsParseFunctionCall (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    // Parse a function call. We have to collect the arguments and the right
    // parenthesis. The head of the arguments list goes in the operator-specific
    // field.

    argtail : ^PrsAstNode = NULLPTR
    node^.Body.Operator.OperatorSpecific = NULLPTR

    IF LexMatchToken (
        &token, // token
        TOKEN_RPAREN, // type
        0, // subtype
    ) THEN
        // No arguments.

        LEAVE
    END

    token : LexToken

    WHILE TRUE DO
        node := PrsExpression ( 0 )

        node^.Next = NULLPTR

        IF NOT argtail THEN
            node^.Body.Operator.OperatorSpecific = node
        ELSE
            argtail^.Next = node
        END

        argtail = node

        IF LexMatchToken (
            &token, // token
            TOKEN_RPAREN, // type
            0, // subtype
        ) THEN
            // Done with the argument list.

            BREAK
        END

        IF NOT LexMatchToken (
            &token, // token
            TOKEN_COMMA, // type
            0, // subtype
        ) THEN
            // Bad.

            LexTokenError ( &token,
                "Expected a comma or right parenthesis", 0, 0, 0 )
        END

        IF LexMatchToken (
            &token, // token
            TOKEN_RPAREN, // type
            0, // subtype
        ) THEN
            // Done with the argument list. This isn't redundant, it's to
            // allow the ,) case.

            BREAK
        END
    END
END

FN PrsIsPowerOfTwo (
    IN constant : TlMachineWord,
) : ULONG

    // Check if the constant is a power of two. If it is, return which Nth power
    // of two it is. This is used for some basic strength reduction.

    IF constant == 0 THEN
        RETURN -1
    END

    bitpos := 0

    WHILE TRUE DO
        IF constant & 1 THEN
            IF constant != 1 THEN
                RETURN -1
            END

            RETURN bitpos
        END

        constant >>= 1
        bitpos += 1
    END
END

FN (PrsOperatorF) PrsParseMul (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type != AST_CONSTANT AND right^.Type != AST_CONSTANT THEN
        // No opportunities for simplification.

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value * right^.Body.Constant.Value

        LEAVE
    END

    IF left^.Type == AST_CONSTANT THEN
        IF left^.Body.Constant.Value == 0 THEN
            // We can roll this into the constant zero.

            node^.Type = AST_CONSTANT

            node^.Body.Constant.Value = 0

            LEAVE
        ELSEIF left^.Body.Constant.Value == 1 THEN
            // We can roll this into the right side.

            TlCopyMemory (
                node, // dest
                right, // src
                SIZEOF PrsAstNode, // sz
            )

            LEAVE
        END
    END

    IF right^.Type == AST_CONSTANT THEN
        IF right^.Body.Constant.Value == 0 THEN
            // We can roll this into the constant zero.

            node^.Type = AST_CONSTANT

            node^.Body.Constant.Value = 0

            LEAVE
        ELSEIF right^.Body.Constant.Value == 1 THEN
            // We can roll this into the left side.

            TlCopyMemory (
                node, // dest
                left, // src
                SIZEOF PrsAstNode, // sz
            )

            LEAVE
        END

        pwrtwo := PrsIsPowerOfTwo ( right^.Body.Constant.Value )

        IF pwrtwo != -1 THEN
            // Cool, it's a power of two, we can reduce this into a left shift.

            node^.Token.Subtype = TOKEN_LEFTSHIFT

            right^.Body.Constant.Value = pwrtwo

            LEAVE
        END
    END
END

FN (PrsOperatorF) PrsParseDivide (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type != AST_CONSTANT AND right^.Type != AST_CONSTANT THEN
        // No opportunities for simplification.

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        IF right^.Body.Constant.Value == 0 THEN
            LexTokenError ( &node^.Token, "Division by zero not allowed", 0, 0, 0 )
        END

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value / right^.Body.Constant.Value

        LEAVE
    END

    IF right^.Type == AST_CONSTANT THEN
        IF right^.Body.Constant.Value == 1 THEN
            // We can roll this into the left side.

            TlCopyMemory (
                node, // dest
                left, // src
                SIZEOF PrsAstNode, // sz
            )

            LEAVE
        END

        pwrtwo := PrsIsPowerOfTwo ( right^.Body.Constant.Value )

        IF pwrtwo != -1 THEN
            // Cool, it's a power of two, we can reduce this into a right shift.

            node^.Token.Subtype = TOKEN_RIGHTSHIFT

            right^.Body.Constant.Value = pwrtwo

            LEAVE
        END
    END
END

FN (PrsOperatorF) PrsParseModulo (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type != AST_CONSTANT AND right^.Type != AST_CONSTANT THEN
        // No opportunities for simplification.

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        IF right^.Body.Constant.Value == 0 THEN
            LexTokenError ( &node^.Token, "Modulo by zero not allowed", 0, 0, 0 )
        END

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value % right^.Body.Constant.Value

        LEAVE
    END

    IF right^.Type == AST_CONSTANT THEN
        IF right^.Body.Constant.Value == 1 THEN
            // We can turn this into the constant zero.

            node^.Type = AST_CONSTANT

            node^.Body.Constant.Value = 0

            LEAVE
        END

        pwrtwo := PrsIsPowerOfTwo ( right^.Body.Constant.Value )

        IF pwrtwo != -1 THEN
            // Cool, it's a power of two, we can reduce this into a bit mask.

            node^.Token.Subtype = TOKEN_BITAND

            right^.Body.Constant.Value = right^.Body.Constant.Value - 1

            LEAVE
        END
    END
END

FN (PrsOperatorF) PrsParsePlus (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type != AST_CONSTANT AND right^.Type != AST_CONSTANT THEN
        // No opportunities for simplification.

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value + right^.Body.Constant.Value

        LEAVE
    END

    IF right^.Type == AST_CONSTANT AND right^.Body.Constant.Value == 0 THEN
        // No effect. Copy the left node over us.

        TlCopyMemory (
            node, // dest
            left, // src
            SIZEOF PrsAstNode
        )

        LEAVE
    END

    IF left^.Type == AST_CONSTANT THEN
        // Shuffle it to the right side; this is somewhat simplifying since
        // we're commutative.

        node^.Body.Operator.Right = left
        node^.Body.Operator.Left = right

        left = right
        right = node^.Body.Operator.Right
    END

    // Check various arithmetic cases for simplification.
    // TODO test these more thoroughly

    IF left^.Type == AST_OPERATOR THEN
        b := right^.Body.Constant.Value

        IF left^.Token.Subtype == TOKEN_PLUS AND
            left^.Body.Operator.Right^.Type == AST_CONSTANT THEN

            // (x + a) + b -> x + (a + b)

            a := left^.Body.Operator.Right^.Body.Constant.Value

            right^.Body.Constant.Value = a + b

            node^.Body.Operator.Left = left^.Body.Operator.Left

            LEAVE

        ELSEIF left^.Token.Subtype == TOKEN_MINUS AND
            left^.Body.Operator.Right^.Type == AST_CONSTANT THEN

            // (x - a) + b -> x - (a - b)

            a := left^.Body.Operator.Right^.Body.Constant.Value

            right^.Body.Constant.Value = a - b

            node^.Body.Operator.Left = left^.Body.Operator.Left
            node^.Token.Subtype = TOKEN_MINUS

            LEAVE

        ELSEIF left^.Token.Subtype == TOKEN_MINUS AND
            left^.Body.Operator.Left^.Type == AST_CONSTANT THEN

            // (a - x) + b -> (a + b) - x

            a := left^.Body.Operator.Left^.Body.Constant.Value

            node^.Body.Operator.Left = right

            right^.Body.Constant.Value = a + b

            node^.Body.Operator.Right = left^.Body.Operator.Right
            node^.Token.Subtype = TOKEN_MINUS

            LEAVE
        END
    END
END

FN (PrsOperatorF) PrsParseMinus (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type != AST_CONSTANT AND right^.Type != AST_CONSTANT THEN
        // No opportunities for simplification.

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value - right^.Body.Constant.Value

        LEAVE
    END

    IF right^.Type == AST_CONSTANT AND right^.Body.Constant.Value == 0 THEN
        // No effect. Copy the left node over us.

        TlCopyMemory (
            node, // dest
            left, // src
            SIZEOF PrsAstNode
        )

        LEAVE
    END

    // Check various arithmetic cases for simplification.
    // TODO test these more thoroughly

    IF left^.Type == AST_OPERATOR THEN
        b := right^.Body.Constant.Value

        IF left^.Token.Subtype == TOKEN_MINUS THEN
            IF left^.Body.Operator.Right^.Type == AST_CONSTANT THEN
                // (x - a) - b  ->  x - (a + b)

                a := left^.Body.Operator.Right^.Body.Constant.Value

                right^.Body.Constant.Value = a + b

                node^.Body.Operator.Left = left^.Body.Operator.Left

                LEAVE
            ELSEIF left^.Body.Operator.Left^.Type == AST_CONSTANT THEN
                // (a - x) - b  ->  (a - b) - x

                a := left^.Body.Operator.Left^.Body.Constant.Value

                right^.Body.Constant.Value = a - b

                node^.Body.Operator.Left = right
                node^.Body.Operator.Right = left^.Body.Operator.Right

                LEAVE
            END
        ELSEIF left^.Token.Subtype == TOKEN_PLUS AND
            left^.Body.Operator.Right^.Type == AST_CONSTANT THEN

            // (x + a) - b -> x + (a - b)

            a := left^.Body.Operator.Right^.Body.Constant.Value

            right^.Body.Constant.Value = a - b

            node^.Token.Subtype = TOKEN_PLUS
            node^.Body.Operator.Left = left^.Body.Operator.Left

            LEAVE
        END
    END

    IF right^.Type == AST_OPERATOR THEN
        b := left^.Body.Constant.Value

        IF right^.Token.Subtype == TOKEN_MINUS THEN
            IF right^.Body.Operator.Right^.Type == AST_CONSTANT THEN
                // b - (x - a) -> (a + b) - x

                a := right^.Body.Operator.Right^.Body.Constant.Value

                left^.Body.Constant.Value = a + b

                node^.Body.Operator.Right = right^.Body.Operator.Left

                LEAVE
            ELSEIF right^.Body.Operator.Left^.Type == AST_CONSTANT THEN
                // b - (a - x) -> x + (b - a)

                a := right^.Body.Operator.Left^.Body.Constant.Value

                left^.Body.Constant.Value = b - a

                node^.Token.Subtype = TOKEN_PLUS
                node^.Body.Operator.Left = right^.Body.Operator.Right

                LEAVE
            END
        ELSEIF right^.Token.Subtype == TOKEN_PLUS AND
            right^.Body.Operator.Right^.Type == AST_CONSTANT THEN
            
            // b - (x + a) -> (b - a) - x

            a := right^.Body.Operator.Right^.Body.Constant.Value

            left^.Body.Constant.Value = b - a

            node^.Body.Operator.Right = right^.Body.Operator.Left

            LEAVE
        END
    END
END

FN (PrsOperatorF) PrsParseLeftShift (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value << right^.Body.Constant.Value

        LEAVE
    END

    IF right^.Type == AST_CONSTANT AND right^.Body.Constant.Value == 0 THEN
        // No effect. Copy the left node over us.

        TlCopyMemory (
            node, // dest
            left, // src
            SIZEOF PrsAstNode
        )
    END
END

FN (PrsOperatorF) PrsParseRightShift (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value >> right^.Body.Constant.Value

        LEAVE
    END

    IF right^.Type == AST_CONSTANT AND right^.Body.Constant.Value == 0 THEN
        // No effect. Copy the left node over us.

        TlCopyMemory (
            node, // dest
            left, // src
            SIZEOF PrsAstNode
        )
    END
END

FN (PrsOperatorF) PrsParseBitAnd (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value & right^.Body.Constant.Value

        LEAVE
    END

    IF (right^.Type == AST_CONSTANT AND right^.Body.Constant.Value == 0) OR
        (left^.Type == AST_CONSTANT AND left^.Body.Constant.Value == 0) THEN

        // We can roll this into the constant zero.

        node^.Type = AST_CONSTANT
        node^.Body.Constant.Value = 0

        LEAVE
    END

    IF right^.Type == AST_CONSTANT AND
        right^.Body.Constant.Value == TL_MACHINE_WORD_MAX THEN

        // No effect. Copy the left node over us.

        TlCopyMemory (
            node, // dest
            left, // src
            SIZEOF PrsAstNode
        )

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND
        left^.Body.Constant.Value == TL_MACHINE_WORD_MAX THEN

        // No effect. Copy the right node over us.

        TlCopyMemory (
            node, // dest
            right, // src
            SIZEOF PrsAstNode
        )
    END
END

FN (PrsOperatorF) PrsParseBitXor (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value $ right^.Body.Constant.Value

        LEAVE
    END

    IF right^.Type == AST_CONSTANT AND right^.Body.Constant.Value == 0 THEN
        // No effect. Copy the left node over us.

        TlCopyMemory (
            node, // dest
            left, // src
            SIZEOF PrsAstNode
        )

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND left^.Body.Constant.Value == 0 THEN
        // No effect. Copy the right node over us.

        TlCopyMemory (
            node, // dest
            right, // src
            SIZEOF PrsAstNode
        )

        LEAVE
    END

    IF right^.Type == AST_CONSTANT AND
        right^.Body.Constant.Value == TL_MACHINE_WORD_MAX THEN

        // Turn this node into a bitwise NOT of the left side.

        node^.Type = AST_OPERATOR
        node^.Token.Subtype = TOKEN_BITNOT

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND
        left^.Body.Constant.Value == TL_MACHINE_WORD_MAX THEN

        // Turn this node into a bitwise NOT of the right side.

        node^.Type = AST_OPERATOR
        node^.Token.Subtype = TOKEN_BITNOT
        node^.Body.Operator.Left = node^.Body.Operator.Right
    END
END

FN (PrsOperatorF) PrsParseBitOr (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value | right^.Body.Constant.Value

        LEAVE
    END

    IF right^.Type == AST_CONSTANT AND right^.Body.Constant.Value == 0 THEN
        // No effect. Copy the left node over us.

        TlCopyMemory (
            node, // dest
            left, // src
            SIZEOF PrsAstNode
        )

        LEAVE
    END

    IF left^.Type == AST_CONSTANT AND left^.Body.Constant.Value == 0 THEN
        // No effect. Copy the right node over us.

        TlCopyMemory (
            node, // dest
            right, // src
            SIZEOF PrsAstNode
        )
    END
END

FN (PrsOperatorF) PrsParseLessThan (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value < right^.Body.Constant.Value
    END
END

FN (PrsOperatorF) PrsParseGreaterThan (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value > right^.Body.Constant.Value
    END
END

FN (PrsOperatorF) PrsParseLtEq (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value <= right^.Body.Constant.Value
    END
END

FN (PrsOperatorF) PrsParseGtEq (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value >= right^.Body.Constant.Value
    END
END

FN (PrsOperatorF) PrsParseEquiv (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value == right^.Body.Constant.Value
    END
END

FN (PrsOperatorF) PrsParseNotEquiv (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value != right^.Body.Constant.Value
    END
END

FN (PrsOperatorF) PrsParseAnd (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value AND right^.Body.Constant.Value

        LEAVE
    END
END

FN (PrsOperatorF) PrsParseOr (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left
    right := node^.Body.Operator.Right

    IF left^.Type == AST_CONSTANT AND right^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT

        node^.Body.Constant.Value =
            left^.Body.Constant.Value OR right^.Body.Constant.Value
    END
END

// Special left-operator parse routines.

FN (PrsOperatorF) PrsParseAddrOf (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    // Parse an addr-of operation. This just sets the operation type to
    // TOKEN_ADDROF, to distinguish it from a bitwise AND.

    node^.Token.Subtype = TOKEN_ADDROF
END

FN (PrsOperatorF) PrsParseInverse (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left

    IF left^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT
        node^.Body.Constant.Value = -left^.Body.Constant.Value

        LEAVE
    END

    // Parse an inverse operation. This just sets the operation type to
    // TOKEN_INVERSE, to distinguish it from a subtraction.

    node^.Token.Subtype = TOKEN_INVERSE
END

FN (PrsOperatorF) PrsParseNot (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left

    IF left^.Type == AST_OPERATOR AND left^.Token.Subtype == TOKEN_NOT THEN
        // Get rid of the redundant NOTs by copying the left side of our left
        // side over the top of us.

        TlCopyMemory (
            node, // dest
            left^.Body.Operator.Left, // src
            SIZEOF PrsAstNode, // sz
        )

        LEAVE
    END

    IF left^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT
        node^.Body.Constant.Value = NOT left^.Body.Constant.Value
    END
END

FN (PrsOperatorF) PrsParseBitNot (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    left := node^.Body.Operator.Left

    IF left^.Type == AST_OPERATOR AND left^.Token.Subtype == TOKEN_BITNOT THEN
        // Get rid of the redundant NOTs by copying the left side of our left
        // side over the top of us.

        TlCopyMemory (
            node, // dest
            left^.Body.Operator.Left, // src
            SIZEOF PrsAstNode, // sz
        )

        LEAVE
    END

    IF left^.Type == AST_CONSTANT THEN
        // We can roll this into a constant.

        node^.Type = AST_CONSTANT
        node^.Body.Constant.Value = ~left^.Body.Constant.Value
    END
END

FN (PrsOperatorF) PrsParseCast (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    // Parse a cast. This takes the form CAST [expression] TO [type].

    node^.Body.Operator.Left = PrsExpression ( 0 )

    token : LexToken

    IF NOT LexMatchToken (
        &token, // token
        TOKEN_OTHER, // type
        TOKEN_TO, // subtype
    ) THEN
        LexTokenError ( &token, "Expected TO.", 0, 0, 0 )
    END

    type := PrsCreateType ()

    PrsType (
        type, // type
        0, // depth
    )

    // The type goes in the operator-specific field.

    node^.Body.Operator.OperatorSpecific = type
END

FN (PrsOperatorF) PrsParseSizeOfValue (
    IN operator : ^VOID,
    IN node : ^PrsAstNode,
)

    // We have to figure out the size of the type of the value, and convert our
    // node to a constant node containing this size.

    TlInternalError ( "TODO PrsParseSizeOfValue", 0, 0, 0 )
END

// Declarator parse routines.

FN PrsCreateNamedType (
    IN token : ^LexToken,
) : ^LexSymbol

    // Common part of creating a named type, such as an ENUM, a TYPE, an FNPTR,
    // etc.

    symbol := CAST token^.Payload TO ^LexSymbol

    IF token^.Subtype == TOKEN_IDENTIFIER_FOUND THEN
        // We must be overriding a forward-declared type, otherwise this is a no
        // go.

        IF symbol^.Type != SYM_FORWARD_TYPE THEN
            LexTokenError ( token, "Identifier already in use", 0, 0, 0 )
        END
    END

    symbol^.Type = SYM_TYPE

    RETURN symbol
END

FN (PrsDeclaratorF) PrsParseEnum () : ^LexSymbol

    // Parse an ENUM declaration.

    nametoken : LexToken

    IF NOT LexMatchToken (
        &nametoken, // token
        TOKEN_IDENTIFIER, // type
        0, // subtype
    ) THEN
        LexTokenError ( &nametoken, "Expected an identifier", 0, 0, 0 )
    END

    symbol := PrsCreateNamedType ( &nametoken )

    colontoken : LexToken

    IF NOT LexMatchToken (
        &colontoken, // token
        TOKEN_COLON, // type
        0, // subtype
    ) THEN
        LexTokenError ( &colontoken, "Expected a type", 0, 0, 0 )
    END

    type := PrsCreateType ()

    PrsType (
        type, // type
        0, // depth
    )

    symbol^.SemanticType = type

    // Parse the list of constant names.
    // These are of the form:
    //
    // NAME
    // NAME = NewPosition

    IF LexMatchToken (
        NULLPTR, // token
        TOKEN_TERMINATOR, // type
        TOKEN_END, // subtype
    ) THEN
        // Empty list, we're done.

        RETURN symbol
    END

    token : LexToken

    value : TlMachineWord = 0

    WHILE TRUE DO
        IF NOT LexMatchToken (
            &token, // token
            TOKEN_IDENTIFIER, // type
            0, // subtype
        ) THEN
            LexTokenError ( &token, "Expected an identifier", 0, 0, 0)
        END

        IF token.Subtype == TOKEN_IDENTIFIER_FOUND THEN
            LexTokenError ( &token, "Identifier already in use", 0, 0, 0 )
        END

        constsymbol := CAST token.Payload TO ^LexSymbol

        constsymbol^.Type = SYM_CONSTANT
        constsymbol^.Value = value

        IF LexMatchToken (
            &token, // token
            TOKEN_ASSIGN, // type
            TOKEN_EQUALS, // subtype
        ) THEN
            // Set a new position for the constant values.

            newposnode := PrsExpression ( 0 )

            IF newposnode^.Type != AST_CONSTANT THEN
                LexTokenError ( &newposnode^.Token,
                    "Expected a constant value", 0, 0, 0 )
            END

            value = newposnode^.Body.Constant.Value
            constsymbol^.Value = value
        END

        value += 1

        IF LexMatchToken (
            &token, // token
            TOKEN_TERMINATOR, // type
            TOKEN_END, // subtype
        ) THEN
            // Done with the constant list.

            BREAK
        END

        IF NOT LexMatchToken (
            &token, // token
            TOKEN_COMMA, // type
            0, // subtype
        ) THEN
            // Bad.

            LexTokenError ( &token,
                "Expected a comma or END", 0, 0, 0 )
        END

        IF LexMatchToken (
            &token, // token
            TOKEN_TERMINATOR, // type
            TOKEN_END, // subtype
        ) THEN
            // Done with the constant list. This isn't redundant, it's to
            // allow the , END case.

            BREAK
        END
    END

    RETURN symbol
END

FN PrsParseFnSignature (
    IN flags : ULONG,
    IN fnptr : UBYTE,
    OUT outsymbol : ^^LexSymbol,
) : ^LexSemanticType

    // Parse a function signature and return a type structure for it.

    // A Jackal function signature takes one of the following forms:
    //
    // (FNPTR) NAME (IN/OUT ARG : TYPE, ...)
    // NAME (IN/OUT ARG : TYPE, ...)

    fnptrtype : ^LexSemanticType = NULLPTR

    IF LexMatchToken (
        NULLPTR, // token
        TOKEN_OPER, // type
        TOKEN_LPAREN, // subtype
    ) THEN
        // An FNPTR name is specified. Collect it.

        IF fnptr THEN
            LexTokenError ( &fnptrtoken, "FNPTR not allowed on an FNPTR", 0, 0, 0 )
        END

        fnptrtoken : LexToken

        IF NOT LexMatchToken (
            &fnptrtoken, // token
            TOKEN_IDENTIFIER, // type
            0, // subtype
        ) THEN
            LexTokenError ( &fnptrtoken, "Expected an identifier", 0, 0, 0 )
        END

        IF fnptrtoken.Subtype == TOKEN_IDENTIFIER_NEW THEN
            LexTokenError ( &fnptrtoken, "Undeclared identifier", 0, 0, 0 )
        END

        symbol := CAST fnptrtoken.Payload TO ^LexSymbol

        IF symbol^.Type != SYM_TYPE THEN
            LexTokenError ( &fnptrtoken, "Symbol isn't a type", 0, 0, 0 )
        END

        fnptrtype = symbol^.SemanticType

        IF fnptrtype^.Subtype != TYPE_POINTER THEN
            LexTokenError ( &fnptrtoken, "Type isn't a function pointer", 0, 0, 0 )
        END

        fnptrtype = fnptrtype^.Body.Pointer.Base

        IF fnptrtype^.Subtype != TYPE_FUNCTION THEN
            LexTokenError ( &fnptrtoken, "Type isn't a function pointer", 0, 0, 0 )
        END

        IF NOT LexMatchToken (
            &fnptrtoken, // token
            TOKEN_RPAREN, // type
            0, // subtype
        ) THEN
            LexTokenError ( &fnptrtoken, "Expected a right parenthesis.", 0, 0, 0 )
        END
    END

    // Collect the name.

    nametoken : LexToken

    IF NOT LexMatchToken (
        &nametoken, // token
        TOKEN_IDENTIFIER, // type
        0, // subtype
    ) THEN
        LexTokenError ( &nametoken, "Expected an identifier", 0, 0, 0 )
    END

    symbol := CAST nametoken.Payload TO ^LexSymbol

    IF fnptr THEN
        PrsCreateNamedType (
            &nametoken, // token
        )
    END

    // We'll verify stuff about the name token after we've fully assembled the
    // type.

    parentoken : LexToken

    IF NOT LexMatchToken (
        &parentoken, // token
        TOKEN_OPER, // type
        TOKEN_LPAREN, // subtype
    ) THEN
        LexTokenError ( &parentoken, "Expected a left parenthesis", 0, 0, 0 )
    END

    type := PrsCreateType ()

    type^.Subtype = TYPE_FUNCTION

    // We have to create a scope atop the global scope to contain the function
    // arguments. This scope will also be used as the function scope.

    oldscope := LexEnterScope (
        NULLPTR, // scope
    )

    type^.Body.Function.ArgListSymbolTable = LexCurrentScope
    type^.Body.Function.ArgListHead = NULLPTR
    type^.Body.Function.ReturnType = NULLPTR
    type^.Body.Function.FnPtrType = fnptrtype
    type^.Body.Function.IsVarArg = FALSE

    argtail : ^LexFunctionArgument = NULLPTR

    // Parse the list of arguments.
    // These are of the form:
    //
    // IN NAME : TYPE
    // OUT NAME : TYPE

    IF NOT LexMatchToken (
        NULLPTR, // token
        TOKEN_RPAREN, // type
        0, // subtype
    ) THEN
        WHILE TRUE DO
            arg : ^LexFunctionArgument

            status := TlBumpAlloc (
                SIZEOF LexFunctionArgument, // bytes
                &arg, // OUT ptr
            )

            IF status THEN
                TlInternalError ( "Failed to allocate arg", 0, 0, 0 )
            END

            checktoken : LexToken
            argtoken : LexToken

            LexGetToken ( &checktoken )

            IF checktoken.Type != TOKEN_ARGSPEC THEN
                LexTokenError ( &checktoken,
                    "Expected an argument specifier IN/OUT", 0, 0, 0 )
            END

            IF checktoken.Subtype == TOKEN_IN THEN
                arg^.InOut = ARG_IN
            ELSEIF checktoken.Subtype == TOKEN_OUT THEN
                arg^.InOut = ARG_OUT
            ELSEIF checktoken.Subtype == TOKEN_VARARG THEN
                type^.Body.Function.IsVarArg = TRUE

                IF NOT fnptr THEN
                    // The next two identifier tokens are the name of the vararg
                    // array and the count respectively. We have to collect
                    // those and set them up.

                    varargtoken : LexToken

                    IF NOT LexMatchToken (
                        &varargtoken, // token
                        TOKEN_IDENTIFIER, // type
                        0, // subtype
                    ) THEN
                        LexTokenError ( &varargtoken,
                            "Expected identifier", 0, 0, 0 )
                    END

                    IF varargtoken.Subtype == TOKEN_IDENTIFIER_FOUND THEN
                        LexTokenError ( &varargtoken,
                            "Identifier already in use", 0, 0, 0 )
                    END

                    varargtablesymbol := CAST varargtoken.Payload TO ^LexSymbol

                    varargtablesymbol^.Type = SYM_VAR
                    varargtablesymbol^.Flags = 0

                    type^.Body.Function.VarArgTable = varargtablesymbol

                    // The type of the vararg table is boundless array of
                    // pointer to void. Slap that together ugly-ly.

                    varargtabletype := PrsCreateType ()

                    varargtabletype^.Subtype = TYPE_ARRAY
                    varargtabletype^.Body.Array.HasBound = FALSE

                    ptrtype := PrsCreateType ()

                    ptrtype^.Subtype = TYPE_POINTER
                    varargtabletype^.Body.Array.Base = ptrtype

                    voidtype := PrsCreateType ()

                    voidtype^.Subtype = TYPE_PRIMITIVE
                    voidtype^.Body.Primitive.Type = PRIM_TYPE_VOID

                    ptrtype^.Body.Pointer.Base = voidtype

                    varargtablesymbol^.SemanticType = varargtabletype

                    // Now yoink the count.

                    IF NOT LexMatchToken (
                        &varargtoken, // token
                        TOKEN_IDENTIFIER, // type
                        0, // subtype
                    ) THEN
                        LexTokenError ( &varargtoken,
                            "Expected identifier", 0, 0, 0 )
                    END

                    IF varargtoken.Subtype == TOKEN_IDENTIFIER_FOUND THEN
                        LexTokenError ( &varargtoken,
                            "Identifier already in use", 0, 0, 0 )
                    END

                    varargcountsymbol := CAST varargtoken.Payload TO ^LexSymbol

                    varargcountsymbol^.Type = SYM_VAR
                    varargcountsymbol^.Flags = 0

                    type^.Body.Function.VarArgCount = varargcountsymbol

                    // The type of the vararg count is ULONG.

                    varargcounttype := PrsCreateType ()

                    varargcounttype^.Subtype = TYPE_PRIMITIVE
                    varargcounttype^.Body.Primitive.Type = PRIM_TYPE_ULONG

                    varargcountsymbol^.SemanticType = varargcounttype
                END

                // No more arguments are allowed after the vararg specifier.

                IF NOT LexMatchToken (
                    &checktoken, // token
                    TOKEN_RPAREN, // type
                    0, // subtype
                ) THEN
                    LexTokenError ( &checktoken,
                        "Expected right parenthesis", 0, 0, 0 )
                END

                BREAK
            END

            arg^.Next = NULLPTR

            IF NOT argtail THEN
                type^.Body.Function.ArgListHead = arg
            ELSE
                argtail^.Next = arg
            END

            argtail = arg

            LexGetToken ( &argtoken )

            IF argtoken.Type != TOKEN_IDENTIFIER THEN
                LexTokenError ( &argtoken, "Expected an identifier", 0, 0, 0)
            END

            IF argtoken.Subtype == TOKEN_IDENTIFIER_FOUND THEN
                LexTokenError ( &argtoken, "Identifier already in use", 0, 0, 0 )
            END

            argsymbol := CAST argtoken.Payload TO ^LexSymbol

            argsymbol^.Type = SYM_VAR
            argsymbol^.Flags = 0

            arg^.Symbol = argsymbol

            IF NOT LexMatchToken (
                &checktoken, // token
                TOKEN_COLON, // type
                0, // subtype
            ) THEN
                LexTokenError ( &checktoken, "Expected a type", 0, 0, 0 )
            END

            argsymbol^.SemanticType = PrsCreateType ()

            PrsType (
                argsymbol^.SemanticType, // type
                0, // depth
            )

            IF LexMatchToken (
                &checktoken, // token
                TOKEN_RPAREN, // type
                0, // subtype
            ) THEN
                // Done with the argument list.

                BREAK
            END

            IF NOT LexMatchToken (
                &checktoken, // token
                TOKEN_COMMA, // type
                0, // subtype
            ) THEN
                // Bad.

                LexTokenError ( &checktoken,
                    "Expected a comma or right parenthesis", 0, 0, 0 )
            END

            IF LexMatchToken (
                &checktoken, // token
                TOKEN_RPAREN, // type
                0, // subtype
            ) THEN
                // Done with the argument list. This isn't redundant, it's to
                // allow the , ) case.

                BREAK
            END
        END
    END

    IF fnptr OR flags & VAR_FLAG_EXTERN THEN
        // There's no body, so reset the scope now, or the lookahead might
        // mistakenly pull a symbol into our scope. This is kind of hacky.

        LexResetScope ( oldscope )
    END

    IF LexMatchToken (
        NULLPTR, // token
        TOKEN_COLON, // type
        0, // subtype
    ) THEN
        // There's a return type!

        returntype := PrsCreateType ()

        PrsType (
            returntype, // type
            0, // depth
        )

        type^.Body.Function.ReturnType = returntype
    END

    IF NOT fnptr AND (flags & VAR_FLAG_EXTERN == 0) THEN
        // There's a body, so only reset the scope now. We waited until after we
        // looked for the colon because otherwise lookahead might cause strange
        // symbol scoping. This is kind of hacky.

        LexResetScope ( oldscope )
    END

    IF fnptrtype THEN
        IF NOT PrsCheckType (
            type, // type1
            fnptrtype, // type2
        ) THEN
            LexTokenError ( &nametoken,
                "Function signature doesn't match associated FNPTR", 0, 0, 0 )
        END
    END

    IF NOT fnptr THEN
        // Now that we have the type, do the found-symbol processing.

        PrsFoundSymbol (
            &nametoken, // token
            symbol, // symbol
            flags, // flags
            TRUE, // global
            type, // newtype
        )
    END

    outsymbol^ = symbol

    RETURN type
END

FN PrsParseFnDeclaration (
    IN flags : ULONG,
) : ^LexSymbol

    // Parse a function declaration. If the flags specify EXTERN, there is no
    // body.

    symbol : ^LexSymbol

    type := PrsParseFnSignature (
        flags, // flags
        FALSE, // fnptr
        &symbol, // OUT symbol
    )

    IF flags & VAR_FLAG_EXTERN THEN
        RETURN symbol
    END

    // Collect the body of the function.

    // First resume the argument scope.

    oldscope := LexEnterScope (
        type^.Body.Function.ArgListSymbolTable, // scope
    )

    TlInsertDynamicBuffer (
        &PrsBlockStack, // array
        BLOCK_PLAIN_BODY, // byte
    )

    PrsCurrentFunction = type

    terminator : LexTokenSubtype

    type^.Body.Function.BodyBlock = PrsParseBlock (
        &terminator, // OUT terminator
    )

    PrsCurrentFunction = NULLPTR

    TlPopDynamicBuffer ( &PrsBlockStack )

    LexResetScope ( oldscope )

    RETURN symbol
END

FN (PrsDeclaratorF) PrsParseFn () : ^LexSymbol

    // Parse a function declaration.

    RETURN PrsParseFnDeclaration (
        VAR_FLAG_PUBLIC, // flags
    )
END

FN (PrsDeclaratorF) PrsParseFnPtr () : ^LexSymbol

    // Parse a function pointer named type declaration.

    symbol : ^LexSymbol

    type := PrsParseFnSignature (
        0, // flags
        TRUE, // fnptr
        &symbol, // OUT symbol
    )

    // Wrap a pointer type around the given type.

    ptrtype := PrsCreateType ()

    ptrtype^.Subtype = TYPE_POINTER
    ptrtype^.Body.Pointer.Base = type

    symbol^.SemanticType = ptrtype

    RETURN symbol
END

FN (PrsDeclaratorF) PrsParseStruct () : ^LexSymbol

    // Parse a STRUCT declaration.
    // XXX remember bit fields!
    // XXX remember that non-pointer references to undeclared STRUCTs are
    //     absolutely forbidden! may require a new argument on PrsType
    // XXX remember that we want to calculate the size of the struct and its
    //     field offsets right now.
    // XXX remember that it might be possible to use the same type structure as
    //     unions because we can have each field be defined only by offset and
    //     type, and in a union the offsets would just all be zero. we can
    //     also probably share most of the parsing logic between structs and
    //     unions.
    // XXX remember that we can probably go back and have types contain their
    //     size where applicable. where not applicable the size should be a
    //     magical value like -1 indicating that the type is not directly
    //     assignable (which means it isn't legal in a struct and union).

    TlInternalError ( "TODO PrsParseStruct", 0, 0, 0 )
END

FN (PrsDeclaratorF) PrsParseUnion () : ^LexSymbol

    // Parse a UNION declaration.

    TlInternalError ( "TODO PrsParseUnion", 0, 0, 0 )
END

FN (PrsDeclaratorF) PrsParseType () : ^LexSymbol

    // Parse a TYPE declaration.

    nametoken : LexToken

    IF NOT LexMatchToken (
        &nametoken, // token
        TOKEN_IDENTIFIER, // type
        0, // subtype
    ) THEN
        LexTokenError ( &nametoken, "Expected an identifier", 0, 0, 0 )
    END

    symbol := PrsCreateNamedType ( &nametoken )

    colontoken : LexToken

    IF NOT LexMatchToken (
        &colontoken, // token
        TOKEN_COLON, // type
        0, // subtype
    ) THEN
        LexTokenError ( &colontoken, "Expected a type", 0, 0, 0 )
    END

    type := PrsCreateType ()

    PrsType (
        type, // type
        0, // depth
    )

    symbol^.SemanticType = type

    RETURN symbol
END

FN PrsParseStorageClassSpecifier (
    IN flags : ULONG,
) : ^LexSymbol

    // Parse any of the storage class specifiers (EXTERN, PUBLIC, etc)

    symbol : ^LexSymbol

    IF LexMatchToken (
        NULLPTR, // token
        TOKEN_DECL, // type
        TOKEN_FN, // subtype
    ) THEN
        symbol = PrsParseFnDeclaration (
            flags, // flags
        )
    ELSE
        token : LexToken

        IF NOT LexMatchToken (
            &token, // token
            TOKEN_IDENTIFIER, // type
            0, // subtype
        ) THEN
            LexTokenError ( &token, "Expected an identifier", 0, 0, 0 )
        END

        colontoken : LexToken

        IF NOT LexMatchToken (
            &colontoken, // token
            TOKEN_COLON, // type
            0, // subtype
        ) THEN
            LexTokenError ( &colontoken,
                "Expected a colon (indicating a declaration).", 0, 0, 0 )
        END

        symbol = PrsVariableDeclaration (
            &token, // token
            flags, // flags
            TRUE, // global
        )
    END

    RETURN symbol
END

FN (PrsDeclaratorF) PrsParseExtern () : ^LexSymbol

    // Parse an EXTERN declaration.

    RETURN PrsParseStorageClassSpecifier (
        VAR_FLAG_EXTERN, // flags
    )
END

FN (PrsDeclaratorF) PrsParsePublic () : ^LexSymbol

    // Parse a PUBLIC declaration.

    RETURN PrsParseStorageClassSpecifier (
        VAR_FLAG_PUBLIC, // flags
    )
END

FN (PrsDeclaratorF) PrsParseExport () : ^LexSymbol

    // Parse an EXPORT declaration.

    RETURN PrsParseStorageClassSpecifier (
        VAR_FLAG_EXPORT, // flags
    )
END

FN (PrsDeclaratorF) PrsParsePrivate () : ^LexSymbol

    // Parse a PRIVATE declaration.

    RETURN PrsParseStorageClassSpecifier (
        0, // flags
    )
END

// Statement parse routines.

FN (PrsStatementF) PrsParseBegin ()

    // Parse a BEGIN block. Just creates a scoping block.

    TlInternalError ( "TODO PrsParseBegin", 0, 0, 0 )
END

FN (PrsStatementF) PrsParseBreak ()

    // Parse a BREAK statement.

    TlInternalError ( "TODO PrsParseBreak", 0, 0, 0 )
END

FN (PrsStatementF) PrsParseContinue ()

    // Parse a CONTINUE statement.

    TlInternalError ( "TODO PrsParseContinue", 0, 0, 0 )
END

FN (PrsStatementF) PrsParseGoTo ()

    // Parse a GOTO statement.

    TlInternalError ( "TODO PrsParseGoTo", 0, 0, 0 )
END

FN (PrsStatementF) PrsParseIf ()

    // Parse an IF statement.

    TlInternalError ( "TODO PrsParseIf", 0, 0, 0 )
END

FN (PrsStatementF) PrsParseLeave ()

    // Parse a LEAVE statement.

    TlInternalError ( "TODO PrsParseLeave", 0, 0, 0 )
END

FN (PrsStatementF) PrsParseReturn ()

    // Parse a RETURN statement.

    TlInternalError ( "TODO PrsParseReturn", 0, 0, 0 )
END

FN (PrsStatementF) PrsParseWhile ()

    // Parse a WHILE statement.

    TlInternalError ( "TODO PrsParseWhile", 0, 0, 0 )
END

FN (PrsStatementF) PrsParseLabel ()

    // Parse a label definition. Goes in the function scope.

    TlInternalError ( "TODO PrsParseLabel", 0, 0, 0 )
END

FN PrsInitialize ()

    // Initialize the parser.

    TlInitializeDynamicBuffer ( &PrsBlockStack )

    // Initialize the operators.

    PrsOperators[TOKEN_DOT].Precedence = 25
    PrsOperators[TOKEN_DOT].ParseFunc = &PrsParseCompoundTypeIndex
    PrsOperators[TOKEN_DOT].NoRightSide = TRUE

    PrsOperators[TOKEN_LBRACKET].Precedence = 25
    PrsOperators[TOKEN_LBRACKET].ParseFunc = &PrsParseArrayIndex
    PrsOperators[TOKEN_LBRACKET].NoRightSide = TRUE

    PrsOperators[TOKEN_LPAREN].Precedence = 25
    PrsOperators[TOKEN_LPAREN].ParseFunc = &PrsParseFunctionCall
    PrsOperators[TOKEN_LPAREN].NoRightSide = TRUE

    PrsOperators[TOKEN_CARET].Precedence = 25
    PrsOperators[TOKEN_CARET].NoRightSide = TRUE

    PrsOperators[TOKEN_MUL].Precedence = 20
    PrsOperators[TOKEN_MUL].ParseFunc = &PrsParseMul

    PrsOperators[TOKEN_DIVIDE].Precedence = 20
    PrsOperators[TOKEN_DIVIDE].ParseFunc = &PrsParseDivide

    PrsOperators[TOKEN_MODULO].Precedence = 20
    PrsOperators[TOKEN_MODULO].ParseFunc = &PrsParseModulo

    PrsOperators[TOKEN_PLUS].Precedence = 19
    PrsOperators[TOKEN_PLUS].ParseFunc = &PrsParsePlus

    PrsOperators[TOKEN_MINUS].Precedence = 19
    PrsOperators[TOKEN_MINUS].ParseFunc = &PrsParseMinus

    PrsOperators[TOKEN_LEFTSHIFT].Precedence = 18
    PrsOperators[TOKEN_LEFTSHIFT].ParseFunc = &PrsParseLeftShift

    PrsOperators[TOKEN_RIGHTSHIFT].Precedence = 18
    PrsOperators[TOKEN_RIGHTSHIFT].ParseFunc = &PrsParseRightShift

    PrsOperators[TOKEN_BITAND].Precedence = 17
    PrsOperators[TOKEN_BITAND].ParseFunc = &PrsParseBitAnd

    PrsOperators[TOKEN_BITXOR].Precedence = 16
    PrsOperators[TOKEN_BITXOR].ParseFunc = &PrsParseBitXor

    PrsOperators[TOKEN_BITOR].Precedence = 15
    PrsOperators[TOKEN_BITOR].ParseFunc = &PrsParseBitOr
    
    PrsOperators[TOKEN_LESSTHAN].Precedence = 14
    PrsOperators[TOKEN_LESSTHAN].ParseFunc = &PrsParseLessThan

    PrsOperators[TOKEN_GREATERTHAN].Precedence = 14
    PrsOperators[TOKEN_GREATERTHAN].ParseFunc = &PrsParseGreaterThan

    PrsOperators[TOKEN_LTEQ].Precedence = 14
    PrsOperators[TOKEN_LTEQ].ParseFunc = &PrsParseLtEq

    PrsOperators[TOKEN_GTEQ].Precedence = 14
    PrsOperators[TOKEN_GTEQ].ParseFunc = &PrsParseGtEq

    PrsOperators[TOKEN_EQUIV].Precedence = 13
    PrsOperators[TOKEN_EQUIV].ParseFunc = &PrsParseEquiv

    PrsOperators[TOKEN_NOTEQUIV].Precedence = 13
    PrsOperators[TOKEN_NOTEQUIV].ParseFunc = &PrsParseNotEquiv

    PrsOperators[TOKEN_AND].Precedence = 12
    PrsOperators[TOKEN_AND].ParseFunc = &PrsParseAnd

    PrsOperators[TOKEN_OR].Precedence = 11
    PrsOperators[TOKEN_OR].ParseFunc = &PrsParseOr

    // Initialize the left-operators.

    PrsLeftOperators[TOKEN_BITAND].Precedence = 24
    PrsLeftOperators[TOKEN_BITAND].ParseFunc = &PrsParseAddrOf

    PrsLeftOperators[TOKEN_MINUS].Precedence = 24
    PrsLeftOperators[TOKEN_MINUS].ParseFunc = &PrsParseInverse

    PrsLeftOperators[TOKEN_NOT].Precedence = 24
    PrsLeftOperators[TOKEN_NOT].ParseFunc = &PrsParseNot

    PrsLeftOperators[TOKEN_BITNOT].Precedence = 24
    PrsLeftOperators[TOKEN_BITNOT].ParseFunc = &PrsParseBitNot

    PrsLeftOperators[TOKEN_CAST].Precedence = 24
    PrsLeftOperators[TOKEN_CAST].ParseFunc = &PrsParseCast
    PrsLeftOperators[TOKEN_CAST].NoRightSide = TRUE

    PrsLeftOperators[TOKEN_SIZEOFVALUE].Precedence = 24
    PrsLeftOperators[TOKEN_SIZEOFVALUE].ParseFunc = &PrsParseSizeOfValue

    // Initialize the declarators.

    PrsDeclarators[TOKEN_ENUM].ParseFunc = &PrsParseEnum
    PrsDeclarators[TOKEN_EXTERN].ParseFunc = &PrsParseExtern
    PrsDeclarators[TOKEN_FN].ParseFunc = &PrsParseFn
    PrsDeclarators[TOKEN_FNPTR].ParseFunc = &PrsParseFnPtr
    PrsDeclarators[TOKEN_PUBLIC].ParseFunc = &PrsParsePublic
    PrsDeclarators[TOKEN_STRUCT].ParseFunc = &PrsParseStruct
    PrsDeclarators[TOKEN_TYPE].ParseFunc = &PrsParseType
    PrsDeclarators[TOKEN_UNION].ParseFunc = &PrsParseUnion
    PrsDeclarators[TOKEN_EXPORT].ParseFunc = &PrsParseExport
    PrsDeclarators[TOKEN_PRIVATE].ParseFunc = &PrsParsePrivate

    // Initialize the statements.

    PrsStatements[TOKEN_BEGIN].ParseFunc = &PrsParseBegin
    PrsStatements[TOKEN_BREAK].ParseFunc = &PrsParseBreak
    PrsStatements[TOKEN_CONTINUE].ParseFunc = &PrsParseContinue
    PrsStatements[TOKEN_GOTO].ParseFunc = &PrsParseGoTo
    PrsStatements[TOKEN_IF].ParseFunc = &PrsParseIf
    PrsStatements[TOKEN_LEAVE].ParseFunc = &PrsParseLeave
    PrsStatements[TOKEN_RETURN].ParseFunc = &PrsParseReturn
    PrsStatements[TOKEN_WHILE].ParseFunc = &PrsParseWhile
    PrsStatements[TOKEN_LABEL].ParseFunc = &PrsParseLabel
END

FN PrsProgram ()

    // Parse a program. This consists of a sequence of global declarations. We
    // also want to place these global declarations on lists so the subsequent
    // phases can use them appropriately, linked via the symbol table entry
    // given to us by the lexer.

    WHILE PrsGlobalDeclaration () DO
        // Keep going...
    END
END