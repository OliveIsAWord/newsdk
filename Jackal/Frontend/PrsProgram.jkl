//
// Parses a Jackal program and constructs an abstract syntax tree.
//

#INCLUDE "<inc>/Parser.hjk"

PUBLIC PrsGlobalListHead : ^LexSymbol = NULLPTR
PUBLIC PrsGlobalListTail : ^LexSymbol = NULLPTR

PrsCurrentBlock : ^PrsBlock = NULLPTR

CONST VAR_FLAG_EXTERN := 1
CONST VAR_FLAG_PUBLIC := 2
CONST VAR_FLAG_EXPORT := 4

FNPTR PrsOperatorF (
    IN node : ^PrsAstNode,
)

STRUCT PrsOperatorRecord
    ParseFunc : PrsOperatorF,
    Precedence : ULONG,
END

PrsLeftOperators : PrsOperatorRecord[TOKEN_SUBTYPE_MAX]
PrsOperators : PrsOperatorRecord[TOKEN_SUBTYPE_MAX]

FN PrsCreateType () : ^LexSemanticType

    // Create a type.

    type : ^LexSemanticType

    status := TlBumpAlloc (
        SIZEOF LexSemanticType, // bytes
        &type, // OUT ptr
    )

    IF status THEN
        TlInternalError ( "Failed to create type", 0, 0, 0 )
    END

    RETURN type
END

FN PrsCreateAstNode (
    IN type : PrsAstType,
    IN token : ^LexToken,
) : ^PrsAstNode

    // Create an AST node.

    node : ^PrsAstNode

    status := TlBumpAlloc (
        SIZEOF PrsAstNode, // bytes
        &node, // OUT ptr
    )

    IF status THEN
        TlInternalError ( "Failed to create AST node", 0, 0, 0 )
    END

    node^.Type = type

    LexCopyToken (
        &node^.Token, // dest
        token, // src
    )

    RETURN node
END

FN PrsCreateIdentifierNode (
    IN token : ^LexToken,
) : ^PrsAstNode

    // Create an identifier node.
    // XXX Turn this into a macro when those work.

    RETURN PrsCreateAstNode (
        AST_IDENTIFIER, // type
        token, // token
    )
END

FN PrsInsertNodeIntoBlock (
    IN block : ^PrsBlock,
    IN node : ^PrsAstNode,
)

    // Insert the node into the given block.
    // XXX Turn this into a macro when those work.
    // XXX Better yet, just use the circular list macros when we have those.

    IF NOT block^.StatementListTail THEN
        block^.StatementListHead = node
    ELSE
        block^.StatementListTail^.Next = node
    END

    block^.StatementListTail = node
END

FN PrsPrintType (
    IN type : ^LexSemanticType,
)

    // Debug function that recursively prints a type.

    TlPrintString ( "Subtype: " )
    TlPrintNumber ( type^.Subtype )
    TlPrintString ( "\n" )

    IF type^.Subtype == TYPE_PRIMITIVE THEN
        TlPrintString ( "Primitive type: " )
        TlPrintNumber ( type^.Body.Primitive.Type )
        TlPrintString ( "\n" )
    ELSEIF type^.Subtype == TYPE_NAMED THEN
        TlPrintString ( "Type name: " )
        TlPrintString ( type^.Body.Named.Symbol^.Name )
        TlPrintString ( "\n" )
    ELSEIF type^.Subtype == TYPE_POINTER THEN
        TlPrintString ( "Pointer to:\n" )
        PrsPrintType ( type^.Body.Pointer.Base )
    ELSEIF type^.Subtype == TYPE_ARRAY THEN
        TlPrintString ( "Array of:\n" )
        PrsPrintType ( type^.Body.Array.Base )
    END
END

FN PrsAtom (
    IN minprecedence : ULONG,
) : ^PrsAstNode

    // Parse an atom. This is an "atomic" part of an expression.

    token : LexToken

    IF LexMatchToken (
        &token, // token
        TOKEN_OPER, // type
        0, // subtype
    ) THEN
        // This must be a left-operator. Look it up in the table.


    END
END

FN PrsExpression (
    IN minprecedence : ULONG,
) : ^PrsAstNode

    // Parse a expression. Pays attention to precedence.

    atomnode := PrsAtom ( minprecedence )
END

FN PrsType (
    IN type : ^LexSemanticType,
    IN depth : UBYTE,
)

    // Parse the type into the provided type structure.

    typetoken : LexToken

    // First check if it's a primitive type.

    IF LexMatchToken (
        &typetoken, // token
        TOKEN_PTYPE, // type
        0, // subtype
    ) THEN
        // It's a primitive type, that was easy!

        type^.Subtype = TYPE_PRIMITIVE
        type^.Body.Primitive.Type = typetoken.TypeContext

    ELSEIF LexMatchToken (
        &typetoken, // token
        TOKEN_OPER, // type
        TOKEN_CARET, // subtype
    ) THEN
        // It's a pointer type! Allocate a base type.

        basetype := PrsCreateType ()

        // Parse the base type into it.

        PrsType (
            basetype, // type
            depth + 1, // depth
        )

        type^.Subtype = TYPE_POINTER
        type^.Body.Pointer.Base = basetype

    ELSEIF LexMatchToken (
        &typetoken, // token
        TOKEN_IDENTIFIER, // type
        0, // subtype
    ) THEN
        // It's a named type!

        symbol := CAST typetoken.Payload TO ^LexSymbol

        IF typetoken.Subtype == TOKEN_IDENTIFIER_FOUND THEN
            // This symbol has already appeared, so verify that it's a type.

            IF symbol^.Type != SYM_TYPE AND
                symbol^.Type != SYM_FORWARD_TYPE THEN

                // Nope, that's bad :(

                LexTokenError ( &typetoken, "Symbol isn't a type", 0, 0, 0 )
            END
        ELSE
            // This is a new type, so forward declare it for now.

            symbol^.Type = SYM_FORWARD_TYPE
        END

        type^.Subtype = TYPE_NAMED
        type^.Body.Named.Symbol = symbol

    ELSE
        // Type didn't match with anything we expected.

        LexTokenError ( &typetoken,
            "Type must be primitive, pointer, or named.", 0, 0, 0 )
    END

    IF depth THEN
        // We don't collect the array components if the type is nested at all.

        LEAVE
    END

    // Collect array components, if any exist. This has to be done in a manner
    // such that the type structure we were passed in becomes the head of a
    // chain of array types, where the tail of the chain contains the original
    // type.

    IF NOT LexMatchToken (
        NULLPTR, // token
        TOKEN_OPER, // type
        TOKEN_LBRACKET, // subtype
    ) THEN
        // No array components.

        LEAVE
    END

    dimensions := 1
    boundless := FALSE

    // There are array components, so firstly we need to allocate a base type
    // and move whatever we created for this type into it.

    basetype := PrsCreateType ()

    TlCopyMemory (
        basetype, // dest
        type, // src
        SIZEOF LexSemanticType, // sz
    )

    arraytype := type

    arraytail : ^LexSemanticType = NULLPTR

    WHILE TRUE DO
        arraytype^.Subtype = TYPE_ARRAY

        IF arraytail THEN
            arraytail^.Body.Array.Base = arraytype
        END

        arraytail = arraytype

        IF LexMatchToken (
            NULLPTR, // token
            TOKEN_RBRACKET, // type
            0, // subtype
        ) THEN
            // The array is boundless.

            IF dimensions > 1 THEN
                LexTokenError ( &typetoken,
                    "Boundless arrays can't be multidimensional.", 0, 0, 0 )
            END

            boundless = TRUE

            arraytype^.Body.Array.Bound = NULLPTR
        ELSE
            // arraytype^.Body.Array.Bound = PrsExpression ( 0 )
            // TODO uncomment above, and test multidimensional array type parses
            //      correctly

            rbrackettoken : LexToken

            IF NOT LexMatchToken (
                &rbrackettoken, // token
                TOKEN_RBRACKET, // type
                0, // subtype
            ) THEN
                LexTokenError ( &rbrackettoken,
                    "Array type must be terminated by right bracket.", 0, 0, 0 )
            END
        END

        IF NOT LexMatchToken (
            NULLPTR, // token
            TOKEN_OPER, // type
            TOKEN_LBRACKET, // subtype
        ) THEN
            // No more array components.

            BREAK
        END

        IF boundless THEN
            LexTokenError ( &typetoken,
                "Boundless arrays can't be multidimensional.", 0, 0, 0 )
        END

        dimensions += 1

        arraytype = PrsCreateType ()
    END

    arraytail^.Body.Array.Base = basetype
END

FN PrsFoundSymbol (
    IN token : ^LexToken,
    IN symbol : ^LexSymbol,
    IN type : LexSymbolType,
    IN flags : ULONG,
    IN global : UBYTE,
)

    // A symbol is being declared. Check for override and make sure stuff is
    // legal and whatever. This is its own function because it is common between
    // function and variable declarations.

    IF token^.Subtype == TOKEN_IDENTIFIER_FOUND THEN
        // This symbol has already appeared, so we want to find out if this is
        // a valid override.

        IF symbol^.Type != type THEN
            // This symbol isn't the expected type.

            LexTokenError ( token, "Symbol name already in use.", 0, 0, 0 )
        END

        IF flags & VAR_FLAG_EXTERN THEN
            // This is an attempt at an extern declaration. Externs can't
            // override anything.

            LexTokenError ( token, "Symbol already declared.", 0, 0, 0 )
        END

        IF NOT (symbol^.Flags & VAR_FLAG_EXTERN) THEN
            // Can only override externs.

            LexTokenError ( token, "Symbol already declared.", 0, 0, 0 )
        END

        IF NOT global THEN
            // Can't override externs from local scope.

            LexTokenError ( token,
                "Can't override extern from local scope.", 0, 0, 0 )
        END
    ELSE
        // Initialize the symbol.

        symbol^.Type = type

        IF global THEN
            // Add it to the list of globals, at the tail.

            tail := PrsGlobalListTail

            symbol^.Next = NULLPTR
            symbol^.Prev = tail

            IF tail THEN
                tail^.Next = symbol
            ELSE
                PrsGlobalListHead = symbol
            END

            PrsGlobalListTail = symbol
        END
    END

    symbol^.Flags = flags

    // We should see if there's a pending section override from the lexer, and
    // do it now if so.

    IF LexNextSymbolSection THEN
        // There was a single-symbol section override via SECTION directive.

        symbol^.Section = LexNextSymbolSection
        LexNextSymbolSection = NULLPTR
    ELSE
        symbol^.Section = LexCurrentSection
    END
END

FN PrsVariableDeclaration (
    IN token : ^LexToken,
    IN flags : ULONG,
    IN global : UBYTE,
)

    // Parse a variable declaration of one of the following forms:
    //
    //  name : type = initial
    //  name : = initial
    //  name : type
    //
    // The colon has already been consumed (that's how the caller knew this is a
    // declaration and not an assignment).
    // Non-extern declarations may override extern declarations.
    // Extern declarations must not have an initial value, just a name and type.
    // The passed in token contains the relevant symbol already.
    // For local declarations, we should generate an AST assignment node.
    // For globals, we should just associate the initial value with the symbol,
    // and add the symbol to a list of globals for the whole program. The
    // initial value AST node is interpreted in the next phase of the compiler.

    symbol := CAST token^.Payload TO ^LexSymbol

    PrsFoundSymbol (
        token, // token
        symbol, // symbol
        SYM_VAR, // type
        flags, // flags
        global, // global
    )

    // Now we have to check if the next token is an equals sign. If so, the type
    // is inferred. Otherwise, we have to put the token back and parse the type.

    IF NOT LexMatchToken (
        NULLPTR, // token
        TOKEN_ASSIGN, // type
        TOKEN_EQUALS, // subtype
    ) THEN
        // The type is explicit. Parse that now.

        PrsType (
            &symbol^.SemanticType, // type
            0, // depth
        )

        PrsPrintType ( &symbol^.SemanticType )
    END

    // Parse the initial value.

    // If the type was implicit, evaluate the type of the initial value.

    IF NOT global THEN
        // Create an AST node for the assignment of the initial value.

        idnode := PrsCreateIdentifierNode ( token )

        asgnnode := PrsCreateAstNode (
            AST_ASSIGN, // type
            token, // token
        )

        asgnnode^.Body.Assign.Left = idnode
        // asgnnode^.Body.Assign.Right = initialnode
        // TODO uncomment above

        // We can place it directly in the statement list for the current block
        // because the existence of a block is implied by the fact this is a
        // local declaration.

        PrsInsertNodeIntoBlock (
            PrsCurrentBlock, // block
            asgnnode, // node
        )
    ELSE
        // Statically evaluate the initial value. If it can't be statically
        // evaluated, that's an error, since this is a global. Note that we
        // might still leave it as a "complex" AST node if it's a pointer to
        // some other global or something because we don't know the value of
        // that immediately.


    END
END

FN PrsGlobalDeclaration () : UBYTE

    // Parse the next global declaration. Return FALSE on EOF.

    token : LexToken

    LexGetToken ( &token )

    IF token.Type == TOKEN_EOF THEN
        RETURN FALSE
    END

    IF token.Type != TOKEN_IDENTIFIER AND token.Type != TOKEN_DECL THEN
        LexTokenError ( &token,
            "Expected identifier or declarative keyword", 0, 0, 0 )
    END

    IF token.Type == TOKEN_IDENTIFIER THEN
        // This is a non-public, non-extern variable declaration.
        // It may be overriding an extern declaration.

        colontoken : LexToken

        IF NOT LexMatchToken (
            &colontoken, // token
            TOKEN_COLON, // type
            TOKEN_SUBTYPE_ANY, // subtype
        ) THEN
            // There MUST be a colon for global declarations, otherwise it would
            // be a global assignment which makes no sense.

            LexTokenError ( &colontoken,
                "Expected a colon (indicating a declaration).", 0, 0, 0 )
        END

        PrsVariableDeclaration (
            &token, // token
            0, // flags
            TRUE, // global
        )

        RETURN TRUE
    END

    // This is a declarative keyword of some variety.

    RETURN TRUE
END

FN PrsProgram ()

    // Parse a program. This consists of a sequence of global declarations. We
    // also want to place these global declarations on lists so the subsequent
    // phases can use them appropriately, linked via the symbol table entry
    // given to us by the lexer.

    WHILE PrsGlobalDeclaration () DO
        // Keep going...
    END
END

FN (PrsOperatorF) PrsParseArrayIndex (
    IN node : ^PrsAstNode,
)

    // Parse an array index. We have to collect the index itself and the right
    // bracket.
END

FN (PrsOperatorF) PrsParseFunctionCall (
    IN node : ^PrsAstNode,
)

    // Parse a function call. We have to collect the arguments and the right
    // parenthesis.
END

FN (PrsOperatorF) PrsParsePointerRef (
    IN node : ^PrsAstNode,
)

    // Parse a pointer ref. We don't actually do anything here, the presence of
    // this routine just stops the expression parser from collecting a "right
    // side".
END

FN (PrsOperatorF) PrsParseAddrOf (
    IN node : ^PrsAstNode,
)

    // Parse an addr-of operation. This just sets the operation type to
    // TOKEN_ADDROF, to distinguish it from a bitwise AND.
END

FN (PrsOperatorF) PrsParseInverse (
    IN node : ^PrsAstNode,
)

    // Parse an inverse operation. This just sets the operation type to
    // TOKEN_INVERSE, to distinguish it from a subtraction.
END

FN (PrsOperatorF) PrsParseCast (
    IN node : ^PrsAstNode,
)

    // Parse a cast. This takes the form CAST [expression] TO [type].
END

FN PrsInitialize ()

    // Initialize the parser.

    PrsOperators[TOKEN_DOT].Precedence = 25

    PrsOperators[TOKEN_LBRACKET].Precedence = 25
    PrsOperators[TOKEN_LBRACKET].ParseFunc = &PrsParseArrayIndex

    PrsOperators[TOKEN_LPAREN].Precedence = 25
    PrsOperators[TOKEN_LPAREN].ParseFunc = &PrsParseFunctionCall

    PrsOperators[TOKEN_CARET].Precedence = 25
    PrsOperators[TOKEN_CARET].ParseFunc = &PrsParsePointerRef

    PrsOperators[TOKEN_MUL].Precedence = 20
    PrsOperators[TOKEN_DIVIDE].Precedence = 20
    PrsOperators[TOKEN_MODULO].Precedence = 20
    PrsOperators[TOKEN_PLUS].Precedence = 19
    PrsOperators[TOKEN_MINUS].Precedence = 19
    PrsOperators[TOKEN_LEFTSHIFT].Precedence = 18
    PrsOperators[TOKEN_RIGHTSHIFT].Precedence = 18
    PrsOperators[TOKEN_BITAND].Precedence = 17
    PrsOperators[TOKEN_BITXOR].Precedence = 16
    PrsOperators[TOKEN_BITOR].Precedence = 15
    PrsOperators[TOKEN_LESSTHAN].Precedence = 14
    PrsOperators[TOKEN_GREATERTHAN].Precedence = 14
    PrsOperators[TOKEN_LTEQ].Precedence = 14
    PrsOperators[TOKEN_GTEQ].Precedence = 14
    PrsOperators[TOKEN_EQUIV].Precedence = 13
    PrsOperators[TOKEN_NOTEQUIV].Precedence = 13
    PrsOperators[TOKEN_AND].Precedence = 12
    PrsOperators[TOKEN_OR].Precedence = 11

    PrsLeftOperators[TOKEN_BITAND].Precedence = 24
    PrsLeftOperators[TOKEN_BITAND].ParseFunc = &PrsParseAddrOf

    PrsLeftOperators[TOKEN_MINUS].Precedence = 24
    PrsLeftOperators[TOKEN_MINUS].ParseFunc = &PrsParseInverse

    PrsLeftOperators[TOKEN_NOT].Precedence = 24
    PrsLeftOperators[TOKEN_BITNOT].Precedence = 24

    PrsLeftOperators[TOKEN_CAST].Precedence = 24
    PrsLeftOperators[TOKEN_CAST].ParseFunc = &PrsParseCast

    PrsLeftOperators[TOKEN_SIZEOFVALUE].Precedence = 24
END