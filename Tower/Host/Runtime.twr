//
// Host-specific runtime functions.
// These are mostly just a bunch of wrapper functions, around libc for the C
// transpilation host, and around Rtl for the MINTIA host.
//

#INCLUDE "<inc>/Runtime.twh"

EXTERN FN printf (
	IN format : ^_char,
	...
) : _int

EXTERN FN exit (
	IN status : _int,
)

EXTERN FN malloc (
	IN size : ULONG,
) : ^VOID

EXTERN FN free (
	IN ptr : ^VOID,
)

EXTERN FN strcmp (
	IN s1 : ^_char,
	IN s2 : ^_char,
) : _int

EXTERN FN strncmp (
	IN s1 : ^_char,
	IN s2 : ^_char,
	IN n : ULONG,
) : _int

EXTERN FN fopen (
	IN path : ^_char,
	IN mode : ^_char,
) : ^VOID

EXTERN FN fclose (
	IN stream : ^VOID,
) : ^_int

EXTERN FN fread (
	OUT ptr : ^VOID,
	IN size : ULONG,
	IN nitems : ULONG,
	IN stream : ^VOID,
) : ULONG

EXTERN FN fwrite (
	IN ptr : ^VOID,
	IN size : ULONG,
	IN nitems : ULONG,
	IN stream : ^VOID,
) : ULONG



FN TwrPrintString (
	IN str : ^UBYTE,
)

	printf (
		"%s\n", // format
		str, // ...
	)
END

FN TwrInternalError (
	IN str : ^UBYTE,
	IN err1 : ULONG,
	IN err2 : ULONG,
	IN err3 : ULONG,
)

	printf (
		"Internal compiler error: %s (%d %d %d)\n", // format
		str, // ...
		err1,
		err2,
		err3,
	)

	exit ( 1 )
END

FN TwrUserError (
	IN str : ^UBYTE,
	IN err1 : ULONG,
	IN err2 : ULONG,
	IN err3 : ULONG,
)

	printf (
		"User error: %s (%d %d %d)\n", // format
		str, // ...
		err1,
		err2,
		err3,
	)

	exit ( 1 )
END

FN TwrAlloc (
	IN bytes : ULONG,
	OUT ptr : ^^VOID,
) : TwrStatus

	ptr^ = malloc ( bytes )

	IF ptr^ == 0 THEN
		RETURN TWR_NO_MEMORY
	END

	RETURN TWR_SUCCESS
END

FN TwrFree (
	IN ptr : ^VOID,
)

	free ( ptr )
END

FN TwrStringCompare (
	IN str1 : ^UBYTE,
	IN str2 : ^UBYTE,
) : ULONG

	RETURN strcmp ( str1, str2 )
END

FN TwrStringCompareCount (
	IN str1 : ^UBYTE,
	IN str2 : ^UBYTE,
	IN count : ULONG,
) : ULONG

	RETURN strncmp ( str1, str2, count )
END

FN TwrStringCopy (
	IN dest : ^UBYTE,
	IN src : ^UBYTE,
	IN bufsize : ULONG,
)
	IF NOT bufsize THEN
		LEAVE
	END

	WHILE bufsize - 1 DO
		dest^ = src^

		dest += 1
		src += 1
		bufsize -= 1

		IF src^ == 0 THEN
			BREAK
		END
	END

	dest^ = 0
END

FN TwrOpenSource (
	IN filename : ^UBYTE,
	OUT handle : ^^VOID,
) : TwrStatus

	handle^ = fopen ( filename, "r" )

	IF handle^ == 0 THEN
		RETURN TWR_COULDNT_OPEN
	END

	RETURN TWR_SUCCESS
END

FN TwrOpenDestination (
	IN filename : ^UBYTE,
	OUT handle : ^^VOID,
) : TwrStatus

	handle^ = fopen ( filename, "w" )

	IF handle^ == 0 THEN
		RETURN TWR_COULDNT_OPEN
	END

	RETURN TWR_SUCCESS
END

FN TwrReadFile (
	IN handle : ^VOID,
	IN bytes : ULONG,
	OUT buffer : ^VOID,
) : ULONG

	RETURN fread ( buffer, bytes, 1, handle )
END

FN TwrWriteFile (
	IN handle : ^VOID,
	IN bytes : ULONG,
	IN buffer : ^VOID,
) : ULONG

	RETURN fwrite ( buffer, bytes, 1, handle )
END