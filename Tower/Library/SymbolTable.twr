//
// Generic scoped symbol table implementation.
// Does not care what the "symbol" structure contains, as long as it has a
// TwrHashTableEntry as a header. This is used for both the parser and also for
// macro expansion, where a concept of "scope" is useful for macro function
// arguments and nested expansion.
//

#INCLUDE "<inc>/Runtime.twh"

FN TwrSymbolTableInitialize (
	IN symboltable : ^TwrSymbolTable,
	IN deletefunc : TwrHashTableEnumF,
) : TwrStatus

	symboltable^.PrevScope = 0
	symboltable^.DeleteRoutine = deletefunc

	RETURN TwrHashTableInitialize ( &symboltable^.HashTable )
END

FN TwrSymbolTableCreate (
	IN outerscope : ^TwrSymbolTable,
	IN deletefunc : TwrHashTableEnumF,
	OUT symboltable : ^^TwrSymbolTable,
) : TwrStatus

	status := TwrAlloc (
		SIZEOF TwrSymbolTable, // bytes
		symboltable, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = TwrSymbolTableInitialize (
		symboltable^, // symboltable
		deletefunc, // deletefunc
	)

	IF status THEN
		TwrFree ( symboltable^ )
	END

	RETURN status
END

FN TwrSymbolTableDelete (
	IN symboltable : ^TwrSymbolTable,
) : ^TwrSymbolTable

	outerscope := symboltable^.PrevScope

	TwrHashTableEnumerate (
		&symboltable^.HashTable, // hashtable
		symboltable^.DeleteRoutine, // deletefunc
	)

	TwrFree ( symboltable )

	RETURN outerscope
END

FN TwrSymbolTableLookup (
	IN symboltable : ^TwrSymbolTable,
	IN name : ^UBYTE,
) : ^TwrHashTableEntry

	WHILE symboltable DO
		entry := TwrHashTableLookup (
			&symboltable^.HashTable, // hashtable
			name, // key
		)

		IF entry THEN
			RETURN entry
		END

		symboltable = symboltable^.PrevScope
	END

	RETURN 0
END

FN TwrSymbolTableInsert (
	IN symboltable : ^TwrSymbolTable,
	IN entry : ^TwrHashTableEntry,
	IN name : ^UBYTE,
)

	TwrHashTableInsert (
		&symboltable^.HashTable, // hashtable
		entry, // entry
		name, // key
	)
END

FN TwrSymbolTableRemove (
	IN entry : ^TwrHashTableEntry,
)

	TwrHashTableRemove ( entry )
END