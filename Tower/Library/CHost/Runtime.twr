//
// Host-specific runtime functions.
// These are mostly just a bunch of wrapper functions, around libc for the C
// transpilation host, and around Rtl for the MINTIA host.
//

#INCLUDE "<inc>/Runtime.twh"
#INCLUDE "<inc>/Lexer.twh"

EXTERN FN fprintf (
	IN stream : ^VOID,
	IN format : ^_char,
	...
) : _int

EXTERN FN exit (
	IN status : _int,
)

EXTERN FN malloc (
	IN size : ULONG,
) : ^VOID

EXTERN FN free (
	IN ptr : ^VOID,
)

EXTERN FN strcmp (
	IN s1 : ^_char,
	IN s2 : ^_char,
) : _int

EXTERN FN strncmp (
	IN s1 : ^_char,
	IN s2 : ^_char,
	IN n : ULONG,
) : _int

EXTERN FN fopen (
	IN path : ^_char,
	IN mode : ^_char,
) : ^VOID

EXTERN FN fclose (
	IN stream : ^VOID,
) : ^_int

EXTERN FN fread (
	OUT ptr : ^VOID,
	IN size : ULONG,
	IN nitems : ULONG,
	IN stream : ^VOID,
) : ULONG

EXTERN FN fwrite (
	IN ptr : ^VOID,
	IN size : ULONG,
	IN nitems : ULONG,
	IN stream : ^VOID,
) : ULONG

EXTERN FN memset (
	IN ptr : ^VOID,
	IN c : _int,
	IN len : ULONG,
) : ^VOID

FN TwrFillMemoryWithByte (
	IN ptr : ^VOID,
	IN sz : ULONG,
	IN byte : UBYTE,
)

	memset (
		ptr, // ptr
		byte, // c
		sz, // len
	)
END

FN TwrErrorExit ()

	exit ( 1 )
END

EXTERN FN TwrStreamError_C (
	IN filename : ^UBYTE,
	IN linenumber : ULONG,
	IN linepos : ULONG,
	IN str : ^UBYTE,
	IN err1 : ULONG,
	IN err2 : ULONG,
	IN err3 : ULONG,
)

FN TwrStreamError (
	IN str : ^UBYTE,
	IN err1 : ULONG,
	IN err2 : ULONG,
	IN err3 : ULONG,
)
	filestream := LexStreamGetLastFileStream ()

	TwrStreamError_C (
		filestream^.FileBlock^.Name, // filename
		filestream^.Generic.LineNumber, // linenumber
		filestream^.Generic.LinePosition, // linepos
		str, // str
		err1, // err1
		err2, // err2
		err3, // err3
	)

	exit ( 1 )
END

FN TwrAlloc (
	IN bytes : ULONG,
	OUT ptr : ^^VOID,
) : TwrStatus

	ptr^ = malloc ( bytes )

	IF ptr^ == 0 THEN
		RETURN TWR_NO_MEMORY
	END

	RETURN TWR_SUCCESS
END

FN TwrFree (
	IN ptr : ^VOID,
)

	free ( ptr )
END

FN TwrStringCompare (
	IN str1 : ^UBYTE,
	IN str2 : ^UBYTE,
) : ULONG

	RETURN strcmp ( str1, str2 )
END

FN TwrStringCompareCount (
	IN str1 : ^UBYTE,
	IN str2 : ^UBYTE,
	IN count : ULONG,
) : ULONG

	RETURN strncmp ( str1, str2, count )
END

FN TwrStringCopy (
	IN dest : ^UBYTE,
	IN src : ^UBYTE,
	IN bufsize : ULONG,
)
	IF NOT bufsize THEN
		LEAVE
	END

	WHILE bufsize - 1 DO
		dest^ = src^

		dest += 1
		src += 1
		bufsize -= 1

		IF src^ == 0 THEN
			BREAK
		END
	END

	dest^ = 0
END

FN TwrOpenSource (
	IN filename : ^UBYTE,
	OUT handle : ^^VOID,
) : TwrStatus

	handle^ = fopen ( filename, "r" )

	IF handle^ == 0 THEN
		RETURN TWR_COULDNT_OPEN
	END

	RETURN TWR_SUCCESS
END

FN TwrOpenDestination (
	IN filename : ^UBYTE,
	OUT handle : ^^VOID,
) : TwrStatus

	handle^ = fopen ( filename, "w" )

	IF handle^ == 0 THEN
		RETURN TWR_COULDNT_OPEN
	END

	RETURN TWR_SUCCESS
END

FN TwrClose (
	IN handle : ^VOID,
)

	fclose ( handle )
END

FN TwrReadFile (
	IN handle : ^VOID,
	IN bytes : ULONG,
	OUT buffer : ^VOID,
) : ULONG

	// XXX make sure to check for errors on hosts where that is more
	// applicable.

	RETURN fread ( buffer, 1, bytes, handle )
END

FN TwrWriteFile (
	IN handle : ^VOID,
	IN bytes : ULONG,
	IN buffer : ^VOID,
) : ULONG

	// XXX make sure to check for errors on hosts where that is more
	// applicable.

	RETURN fwrite ( buffer, 1, bytes, handle )
END