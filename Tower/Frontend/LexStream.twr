//
// Implements stream objects for the lexer.
//

#INCLUDE "<inc>/Frontend.twh"
#INCLUDE "<inc>/Runtime.twh"
#INCLUDE "<inc>/Lexer.twh"

FN LexStreamInitialize (
	IN stream : ^LexStream,
	IN ismacro : UBYTE,
) : TwrStatus

	// Initialize a stream structure.

	stream^.Previous = 0

	stream^.Buffer = 0
	stream^.BufferSize = 0
	stream^.ValidLength = 0
	stream^.LineNumber = 1
	stream^.LinePosition = 1
	stream^.BufferPosition = 0
	stream^.IsMacro = ismacro
	stream^.LastWasNewline = FALSE

	RETURN TWR_SUCCESS
END

FN LexStreamUninitialize (
	IN stream : ^LexStream,
)

	// Generic uninitialization for any stream type.

	IF NOT stream^.IsMacro THEN
		// This is a file stream, free the buffer.
		// We don't delete the file block since it's still referenced by
		// tokens and such.

		TwrClose ( (CAST stream TO ^LexFileStream)^.FileBlock^.Handle )

		TwrFree ( stream^.Buffer )
	END
END

FN LexStreamFree (
	IN stream : ^LexStream,
)

	LexStreamUninitialize ( stream )
	TwrFree ( stream )
END

FN LexStreamPush (
	IN stream : ^LexStream,
)

	stream^.Previous = LexCurrentStream
	LexCurrentStream = stream
END

FN LexStreamPop () : ^LexStream

	oldstream := LexCurrentStream
	LexCurrentStream = oldstream^.Previous

	RETURN oldstream
END

FN LexFileStreamInitialize (
	IN filestream : ^LexFileStream,
	IN handle : ^VOID,
	IN filename : ^UBYTE,
) : TwrStatus

	// Initialize a file stream.

	status := LexStreamInitialize (
		&filestream^.Generic, // stream
		FALSE, // ismacro
	)

	IF status THEN
		RETURN status
	END

	// Allocate the file block and lex buffer.

	fileblock : ^TwrFileBlock
	buffer : ^UBYTE

	status = TwrAlloc (
		SIZEOF TwrFileBlock, // bytes
		&fileblock, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = TwrAlloc (
		LEX_BUFFER_SIZE, // bytes
		&buffer, // OUT ptr
	)

	IF status THEN
		TwrFree ( fileblock )

		RETURN status
	END

	// Initialize the file block.

	fileblock^.Handle = handle

	TwrStringCopy (
		&fileblock^.Name[0], // dest
		filename, // src
		TWR_PATH_BUFFER_SIZE, // bufsize
	)

	filestream^.FileBlock = fileblock

	// Set up the lex buffer.

	filestream^.Generic.BufferSize = LEX_BUFFER_SIZE
	filestream^.Generic.Buffer = buffer

	RETURN status
END

FN LexFileStreamCreate (
	IN handle : ^VOID,
	IN filename : ^UBYTE,
	OUT filestream : ^^LexFileStream,
) : TwrStatus

	status := TwrAlloc (
		SIZEOF LexFileStream, // bytes
		filestream, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = LexFileStreamInitialize (
		filestream^, // filestream
		handle, // handle
		filename, // filename
	)

	IF status THEN
		TwrFree ( filestream^ )
	END

	RETURN status
END

FN LexStreamGetLastFileStream () : ^LexFileStream

	stream := LexCurrentStream

	// This routine assumes that there will always be at least one file stream
	// on the stream stack. If this assumption is violated, it will walk off
	// into nowhere here.

	WHILE stream^.IsMacro DO
		stream = stream^.Previous
	END

	RETURN CAST stream TO ^LexFileStream
END

FN LexStreamNextCharacter () : UBYTE

	// Return the next byte from the stream on top of the stream stack. If the
	// stream has been emptied, it is popped from the stack and deleted, and
	// the byte from the next stream is returned instead. If it was the last
	// stream on the stack, then EOF has been reached and a null byte is
	// returned. If a file actually contains a null byte, this function will
	// print a diagnostic and the compiler will terminate. This will also be
	// done for a 0x0D byte, which usually appears in DOS line endings. We
	// explicitly do not support DOS line endings, because the MINTIA OS does
	// not use them.
	//
	// For macro streams, there is a buffer that we will return the character
	// directly from. For file streams, there is a buffer that contains some
	// file data. When this buffer runs dry, we have to read more data in.
	// When there is no more data in the file, the stream is considered empty.
	//
	// In any case, we have to maintain the LineNumber field of the stream, by
	// incrementing it each time we encounter a newline character.

	WHILE LexCurrentStream DO
		stream := LexCurrentStream

		byte : UBYTE

		IF stream^.BufferPosition < stream^.ValidLength THEN
			// There is at least one character in the buffer, so return it.

			byte = stream^.Buffer[stream^.BufferPosition]

			stream^.BufferPosition += 1

		ELSEIF stream^.IsMacro THEN
			// The macro stream has emptied.

			LexStreamFree ( LexStreamPop () )

			CONTINUE

		ELSE
			// The remaining code deals with the file stream buffer refill case.

			filestream := CAST stream TO ^LexFileStream

			stream^.ValidLength = TwrReadFile (
				filestream^.FileBlock^.Handle, // handle
				stream^.BufferSize, // bytes
				stream^.Buffer, // OUT buffer
			)

			IF NOT stream^.ValidLength THEN
				// The end of the file has been reached. If the final
				// character wasn't a newline, then present a fake final
				// newline to the upper layers of the lexer. This avoids some
				// nasty edge cases, and guarantees a token will always be
				// terminated by whitespace (never by EOF).

				IF NOT stream^.LastWasNewline THEN
					stream^.LastWasNewline = TRUE

					RETURN 0x0A
				END

				LexStreamFree ( LexStreamPop () )

				CONTINUE
			END

			stream^.BufferPosition = 1

			byte = stream^.Buffer[0]
		END

		IF byte == 0x00 THEN
			TwrStreamError ( "An invalid byte was found in the source file.", byte, 0, 0 )

		ELSEIF byte == '\r' THEN
			TwrStreamError ( "DOS line endings were detected in the source file.", byte, 0, 0 )

		ELSEIF byte == '\n' THEN
			stream^.LineNumber += 1
			stream^.LinePosition = 1
			stream^.LastWasNewline = TRUE

		ELSE
			stream^.LinePosition += 1
			stream^.LastWasNewline = FALSE
		END

		RETURN byte
	END

	RETURN 0
END