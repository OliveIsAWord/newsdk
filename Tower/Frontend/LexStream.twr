//
// Implements stream objects for the lexer.
//

#INCLUDE "<inc>/Frontend.twh"
#INCLUDE "<inc>/Runtime.twh"
#INCLUDE "<inc>/Lexer.twh"

FN LexStreamInitialize (
	IN stream : ^LexStream,
	IN ismacro : UBYTE,
) : TwrStatus

	// Initialize a stream structure.

	stream^.Previous = 0

	stream^.Buffer = 0
	stream^.BufferSize = 0
	stream^.ValidLength = 0
	stream^.LineNumber = 1
	stream^.BufferPosition = 0
	stream^.IsMacro = ismacro

	RETURN TWR_SUCCESS
END

FN LexStreamUninitialize (
	IN stream : ^LexStream,
)

	// Generic uninitialization for any stream type.

	IF NOT stream^.IsMacro THEN
		// This is a file stream, free the buffer.
		// We don't delete the file block since it's still referenced by
		// tokens and such.

		TwrClose ( (CAST stream TO ^LexFileStream)^.FileBlock^.Handle )

		TwrFree ( stream^.Buffer )
	END
END

FN LexStreamFree (
	IN stream : ^LexStream,
)

	LexStreamUninitialize ( stream )
	TwrFree ( stream )
END

FN LexStreamPush (
	IN stream : ^LexStream,
)

	stream^.Previous = LexCurrentStream
	LexCurrentStream = stream
END

FN LexStreamPop () : ^LexStream

	oldstream := LexCurrentStream
	LexCurrentStream = oldstream^.Previous

	RETURN oldstream
END

FN LexFileStreamInitialize (
	IN filestream : ^LexFileStream,
	IN handle : ^VOID,
	IN filename : ^UBYTE,
) : TwrStatus

	// Initialize a file stream.

	status := LexStreamInitialize (
		&filestream^.Generic, // stream
		FALSE, // ismacro
	)

	IF status THEN
		RETURN status
	END

	// Allocate the file block and lex buffer.

	fileblock : ^TwrFileBlock
	buffer : ^UBYTE

	status = TwrAlloc (
		SIZEOF TwrFileBlock, // bytes
		&fileblock, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = TwrAlloc (
		LEX_BUFFER_SIZE, // bytes
		&buffer, // OUT ptr
	)

	IF status THEN
		TwrFree ( fileblock )

		RETURN status
	END

	// Initialize the file block.

	fileblock^.Handle = handle

	TwrStringCopy (
		&fileblock^.Name, // dest
		filename, // src
		TWR_PATH_BUFFER_SIZE, // bufsize
	)

	filestream^.FileBlock = fileblock

	// Set up the lex buffer.

	filestream^.Generic.BufferSize = LEX_BUFFER_SIZE
	filestream^.Generic.Buffer = buffer

	RETURN status
END

FN LexFileStreamCreate (
	IN handle : ^VOID,
	IN filename : ^UBYTE,
	OUT filestream : ^^LexFileStream,
) : TwrStatus

	status := TwrAlloc (
		SIZEOF LexFileStream, // bytes
		filestream, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = LexFileStreamInitialize (
		filestream^, // filestream
		handle, // handle
		filename, // filename
	)

	IF status THEN
		TwrFree ( filestream^ )
	END

	RETURN status
END

FN LexStreamNextCharacter (
	IN stream : ^LexStream,
) : UBYTE

	// Return the next byte from the given stream. If the stream has been
	// emptied, a null byte is returned instead. If an error is reached, a
	// 0xFF byte is returned. If a file actually contains one of these bytes,
	// this function will print a diagnostic and the compiler will terminate.
	// This will also be done for a 0x0D byte, which usually appears in DOS
	// line endings. We explicitly do not support DOS line endings, because
	// the MINTIA OS does not use them.
	//
	// For macro streams, there is a buffer that we will return the character
	// directly from. For file streams, there is a buffer that contains some
	// file data. When this buffer runs dry, we have to read more data in.
	// When there is no more data in the file, the stream is considered empty.
	//
	// In any case, we have to maintain the LineNumber field of the stream, by
	// incrementing it each time we encounter a newline character.

	byte : UBYTE

	IF stream^.BufferPosition < stream^.ValidLength THEN
		// There is at least one character in the buffer, so return it.

		byte = stream^.Buffer[stream^.BufferPosition]

		stream^.BufferPosition += 1
	ELSEIF stream^.IsMacro THEN
		// The macro stream has emptied.

		RETURN 0
	ELSE
		// The remaining code deals with the file stream buffer refill case.

		filestream := CAST stream TO ^LexFileStream

		stream^.ValidLength = TwrReadFile (
			filestream^.FileBlock^.Handle, // handle
			stream^.BufferSize, // bytes
			stream^.Buffer, // OUT buffer
		)

		IF NOT stream^.ValidLength THEN
			RETURN 0
		END

		stream^.BufferPosition = 1

		byte = stream^.Buffer[0]
	END

	IF byte == 0x00 OR byte == 0xFF THEN
		TwrUserError ( "An invalid byte was found in the source file.", byte, 0, 0 )
	ELSEIF byte == 0x0D THEN
		TwrUserError ( "DOS line endings were detected in the source file.", byte, 0, 0 )
	ELSEIF byte == 0x0A THEN
		stream^.LineNumber += 1
	END

	RETURN byte
END