//
// Lexer.
//

#INCLUDE "<inc>/Frontend.twh"
#INCLUDE "<inc>/Runtime.twh"
#INCLUDE "<inc>/Lexer.twh"

// The "engine" of the lexer, the bit that provides the character stream,
// operates by stacking and unstacking source text streams. Each stream has a
// filename and a current line number associated with it, which are ultimately
// used to generate useful diagnostic messages. Streams are associated with
// include files, and also with preprocessor macro expansion.

LexCharTreatment : LexCharBehavior[256] = {
	[' ']  = CHAR_WHITESPACE,
	['\n'] = CHAR_WHITESPACE,
	['\t'] = CHAR_WHITESPACE,

	['^'] = CHAR_SPLIT,
	['('] = CHAR_SPLIT,
	[')'] = CHAR_SPLIT,
	['~'] = CHAR_SPLIT,
	[','] = CHAR_SPLIT,
	['['] = CHAR_SPLIT,
	[']'] = CHAR_SPLIT,
	[':'] = CHAR_SPLIT,
	['{'] = CHAR_SPLIT,
	['}'] = CHAR_SPLIT,

	['='] = CHAR_COALESCE,
	['&'] = CHAR_COALESCE,
	['|'] = CHAR_COALESCE,
	['!'] = CHAR_COALESCE,
	['<'] = CHAR_COALESCE,
	['>'] = CHAR_COALESCE,
	['+'] = CHAR_COALESCE,
	['-'] = CHAR_COALESCE,
	['/'] = CHAR_COALESCE,
	['%'] = CHAR_COALESCE,
	['.'] = CHAR_COALESCE,
	['@'] = CHAR_COALESCE,
	['$'] = CHAR_COALESCE,

	// Since CHAR_NORMAL is the first field in the enum, it is guaranteed to
	// be zero in value, so we don't have to explicitly set all the other
	// character behaviors to it, since any non-defined fields here will also
	// be zero.
}

LexPutbackStack : LexToken[LEX_PUTBACK_STACK_DEPTH]

LexCurrentStream : ^LexStream = 0
LexCurrentMacroScope : ^TwrSymbolTable = 0
LexFalseCount : ULONG = 0
LexPutbackStackPtr : ULONG = 0

FN LexInitialize () : TwrStatus

	// Create the root file stream.

	filestream : ^LexFileStream

	status := LexFileStreamCreate (
		TwrInputFileHandle, // handle
		TwrInputFile, // filename
		&filestream, // OUT filestream
	)

	IF status THEN
		RETURN status
	END

	LexStreamPush ( CAST filestream TO ^LexStream )

	// Create the root macro scope.

	status = TwrSymbolTableCreate (
		0, // outerscope
		&LexMacroDelete, // deletefunc
		&LexCurrentMacroScope, // OUT symboltable
	)

	byte := LexGetCharacter ( )

	WHILE byte DO
		TwrPrintCharacter ( byte )

		byte = LexGetCharacter ( )
	END

	RETURN status
END

FN (TwrHashTableEnumF) LexMacroDelete (
	IN entry : ^TwrHashTableEntry,
)

	TwrFree ( entry )
END

LexCharacterBackslash := FALSE
LexCharacterInString := FALSE
LexCharacterInLiteral := FALSE
LexCharacterPutback : UBYTE = 0

// LexCharacterNewlineSeen is initialized to TRUE so that the first character
// of the stream is correctly identified as the beginning of a line.

LexCharacterNewlineSeen := TRUE

FN LexGetCharacter () : UBYTE

	// Return the next character in the source stream. Omits comments and text
	// that is killed by the "preprocessor", and notices preprocessor
	// directives, which it ships off to a special little interpreter.

	byte : UBYTE

	comment := FALSE

	WHILE TRUE DO
		IF LexCharacterPutback THEN
			byte = LexCharacterPutback
			LexCharacterPutback = 0
		ELSE
			byte = LexStreamNextCharacter ()

			IF NOT byte THEN
				// EOF has been reached.

				BREAK
			END
		END

		// We care about backslashes and about knowing whether we're in a
		// string or not in this routine, because otherwise we will
		// mis-identify things as comments or directives that aren't.

		IF comment THEN
			IF byte != '\n' THEN
				CONTINUE
			END

			comment = FALSE

			// Make sure this newline is seen by the higher level code,
			// otherwise a token that is immediately followed by a comment
			// with no interfering whitespace may not terminate properly.

		ELSEIF LexCharacterInString THEN
			LexCharacterInString = NOT (byte == '\"')

		ELSEIF LexCharacterInLiteral THEN
			LexCharacterInLiteral = NOT (byte == 0x27) // single-quote

		ELSEIF byte == '/' THEN
			// We have to figure out if this is a comment or not. This
			// requires looking at the next character and seeing if it is also
			// a forward slash character. If it is, we set comment to true. If
			// it isn't, we pass this forward slash along and set putback to
			// the value of the character we peeked, causing it to be returned
			// on the next call.

			nextbyte := LexStreamNextCharacter ()

			IF nextbyte == '/' THEN
				comment = TRUE

				CONTINUE
			END

			LexCharacterPutback = nextbyte

		ELSEIF LexCharacterBackslash THEN
			LexCharacterBackslash = FALSE

		ELSEIF byte == '\\' THEN
			LexCharacterBackslash = TRUE

		ELSEIF byte == '\"' THEN
			LexCharacterInString = TRUE

		ELSEIF byte == 0x27 THEN // single-quote
			LexCharacterInLiteral = TRUE

		ELSEIF LexCharacterNewlineSeen AND byte == '#' THEN
			// We found a preprocessor directive! We dispatch to
			// the preprocessor regardless of the value of the false count.
			// This gives it an opportunity to manipulate the false count, but
			// it must be sure to ignore directives that aren't relevant.

			LexParseDirective ()

			// The preprocessor consumed the newline character terminating the
			// directive, so we return one here for good measure.

			byte = '\n'
		END

		LexCharacterNewlineSeen = byte == '\n'

		IF LexFalseCount THEN
			// A non-zero false count causes all characters to be ignored
			// until this situation is resolved by a preprocessor directive.
			// This is used for conditional compilation.

			CONTINUE
		END

		BREAK
	END

	RETURN byte
END