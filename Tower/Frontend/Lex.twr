//
// Lexer. Also performs inline preprocessing.
//

#INCLUDE "<inc>/Frontend.twh"
#INCLUDE "<inc>/Runtime.twh"
#INCLUDE "<inc>/Lexer.twh"

// The "engine" of the lexer, the bit that provides the character stream,
// operates by stacking and unstacking source text streams. Each stream has a
// filename and a current line number associated with it, which are ultimately
// used to generate useful diagnostic messages. Streams are associated with
// include files, and also with preprocessor macro expansion.

CONST LEX_BUFFER_SIZE : ULONG = 8192

ENUM LexCharBehavior : UBYTE
	CHAR_NORMAL,
	CHAR_SPLIT,
	CHAR_COALESCE,
END

LexCharTreatment : LexCharBehavior[256] = {
	['^'] = CHAR_SPLIT,
	['('] = CHAR_SPLIT,
	[')'] = CHAR_SPLIT,
	['~'] = CHAR_SPLIT,
	[','] = CHAR_SPLIT,
	['['] = CHAR_SPLIT,
	[']'] = CHAR_SPLIT,
	[':'] = CHAR_SPLIT,
	['{'] = CHAR_SPLIT,
	['}'] = CHAR_SPLIT,

	['='] = CHAR_COALESCE,
	['&'] = CHAR_COALESCE,
	['|'] = CHAR_COALESCE,
	['!'] = CHAR_COALESCE,
	['<'] = CHAR_COALESCE,
	['>'] = CHAR_COALESCE,
	['+'] = CHAR_COALESCE,
	['-'] = CHAR_COALESCE,
	['/'] = CHAR_COALESCE,
	['%'] = CHAR_COALESCE,
	['.'] = CHAR_COALESCE,
	['@'] = CHAR_COALESCE,
	['$'] = CHAR_COALESCE,
}

STRUCT LexStream
	Previous : ^LexStream,

	Buffer : ^UBYTE,
	BufferSize : ULONG,
	ValidLength : ULONG,

	LineNumber : ULONG,
	BufferPosition : ULONG,

	IsMacro : UBYTE,
END

STRUCT LexFileStream
	Generic : LexStream, // must be at the beginning

	FileBlock : ^TwrFileBlock,
END

STRUCT LexMacroStream
	Generic : LexStream, // must be at the beginning
END

LexCurrentStream : ^LexStream = 0
LexCurrentMacroScope : ^TwrSymbolTable = 0

FN LexStreamInitialize (
	IN stream : ^LexStream,
	IN ismacro : UBYTE,
) : TwrStatus

	// Initialize a stream structure.

	stream^.Previous = 0

	stream^.Buffer = 0
	stream^.BufferSize = 0
	stream^.ValidLength = 0
	stream^.LineNumber = 1
	stream^.BufferPosition = 0
	stream^.IsMacro = ismacro

	RETURN TWR_SUCCESS
END

FN LexStreamUninitialize (
	IN stream : ^LexStream,
)

	// Generic uninitialization for any stream type.

	IF NOT stream^.IsMacro THEN
		// This is a file stream, free the buffer.
		// We don't delete the file block since it's still referenced by
		// tokens and such.

		TwrClose ( (CAST stream TO ^LexFileStream)^.FileBlock^.Handle )

		TwrFree ( stream^.Buffer )
	END
END

FN LexStreamFree (
	IN stream : ^LexStream,
)

	LexStreamUninitialize ( stream )
	TwrFree ( stream )
END

FN LexStreamPush (
	IN stream : ^LexStream,
)

	stream^.Previous = LexCurrentStream
	LexCurrentStream = stream
END

FN LexStreamPop () : ^LexStream

	oldstream := LexCurrentStream
	LexCurrentStream = oldstream^.Previous

	RETURN oldstream
END

FN LexFileStreamInitialize (
	IN filestream : ^LexFileStream,
	IN handle : ^VOID,
	IN filename : ^UBYTE,
) : TwrStatus

	// Initialize a file stream.

	status := LexStreamInitialize (
		&filestream^.Generic, // stream
		FALSE, // ismacro
	)

	IF status THEN
		RETURN status
	END

	// Allocate the file block and lex buffer.

	fileblock : ^TwrFileBlock
	buffer : ^UBYTE

	status = TwrAlloc (
		SIZEOF TwrFileBlock, // bytes
		&fileblock, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = TwrAlloc (
		LEX_BUFFER_SIZE, // bytes
		&buffer, // OUT ptr
	)

	IF status THEN
		TwrFree ( fileblock )

		RETURN status
	END

	// Initialize the file block.

	fileblock^.Handle = handle

	TwrStringCopy (
		&fileblock^.Name, // dest
		filename, // src
		TWR_PATH_BUFFER_SIZE, // bufsize
	)

	filestream^.FileBlock = fileblock

	// Set up the lex buffer.

	filestream^.Generic.BufferSize = LEX_BUFFER_SIZE
	filestream^.Generic.Buffer = buffer

	RETURN status
END

FN LexFileStreamCreate (
	IN handle : ^VOID,
	IN filename : ^UBYTE,
	OUT filestream : ^^LexFileStream,
) : TwrStatus

	status := TwrAlloc (
		SIZEOF LexFileStream, // bytes
		filestream, // OUT ptr
	)

	IF status THEN
		RETURN status
	END

	status = LexFileStreamInitialize (
		filestream^, // filestream
		handle, // handle
		filename, // filename
	)

	IF status THEN
		TwrFree ( filestream^ )
	END

	RETURN status
END

FN LexInitialize () : TwrStatus

	// Create the root file stream.

	filestream : ^LexFileStream

	status := LexFileStreamCreate (
		TwrInputFileHandle, // handle
		TwrInputFile, // filename
		&filestream, // OUT filestream
	)

	IF status THEN
		RETURN status
	END

	LexStreamPush ( CAST filestream TO ^LexStream )

	// Create the root macro scope.

	status = TwrSymbolTableCreate (
		0, // outerscope
		&LexMacroDelete, // deletefunc
		&LexCurrentMacroScope, // OUT symboltable
	)

	RETURN status
END

FN (TwrHashTableEnumF) LexMacroDelete (
	IN entry : ^TwrHashTableEntry,
)

	TwrFree ( entry )
END

FN LexGetCharacter () : UBYTE

	// Get a character from the stream at the top of the stream stack. If the
	// stream ran dry, pop it off the stack. If it was the last one on the
	// stack, EOF has been reached. Here we also must identify preprocessor
	// directives.



	RETURN 0
END