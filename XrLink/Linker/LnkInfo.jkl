//
// Implementation of linker info dumping commands.
// Dumps more info than me at 3 AM after eight Diet Dr Peppers.
//

#INCLUDE "<inc>/Linker.hjk"

LnkArchitectureCodeToName : ^UBYTE[XLO_ARCHITECTURE_MAX] = {
    [XLO_ARCHITECTURE_XR17032] = "xr17032",
    [XLO_ARCHITECTURE_FOX32] = "fox32",
    [XLO_ARCHITECTURE_APHELION] = "aphelion",
    [XLO_ARCHITECTURE_AMD64] = "amd64",
}

LnkFlagToName : ^UBYTE[32] = {
    [0] = "FRAGMENT",
}

LnkSectionFlagToName : ^UBYTE[32] = {
    [0] = "ZERO",
    [1] = "CODE",
    [2] = "MAP",
}

FN LnkDumpInfo (
    IN filename : ^UBYTE,
)

    buf := LnkLoadXloFile ( filename )

    header := CAST buf TO ^XloHeader

    TlPrintString ( "DateStamp     " )
    TlPrintHex ( header^.Timestamp )
    TlPrintString ( "\n" )

    TlPrintString ( "Architecture  " )

    IF header^.TargetArchitecture < XLO_ARCHITECTURE_MAX AND
        LnkArchitectureCodeToName[header^.TargetArchitecture] THEN
        
        TlPrintString ( LnkArchitectureCodeToName[header^.TargetArchitecture] )

    ELSE
        TlPrintString ( "Unknown" )
    END

    TlPrintString ( "\n" )

    TlPrintString ( "Head Length   " )
    TlPrintNumber ( header^.HeadLength )
    TlPrintString ( "\n" )

    TlPrintString ( "Flags         " )

    flags := header^.Flags
    i := 0
    printed := FALSE

    WHILE flags AND i < 32 DO
        IF flags & 1 THEN
            IF printed THEN
                TlPrintString ( " | " )
            END

            IF LnkFlagToName[i] THEN
                TlPrintString ( LnkFlagToName[i] )
            
            ELSE
                TlPrintString ( "FLAG" )
                TlPrintNumber ( i )
            END

            printed = TRUE
        END

        i += 1
        flags >>= 1
    END

    TlPrintString ( "\n\nSections:\n" )

    i = 0
    section := CAST buf + header^.SectionTableOffset TO ^XloSectionHeader
    stringtab := buf + header^.StringTableOffset

    WHILE i < header^.SectionCount DO
        TlPrintString ( stringtab + section^.NameOffset )
        TlPrintString ( ":\n" )

        TlPrintString ( "  Size     " )
        TlPrintNumber ( section^.DataLength )
        TlPrintString ( " bytes\n" )

        TlPrintString ( "  Address  0x" )
        TlPrintHex ( section^.VirtualAddress )
        TlPrintString ( "\n" )

        TlPrintString ( "  Offset   0x" )
        TlPrintHex ( section^.FileOffset )
        TlPrintString ( "\n" )

        TlPrintString ( "  Flags    " )

        j := 0
        printed = FALSE
        flags = section^.Flags

        WHILE flags AND j < 32 DO
            IF flags & 1 THEN
                IF printed THEN
                    TlPrintString ( " | " )
                END

                IF LnkSectionFlagToName[j] THEN
                    TlPrintString ( LnkSectionFlagToName[j] )
                
                ELSE
                    TlPrintString ( "FLAG" )
                    TlPrintNumber ( j )
                END

                printed = TRUE
            END

            j += 1
            flags >>= 1
        END

        TlPrintString ( "\n\n" )

        section += SIZEOF XloSectionHeader
        i += 1
    END
END

FN LnkDumpSymbols (
    IN filename : ^UBYTE,
)

    buf := LnkLoadXloFile ( filename )

    header := CAST buf TO ^XloHeader

    i := 0
    symbol := CAST buf + header^.SymbolTableOffset TO ^XloSymbolEntry
    stringtab := buf + header^.StringTableOffset
    sectiontab := CAST buf + header^.SectionTableOffset TO ^XloSectionHeader

    WHILE i < header^.SymbolCount DO
        IF symbol^.Type == XLO_SYMBOL_GLOBAL THEN
            TlPrintString ( "G " )

        ELSEIF symbol^.Type == XLO_SYMBOL_EXPORT THEN
            TlPrintString ( "E ")
        
        ELSE
            TlPrintString ( "? " )
        END

        section := &sectiontab[symbol^.SectionIndex]

        TlPrintHex ( symbol^.SectionOffset )
        TlPrintString ( " " )
        TlPrintString ( stringtab + section^.NameOffset )
        TlPrintString ( " " )
        TlPrintString ( stringtab + symbol^.NameOffset )
        TlPrintString ( "\n" )

        symbol += SIZEOF XloSymbolEntry
        i += 1
    END
END

FN LnkDumpExterns (
    IN filename : ^UBYTE,
)

    buf := LnkLoadXloFile ( filename )

    header := CAST buf TO ^XloHeader

    i := 0
    extern := CAST buf + header^.ExternTableOffset TO ^XloExternEntry
    stringtab := buf + header^.StringTableOffset

    WHILE i < header^.ExternCount DO
        TlPrintString ( stringtab + extern^.NameOffset )
        TlPrintString ( "\n" )

        extern += SIZEOF XloExternEntry
        i += 1
    END
END

XloRelocTypeNames : ^UBYTE[XLO_RELOC_MAX] = {
    [XLO_RELOC_PTR] = "PTR",

    [XLO_RELOC_XR17032_ABSJ] = "XR17032_ABSJ",
    [XLO_RELOC_XR17032_LA] = "XR17032_LA",
    [XLO_RELOC_XR17032_FAR_INT] = "XR17032_FAR_INT",
    [XLO_RELOC_XR17032_FAR_LONG] = "XR17032_FAR_LONG",

    [XLO_RELOC_FOX32_CALL] = "FOX32_CALL",
}

FN LnkDumpRelocs (
    IN filename : ^UBYTE,
)

    buf := LnkLoadXloFile ( filename )

    header := CAST buf TO ^XloHeader

    i := 0
    sectiontab := CAST buf + header^.SectionTableOffset TO ^XloSectionHeader
    stringtab := buf + header^.StringTableOffset
    externtab := CAST buf + header^.ExternTableOffset TO ^XloExternEntry

    j : UWORD
    reloc : ^XloRelocEntry

    IF header^.Flags & XLO_FILE_FRAGMENT THEN
        extheader := CAST buf TO ^XloHeaderExtended

        TlPrintString ( "EXTERN:\n" )

        j = 0
        reloc =
            CAST buf + extheader^.UnresolvedFixupTableOffset TO ^XloRelocEntry

        WHILE j < extheader^.UnresolvedFixupCount DO
            TlPrintHex ( reloc^.SectionOffset )
            TlPrintString ( " " )
            TlPrintString ( stringtab + sectiontab[reloc^.SectionIndex].NameOffset )
            TlPrintString ( " " )
            TlPrintString ( stringtab + externtab[reloc^.ExternIndex].NameOffset )
            TlPrintString ( " " )

            IF reloc^.Type < XLO_RELOC_MAX AND
                XloRelocTypeNames[reloc^.Type] THEN

                TlPrintString ( XloRelocTypeNames[reloc^.Type] )

            ELSE
                TlPrintString ( "UnknownType" )
            END


            TlPrintString ( "\n" )

            reloc += SIZEOF XloRelocEntry
            j += 1
        END

        TlPrintString ( "\n" )
    END

    WHILE i < header^.SectionCount DO
        TlPrintString ( stringtab + sectiontab[i].NameOffset )
        TlPrintString ( ":\n" )

        j = 0
        reloc = CAST buf + sectiontab[i].RelocTableOffset TO ^XloRelocEntry

        WHILE j < sectiontab[i].RelocCount DO
            TlPrintHex ( reloc^.SectionOffset )
            TlPrintString ( " " )
            TlPrintString ( stringtab + sectiontab[reloc^.SectionIndex].NameOffset )
            TlPrintString ( " " )

            IF reloc^.Type < XLO_RELOC_MAX AND
                XloRelocTypeNames[reloc^.Type] THEN

                TlPrintString ( XloRelocTypeNames[reloc^.Type] )

            ELSE
                TlPrintString ( "UnknownType" )
            END

            TlPrintString ( "\n" )

            reloc += SIZEOF XloRelocEntry
            j += 1
        END

        TlPrintString ( "\n" )

        i += 1
    END
END

FN LnkDumpFixups (
    IN filename : ^UBYTE,
)

    TlInternalError ( "TODO fixups dumping deferred until there are object files with fixups", 0, 0, 0 )
END

FN LnkDumpImports (
    IN filename : ^UBYTE,
)

    TlInternalError ( "TODO imports dumping deferred until there are object files with imports", 0, 0, 0 )
END