//
// Link stuff.
//

#INCLUDE "<inc>/Linker.hjk"

#IF ( == BITS 32 )

#MACRO LnkEncodeExternLink ( extern, ptr ) [
    extern^.Padding2 = CAST ptr TO UWORD
]

#MACRO LnkFetchExternLinkToSymbol ( extern ) [
    CAST extern^.Padding2 TO ^LnkSymbol
]

#MACRO LnkFetchExternLinkToExtern ( extern ) [
    CAST extern^.Padding2 TO ^LnkExtern
]

#ELSE

// This is necessary since the extern table entries are not necessarily UQUAD
// aligned, and we will run on 64-bit architectures w/ alignment restrictions
// (such as Aphelion).

#MACRO LnkEncodeExternLink ( extern, ptr ) [
    extern^.Padding2 = (CAST ptr TO UWORD) & 0xFFFFFFFF
    extern^.Padding3 = (CAST ptr TO UWORD) >> 32
]

#MACRO LnkFetchExternLinkToSymbol ( extern ) [
    CAST extern^.Padding2 | (extern^.Padding3 << 32) TO ^LnkSymbol
]

#MACRO LnkFetchExternLinkToExtern ( extern ) [
    CAST extern^.Padding2 | (extern^.Padding3 << 32) TO ^LnkExtern
]

#END

LnkObjectListHead : TlListEntry
LnkLibListHead : TlListEntry
LnkUnresolvedFixupList : TlListEntry
LnkSpecialRelocationList : TlListEntry
LnkSectionTable : TlHashTable
LnkSymbolTable : TlHashTable
LnkExternTable : TlHashTable
LnkJumpStubSection : ^LnkSection

LnkSectionCount := 0
LnkSymbolCount := 0
LnkExternCount := 0
LnkUnresolvedCount := 0
LnkHeadLength := 0

LnkIndexedSectionArray : ^LnkSection[256]

STRUCT LnkObject
    Entry : TlListEntry,

    Path : ^UBYTE,
    Data : ^UBYTE,
END

STRUCT LnkLibrary
    Entry : TlListEntry,

    Path : ^UBYTE,
    Data : ^UBYTE,

    FixupListHead : TlListEntry,
END

STRUCT LnkSection
    Entry : TlHashTableEntry,

    RelocationListHead : TlListEntry,

    VirtualAddress : UWORD,
    Size : UWORD,
    Flags : UWORD,
    Index : UWORD,
    Pen : UWORD,

    Data : ^UBYTE,
    DynamicData : TlDynamicBuffer,
END

STRUCT LnkRelocation
    Entry : TlListEntry,

    Section : ^LnkSection,
    SectionOffset : UWORD,
    Type : UWORD,
    Extern : ^LnkExtern,
END

#DEFINE LNK_SYMBOL_BASE 1
#DEFINE LNK_SYMBOL_SIZE 2
#DEFINE LNK_SYMBOL_END 3

STRUCT LnkSymbol
    Entry : TlHashTableEntry,

    Section : ^LnkSection,
    SectionOffset : UWORD,
    Type : UWORD,

    SourceObject : ^LnkObject,
END

STRUCT LnkExtern
    Entry : TlHashTableEntry,

    SourceObject : ^LnkObject,

    Library : ^LnkLibrary,
    Symbol : ^XloSymbolEntry,
    Address : UWORD,

    JumpStubOffset : UWORD,

    HasJumpStub : UBYTE,
END

FN LnkFindSection (
    IN name : ^UBYTE,
    IN flags : UWORD,
    IN objectname : ^UBYTE,
) : ^LnkSection

    // Find or create a matching section.

    created : UBYTE

    section := CAST TlLookupOrAllocateEntryHashTable (
        &LnkSectionTable, // hashtable
        SIZEOF LnkSection, // entrysize
        name, // key
        OUT created, // created
    ) TO ^LnkSection

    IF created THEN
        // Initialize the section structure.

        IF LnkSectionCount == 256 THEN
            TlPrintString ( objectname )
            TlPrintString ( ": " )
            TlPrintString ( name )
            TlPrintString ( ": Maximum section count exceeded\n" )

            TlErrorExit ()
        END

        section^.Size = 0
        section^.Flags = flags
        section^.Index = LnkSectionCount
        section^.Pen = 0
        section^.Data = NULLPTR
        section^.VirtualAddress = 0

        TlInitializeList ( &section^.RelocationListHead )

        TlInitializeDynamicBuffer ( &section^.DynamicData )

        LnkIndexedSectionArray[LnkSectionCount] = section
    
        LnkSectionCount += 1

        IF NOT LnkJumpStubSection AND flags & XLO_SECTION_CODE THEN
            // The stub section is the first code section found.

            LnkJumpStubSection = section
        END

    ELSE
        // Check that the section matches.

        IF flags != section^.Flags THEN
            TlPrintString ( objectname )
            TlPrintString ( ": Mismatched section '" )
            TlPrintString ( name )
            TlPrintString ( "'\n" )

            TlErrorExit ()
        END
    END

    RETURN section
END

FN LnkAddStaticObject (
    IN filename : ^UBYTE,
)

    // Allocate an object block.
    // N.B. filename must be in permanent memory.

    object : ^LnkObject

    status := TlBumpAlloc (
        SIZEOF LnkObject, // bytes
        OUT object, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate object block", 0, 0, 0 )
    END

    // Load the static object.

    object^.Data = LnkLoadXloFile ( filename )
    object^.Path = filename

    // Sanity check the header.

    header := CAST object^.Data TO ^XloHeader

    IF NOT (header^.Flags & XLO_FILE_FRAGMENT) THEN
        TlPrintString ( filename )
        TlPrintString ( ": Can't link non-fragment objects\n" )

        TlErrorExit ()
    END

    // Insert in list.

    TlInsertAtTailList (
        &LnkObjectListHead, // head
        &object^.Entry, // entry
    )
END

FN LnkAddDynamicObject (
    IN filename : ^UBYTE,
)

    // Allocate a library block.
    // N.B. filename must be in permanent memory.

    library : ^LnkLibrary

    status := TlBumpAlloc (
        SIZEOF LnkLibrary, // bytes
        OUT library, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate library block", 0, 0, 0 )
    END

    // Load the dynamic library.

    library^.Data = LnkLoadXloFile ( filename )
    library^.Path = filename

    TlInitializeList ( &library^.FixupListHead )

    // Sanity check the header.

    header := CAST library^.Data TO ^XloHeader

    IF header^.Flags & XLO_FILE_FRAGMENT THEN
        TlPrintString ( filename )
        TlPrintString ( ": Can't dynamically link with fragment\n" )

        TlErrorExit ()
    END

    // Insert in list.

    TlInsertAtTailList (
        &LnkLibListHead, // head
        &library^.Entry, // entry
    )
END

FNPTR LnkRelocF (
    IN ptr : ^VOID,
    IN value : UWORD,
)

FN (LnkRelocF) LnkPerformRelocPtr (
    IN ptr : ^VOID,
    IN value : UWORD,
)

    IF LnkArchitectureInTokyo == 32 THEN
        // Update 32-bit pointer.

        data := CAST ptr TO ^ULONG

        data^ += value

        LEAVE
    END

    // Must be 64.

#IF ( == BITS 64 )
    data := CAST ptr TO ^UQUAD

    data^ += value

#ELSE
    // This should have been rejected earlier.

    TlInternalError ( "64 bit relocation on 32 bit linker build", 0, 0, 0 )
#END

END

FN (LnkRelocF) LnkPerformRelocXrAbsj (
    IN ptr : ^VOID,
    IN value : UWORD,
)

    // Relocate XR17032 absolute jump.
    // The pointer is the base of the jump instruction.

    IF value & 3 THEN
        TlInternalError ( "Unaligned XR_ABSJ offset", value, 0, 0 )
    END

    IF ptr & 3 THEN
        TlInternalError ( "Unaligned XR_ABSJ ptr", CAST ptr TO UWORD, 0, 0 )
    END

    instptr := CAST ptr TO ^ULONG
    inst := instptr^

    // Isolate the jump target.

    oldvalue := inst >> 3

    // Add the offset.

    oldvalue += value >> 2

    // Re-encode the instruction with the new jump target and the original
    // jump opcode.

    instptr^ = (oldvalue << 3) | (inst & 0x7)
END

FN (LnkRelocF) LnkPerformRelocXrLa (
    IN ptr : ^VOID,
    IN value : UWORD,
)

    // Relocate XR17032 LA pseudo-instruction.
    // The pointer is the base of the instruction pair.
    // The first instruction loads the upper 16 bits and the second instruction
    // loads the lower 16 bits.

    IF value & 3 THEN
        TlInternalError ( "Unaligned XR_LA offset", value, 0, 0 )
    END

    IF ptr & 3 THEN
        TlInternalError ( "Unaligned XR_LA ptr", CAST ptr TO UWORD, 0, 0 )
    END

    instptr := CAST ptr TO ^ULONG
    
    insthi := instptr[0]
    instlo := instptr[1]

    // Isolate the old value.

    oldvalue := (insthi & 0xFFFF0000) | (instlo >> 16)

    // Add the offset.

    oldvalue += value

    // Re-encode the instructions with the new value and the original opcodes.

    instptr[0] = (oldvalue & 0xFFFF0000) | (insthi & 0xFFFF)
    instptr[1] = (oldvalue << 16) | (instlo & 0xFFFF)
END

FN (LnkRelocF) LnkPerformRelocXrFarInt (
    IN ptr : ^VOID,
    IN value : UWORD,
)

    // Relocate XR17032 "far int" pseudo-instructions.
    // The pointer is the base of the instruction pair.
    // The first instruction loads the upper 16 bits and the second instruction
    // loads the lower 16 bits, shifted right by 1.

    IF value & 3 THEN
        TlInternalError ( "Unaligned XR_FAR_INT offset", value, 0, 0 )
    END

    IF ptr & 3 THEN
        TlInternalError ( "Unaligned XR_FAR_INT ptr", CAST ptr TO UWORD, 0, 0 )
    END

    instptr := CAST ptr TO ^ULONG
    
    insthi := instptr[0]
    instlo := instptr[1]

    // Isolate the old value.

    oldvalue := (insthi & 0xFFFF0000) | ((instlo >> 16) << 1)

    // Add the offset.

    oldvalue += value

    // Re-encode the instructions with the new value and the original opcodes.

    instptr[0] = (oldvalue & 0xFFFF0000) | (insthi & 0xFFFF)
    instptr[1] = ((oldvalue << 16) >> 1) | (instlo & 0xFFFF)
END

FN (LnkRelocF) LnkPerformRelocXrFarLong (
    IN ptr : ^VOID,
    IN value : UWORD,
)

    // Relocate XR17032 "far long" pseudo-instructions.
    // The pointer is the base of the instruction pair.
    // The first instruction loads the upper 16 bits and the second instruction
    // loads the lower 16 bits, shifted right by 2.

    IF value & 3 THEN
        TlInternalError ( "Unaligned XR_FAR_LONG offset", value, 0, 0 )
    END

    IF ptr & 3 THEN
        TlInternalError ( "Unaligned XR_FAR_LONG ptr", CAST ptr TO UWORD, 0, 0 )
    END

    instptr := CAST ptr TO ^ULONG
    
    insthi := instptr[0]
    instlo := instptr[1]

    // Isolate the old value.

    oldvalue := (insthi & 0xFFFF0000) | ((instlo >> 16) << 2)

    // Add the offset.

    oldvalue += value

    // Re-encode the instructions with the new value and the original opcodes.

    instptr[0] = (oldvalue & 0xFFFF0000) | (insthi & 0xFFFF)
    instptr[1] = ((oldvalue << 16) >> 2) | (instlo & 0xFFFF)
END

LnkPerformRelocationTable : LnkRelocF[] = {
    [XLO_RELOC_PTR] = &LnkPerformRelocPtr,

    [XLO_RELOC_XR17032_ABSJ] = &LnkPerformRelocXrAbsj,
    [XLO_RELOC_XR17032_LA] = &LnkPerformRelocXrLa,
    [XLO_RELOC_XR17032_FAR_INT] = &LnkPerformRelocXrFarInt,
    [XLO_RELOC_XR17032_FAR_LONG] = &LnkPerformRelocXrFarLong,
}

LnkCreateJumpStub : UBYTE[XLO_RELOC_MAX] = {
    [XLO_RELOC_XR17032_ABSJ] = TRUE,
}

FN LnkRelocateInternalSection (
    IN section : ^XloSectionHeader,
    IN sectiontable : ^XloSectionHeader,
    IN base : ^VOID,
    IN offset : UWORD,
)

    // Relocate a section by the provided offset.

    reloc := CAST base + section^.RelocTableOffset TO ^XloRelocEntry
    count := section^.RelocCount

    WHILE count DO
        targetsection := &sectiontable[reloc^.SectionIndex]

        LnkPerformRelocationTable[reloc^.Type] (
            base + targetsection^.FileOffset + reloc^.SectionOffset, // ptr
            offset, // value
        )

        count -= 1
        reloc += SIZEOF XloRelocEntry
    END
END

FN LnkAllocateStorage ()

    // Allocate storage for each of the sections in each of the objects.
    // We also relocate the section by its offset.

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeader

        sectiontable :=
            CAST header + header^.SectionTableOffset TO ^XloSectionHeader

        stringtable := CAST header + header^.StringTableOffset TO ^UBYTE

        i := 0

        WHILE i < header^.SectionCount DO
            section := &sectiontable[i]
            sectionname := stringtable + section^.NameOffset

            IF section^.VirtualAddress != 0 THEN
                TlPrintString ( object^.Path )
                TlPrintString ( ": Section with non-zero base '" )
                TlPrintString ( sectionname )
                TlPrintString ( "'\n" )
                TlErrorExit ()
            END

            // Find the final section.

            lnksection := LnkFindSection (
                sectionname, // name
                section^.Flags, // flags
                object^.Path, // objectname
            )

            // Cache the index of the final section.

            section^.NameOffset = lnksection^.Index

            // Stash the offset of this section from the base of the matching
            // final section in the VirtualAddress field of its header.

            section^.VirtualAddress = lnksection^.Size

            // Increment the size of the final section.

            lnksection^.Size += section^.DataLength

            // Run down the relocation table to offset all references to
            // this section by the byte count we've determined.
            // Don't bother if the offset is zero.

            IF section^.VirtualAddress THEN
                LnkRelocateInternalSection (
                    section, // section
                    sectiontable, // sectiontable
                    header, // base
                    section^.VirtualAddress, // offset
                )
            END

            i += 1
        END

        // While we're here, accumulate a count of all symbols.

        LnkSymbolCount += header^.SymbolCount

        listentry = listentry^.Next
    END
END

FN LnkMergeSections ()

    // Merge the relocation tables and contents of the sections.

    status : TlStatus

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeader

        sectiontable :=
            CAST header + header^.SectionTableOffset TO ^XloSectionHeader

        i := 0

        WHILE i < header^.SectionCount DO
            section := &sectiontable[i]

            // Find the final section using the cached index.

            lnksection := LnkIndexedSectionArray[section^.NameOffset]

            IF NOT (lnksection^.Flags & XLO_SECTION_ZERO) THEN
                IF NOT lnksection^.Data AND lnksection^.Size THEN
                    // We need to allocate the data buffer.

                    status = TlBumpAlloc (
                        lnksection^.Size, // bytes
                        OUT lnksection^.Data, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate section contents", 0, 0, 0 )
                    END
                END

                IF section^.DataLength THEN
                    // Copy our data into the final section.

                    TlCopyMemory (
                        lnksection^.Data + lnksection^.Pen, // dest
                        header + section^.FileOffset, // src
                        section^.DataLength, // sz
                    )

                    lnksection^.Pen += section^.DataLength
                END
            END

            IF section^.RelocCount THEN
                // Copy our relocations into the final section.

                reloctable :=
                    CAST header + section^.RelocTableOffset TO ^XloRelocEntry

                j := 0

                WHILE j < section^.RelocCount DO
                    reloc := &reloctable[j]

                    lnkreloc : ^LnkRelocation

                    status = TlBumpAlloc (
                        SIZEOF LnkRelocation, // bytes
                        OUT lnkreloc, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate relocation", 0, 0, 0 )
                    END

                    // Create the relocation structure.

                    targetsection := &sectiontable[reloc^.SectionIndex]

                    // Make sure to increment the offset by the offset of the
                    // target section from the base of the final section.

                    lnkreloc^.SectionOffset =
                        reloc^.SectionOffset + targetsection^.VirtualAddress

                    // Store a pointer to the final section.

                    lnkreloc^.Section =
                        LnkIndexedSectionArray[targetsection^.NameOffset]

                    // Copy the relocation type.

                    lnkreloc^.Type = reloc^.Type

                    // Insert in the final section's relocation list.

                    TlInsertAtTailList (
                        &lnksection^.RelocationListHead, // head
                        &lnkreloc^.Entry, // entry
                    )

                    j += 1
                END
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkCreateSpecialSymbol (
    IN section : ^LnkSection,
    IN name : ^UBYTE,
    IN type : UWORD,
)

    // Helper function to create a special symbol.

    lnksymbol : ^LnkSymbol

    status := TlBumpAlloc (
        SIZEOF LnkSymbol, // bytes
        OUT lnksymbol, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate special symbol", 0, 0, 0 )
    END

    lnksymbol^.SourceObject =
        CONTAINEROF LnkObjectListHead.Next TO LnkObject.Entry
    
    lnksymbol^.Section = section

    lnksymbol^.SectionOffset = type

    lnksymbol^.Type = XLO_SYMBOL_SPECIAL

    TlInsertHashTable (
        &LnkSymbolTable, // hashtable
        &lnksymbol^.Entry, // entry
        name, // key
    )
END

FN LnkCreateSpecialSymbols ()
    
    // Create special symbols for each section.
    // These consist of:
    //
    // _[section]: The base of the section.
    // _[section]_size: The size of the section.
    // _[section]_end: The end of the section.

    symnamearray : ^TlDynamicBuffer

    status := TlBumpAlloc (
        SIZEOF TlDynamicBuffer, // bytes
        OUT symnamearray, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate special sym names", 0, 0, 0 )
    END

    TlInitializeDynamicBuffer ( symnamearray )

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        sectionname := lnksection^.Entry.Key
        sectionnamelen := TlMeasureString ( sectionname )

        TlInsertDynamicBuffer (
            symnamearray, // array
            '_', // byte
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            sectionname, // srcbuf
            sectionnamelen, // length
        )

        TlInsertDynamicBuffer (
            symnamearray, // array
            0, // byte
        )

        basename :=
            &symnamearray^.Buffer[symnamearray^.Count - sectionnamelen - 2]

        TlInsertDynamicBuffer (
            symnamearray, // array
            '_', // byte
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            sectionname, // srcbuf
            sectionnamelen, // length
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            "_size", // srcbuf
            6, // length (plus null terminator)
        )

        sizename :=
            &symnamearray^.Buffer[symnamearray^.Count - sectionnamelen - 7]

        TlInsertDynamicBuffer (
            symnamearray, // array
            '_', // byte
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            sectionname, // srcbuf
            sectionnamelen, // length
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            "_end", // srcbuf
            5, // length (plus null terminator)
        )

        endname :=
            &symnamearray^.Buffer[symnamearray^.Count - sectionnamelen - 6]

        LnkCreateSpecialSymbol (
            lnksection, // section
            basename, // name
            LNK_SYMBOL_BASE, // type
        )

        LnkCreateSpecialSymbol (
            lnksection, // section
            sizename, // name
            LNK_SYMBOL_SIZE, // type
        )

        LnkCreateSpecialSymbol (
            lnksection, // section
            endname, // name
            LNK_SYMBOL_END, // type
        )

        listentry = listentry^.Next
    END
END

FN LnkMergeSymbolTables ()

    // Merge the symbol tables together.

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeader

        symboltable :=
            CAST header + header^.SymbolTableOffset TO ^XloSymbolEntry

        sectiontable :=
            CAST header + header^.SectionTableOffset TO ^XloSectionHeader

        stringtable := CAST header + header^.StringTableOffset TO ^UBYTE

        i := 0

        WHILE i < header^.SymbolCount DO
            symbol := &symboltable[i]

            section := &sectiontable[symbol^.SectionIndex]

            created : UBYTE

            lnksymbol := CAST TlLookupOrAllocateEntryHashTable (
                &LnkSymbolTable, // hashtable
                SIZEOF LnkSymbol, // entrysize
                stringtable + symbol^.NameOffset, // key
                OUT created, // created
            ) TO ^LnkSymbol

            IF NOT created THEN
                // There's a symbol collision!

                TlPrintString ( "Symbol '" )
                TlPrintString ( stringtable + symbol^.NameOffset )
                TlPrintString ( "' defined in both:\n " )
                TlPrintString ( lnksymbol^.SourceObject^.Path )
                TlPrintString ( "\n " )
                TlPrintString ( object^.Path )
                TlPrintString ( "\n" )

                TlErrorExit ()
            END

            // Initialize the symbol structure.

            lnksymbol^.SourceObject = object
            
            lnksymbol^.Section = LnkIndexedSectionArray[section^.NameOffset]
            
            // Make sure the symbol value is offset by the offset of the
            // original section.

            lnksymbol^.SectionOffset =
                symbol^.SectionOffset + section^.VirtualAddress

            lnksymbol^.Type = symbol^.Type

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkResolveExterns ()

    // Resolve the outstanding externs for each object file.

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeader

        externtable :=
            CAST header + header^.ExternTableOffset TO ^XloExternEntry

        stringtable := CAST header + header^.StringTableOffset TO ^UBYTE

        i := 0

        WHILE i < header^.ExternCount DO
            extern := &externtable[i]

            // Look up the extern's name in the combined symbol table.

            symbol := CAST TlLookupHashTable (
                &LnkSymbolTable, // hashtable
                stringtable + extern^.NameOffset, // key
            ) TO ^LnkSymbol

            IF symbol THEN
                // Resolved! Record that.

                extern^.Type = XLO_EXTERN_RESOLVED

                LnkEncodeExternLink ( extern, symbol )

            ELSE
                // Not resolved (yet). Place into the global extern hash table.

                created : UBYTE

                lnkextern := CAST TlLookupOrAllocateEntryHashTable (
                    &LnkExternTable, // hashtable
                    SIZEOF LnkExtern, // entrysize
                    stringtable + extern^.NameOffset, // key
                    OUT created, // created
                ) TO ^LnkExtern

                IF created THEN
                    // Initialize.

                    lnkextern^.SourceObject = object
                    lnkextern^.Library = NULLPTR
                    lnkextern^.Symbol = NULLPTR
                    lnkextern^.HasJumpStub = FALSE

                    LnkExternCount += 1
                    LnkUnresolvedCount += 1
                END

                LnkEncodeExternLink ( extern, lnkextern )
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkBindExports ()

    // Bind the exported symbols of the dynamic libraries to any relevant
    // outstanding externs.

    listhead := &LnkLibListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        library := CONTAINEROF listentry TO LnkLibrary.Entry
        
        header := CAST library^.Data TO ^XloHeader

        symboltable :=
            CAST header + header^.SymbolTableOffset TO ^XloSymbolEntry

        stringtable := CAST header + header^.StringTableOffset TO ^UBYTE

        sectiontable :=
            CAST header + header^.SectionTableOffset TO ^XloSectionHeader

        i := 0

        WHILE i < header^.SymbolCount DO
            symbol := &symboltable[i]
            section := &sectiontable[symbol^.SectionIndex]

            IF symbol^.Type == XLO_SYMBOL_EXPORT THEN
                // Look it up in the extern hash table.

                lnkextern := CAST TlLookupHashTable (
                    &LnkExternTable, // hashtable
                    stringtable + symbol^.NameOffset, // key
                ) TO ^LnkExtern

                IF lnkextern AND NOT lnkextern^.Library THEN
                    // Woo! Got one.

                    lnkextern^.Library = library
                    
                    lnkextern^.Symbol = symbol
                    
                    lnkextern^.Address =
                        section^.VirtualAddress + symbol^.SectionOffset

                    LnkUnresolvedCount -= 1
                END
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FNPTR LnkCreateStubF (
    IN lnkextern : ^LnkExtern,
)

FN (LnkCreateStubF) LnkCreateXr17032Stub (
    IN lnkextern : ^LnkExtern,
)

    // Create a jump stub for XR/17032.
    // This is just a single  J [ADDR]  instruction appended to the end of the
    // jump stub section.

    inst : ULONG[1]

    inst[0] = 0x6 // J opcode
    inst[0] |= (lnkextern^.Address >> 2) << 3

    TlCopyIntoDynamicBuffer (
        &LnkJumpStubSection^.DynamicData, // array
        &inst[0], // srcbuf
        4, // length
    )

    // Create the import fixup that fixes up the jump stub if the dynamic
    // library is relocated.

    lnkreloc : ^LnkRelocation

    status := TlBumpAlloc (
        SIZEOF LnkRelocation, // bytes
        OUT lnkreloc, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate relocation", 0, 0, 0 )
    END

    lnkreloc^.Extern = lnkextern

    lnkreloc^.SectionOffset = lnkextern^.JumpStubOffset

    lnkreloc^.Section = LnkJumpStubSection

    lnkreloc^.Type = XLO_RELOC_XR17032_ABSJ

    TlInsertAtTailList (
        &lnkextern^.Library^.FixupListHead, // head
        &lnkreloc^.Entry, // entry
    )
END

LnkCreateStubTable : LnkCreateStubF[XLO_ARCHITECTURE_MAX] = {
    [XLO_ARCHITECTURE_XR17032] = &LnkCreateXr17032Stub,
}

FN LnkResolveFixupTable ()

    // For each object, we now need to iterate its unresolved fixup table and
    // figure out the nature of each fixup.
    //
    // 1. If it pointed to an extern that we resolved "internally", we have to
    //    perform the relocation to replace the placeholder zeroes with the
    //    address of the symbol it was resolved to. We then need to create a new
    //    relocation for that.
    //
    // 2. If it pointed to an extern that we resolved "externally", i.e. in a
    //    dynamic library, we have to create an import fixup for placement in
    //    the library import's fixup table.
    //
    // 3. If it was unresolved, just place it in an unresolved fixup list.

    status : TlStatus

    lnkreloc : ^LnkRelocation

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeaderExtended

        externtable :=
            CAST header + header^.Hdr.ExternTableOffset TO ^XloExternEntry

        stringtable := CAST header + header^.Hdr.StringTableOffset TO ^UBYTE

        fixuptable :=
            CAST header + header^.UnresolvedFixupTableOffset TO ^XloRelocEntry

        sectiontable :=
            CAST header + header^.Hdr.SectionTableOffset TO ^XloSectionHeader

        i := 0

        WHILE i < header^.UnresolvedFixupCount DO
            fixup := &fixuptable[i]
            extern := &externtable[fixup^.ExternIndex]
            section := &sectiontable[fixup^.SectionIndex]
            lnksection := LnkIndexedSectionArray[section^.NameOffset]

            IF extern^.Type == XLO_EXTERN_RESOLVED THEN
                // Case 1: Resolved internally.
            
                lnksymbol := LnkFetchExternLinkToSymbol ( extern )

                IF lnksymbol^.Type != XLO_SYMBOL_SPECIAL THEN
                    // Perform the fixup to bind the extern.

                    LnkPerformRelocationTable[fixup^.Type] (
                        lnksection^.Data +
                        section^.VirtualAddress +
                        fixup^.SectionOffset, // ptr
                        lnksymbol^.SectionOffset, // value
                    )

                    // Create new relocation.

                    status = TlBumpAlloc (
                        SIZEOF LnkRelocation, // bytes
                        OUT lnkreloc, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate relocation", 0, 0, 0 )
                    END

                    lnkreloc^.SectionOffset =
                        section^.VirtualAddress + fixup^.SectionOffset

                    lnkreloc^.Section = lnksection

                    lnkreloc^.Type = fixup^.Type

                    TlInsertAtTailList (
                        &lnksymbol^.Section^.RelocationListHead, // head
                        &lnkreloc^.Entry, // entry
                    
                    )

                ELSE
                    // This was a special symbol, so create a special deferred
                    // relocation, which is only used internally by the linker
                    // after section parameters are fully known.

                    status = TlBumpAlloc (
                        SIZEOF LnkRelocation, // bytes
                        OUT lnkreloc, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate relocation", 0, 0, 0 )
                    END

                    lnkreloc^.SectionOffset =
                        section^.VirtualAddress + fixup^.SectionOffset

                    lnkreloc^.Section = lnksection

                    lnkreloc^.Extern = CAST lnksymbol TO ^LnkExtern

                    lnkreloc^.Type = fixup^.Type

                    TlInsertAtTailList (
                        &LnkSpecialRelocationList, // head
                        &lnkreloc^.Entry, // entry
                    )
                END

            ELSE
                lnkextern := LnkFetchExternLinkToExtern ( extern )

                IF lnkextern^.Library THEN
                    // Case 2: Resolved in dynamic library.

                    IF LnkCreateJumpStub[fixup^.Type] AND LnkCreateStubs THEN
                        // We need to use a jump stub.

                        IF NOT lnkextern^.HasJumpStub THEN
                            // Create the jump stub.

                            IF NOT LnkJumpStubSection THEN
                                TlPrintString ( "No code section for stubs\n" )
                                TlErrorExit ()
                            END

                            lnkextern^.JumpStubOffset =
                                LnkJumpStubSection^.Size +
                                LnkJumpStubSection^.DynamicData.Count

                            lnkextern^.HasJumpStub = TRUE

                            // Call the architecture-specific junk to actually
                            // encode it. Also creates the import fixup.

                            LnkCreateStubTable[LnkArchitectureType] (
                                lnkextern, // lnkextern
                            )
                        END

                        // Perform the fixup to redirect to the jump stub.

                        LnkPerformRelocationTable[fixup^.Type] (
                            lnksection^.Data +
                            section^.VirtualAddress +
                            fixup^.SectionOffset, // ptr
                            lnkextern^.JumpStubOffset, // value
                        )

                        // Create a relocation referencing the jump stub.

                        status = TlBumpAlloc (
                            SIZEOF LnkRelocation, // bytes
                            OUT lnkreloc, // ptr
                        )

                        IF status THEN
                            TlInternalError (
                                "Failed to allocate relocation", 0, 0, 0 )
                        END

                        lnkreloc^.SectionOffset =
                            section^.VirtualAddress + fixup^.SectionOffset

                        lnkreloc^.Section = lnksection

                        lnkreloc^.Type = fixup^.Type

                        TlInsertAtTailList (
                            &LnkJumpStubSection^.RelocationListHead, // head
                            &lnkreloc^.Entry, // entry
                        )

                    ELSE
                        // Perform the fixup to bind the extern.

                        LnkPerformRelocationTable[fixup^.Type] (
                            lnksection^.Data +
                            section^.VirtualAddress +
                            fixup^.SectionOffset, // ptr
                            lnkextern^.Address, // value
                        )

                        // Create an import fixup.

                        status = TlBumpAlloc (
                            SIZEOF LnkRelocation, // bytes
                            OUT lnkreloc, // ptr
                        )

                        IF status THEN
                            TlInternalError (
                                "Failed to allocate relocation", 0, 0, 0 )
                        END

                        lnkreloc^.Extern = lnkextern

                        lnkreloc^.SectionOffset =
                            section^.VirtualAddress + fixup^.SectionOffset

                        lnkreloc^.Section = lnksection

                        lnkreloc^.Type = fixup^.Type

                        TlInsertAtTailList (
                            &lnkextern^.Library^.FixupListHead, // head
                            &lnkreloc^.Entry, // entry
                        )
                    END

                ELSE
                    // Case 3: Not resolved. Insert in unresolved fixup list.

                    status = TlBumpAlloc (
                        SIZEOF LnkRelocation, // bytes
                        OUT lnkreloc, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate relocation", 0, 0, 0 )
                    END

                    lnkreloc^.Extern = lnkextern

                    lnkreloc^.SectionOffset =
                        section^.VirtualAddress + fixup^.SectionOffset

                    lnkreloc^.Section = lnksection

                    lnkreloc^.Type = fixup^.Type

                    TlInsertAtTailList (
                        &LnkUnresolvedFixupList, // head
                        &lnkreloc^.Entry, // entry
                    )
                END
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkDieCuzOfUnresolvedExterns ()

    // Print all of the unresolved symbols and die.

    TlPrintString ( "Failed to resolve the following externs:\n" )

    listhead := &LnkExternTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnkextern := CONTAINEROF listentry TO LnkExtern.Entry.OrderedEntry

        IF NOT lnkextern^.Library THEN
            TlPrintString ( " " )
            TlPrintString ( lnkextern^.SourceObject^.Path )
            TlPrintString ( ": " )
            TlPrintString ( lnkextern^.Entry.Key )
            TlPrintString ( "\n" )
        END

        listentry = listentry^.Next
    END

    TlErrorExit ()
END

FN LnkAssignSectionBases (
    IN base : UWORD,
)

    // Assign a simple consecutive base to each section.

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        lnksection^.VirtualAddress = base

        base += (lnksection^.Size + lnksection^.DynamicData.Count)

        listentry = listentry^.Next
    END
END

FN LnkAssignMappedBases (
    IN base : UWORD,
)

    // Assign a page-aligned mapped base to each section.
    //
    // Following this relocation, the sections can be mapped rounded down to the
    // previous page size, for a length up to the following page size, without
    // having to be physically page aligned within the file, which saves a lot
    // of bytes on disk (especially on Aphelion... 16K pages!)
    //
    // Note that this does require that the zeroed bss sections are all placed
    // at the end.

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    sawbss := FALSE

    base += LnkHeadLength & LnkArchitecturePageMask

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        IF lnksection^.Flags & XLO_SECTION_ZERO THEN
            // We can reset the alignment for bss.

            base &= ~LnkArchitecturePageMask

            sawbss = TRUE
        
        ELSEIF sawbss THEN
            TlPrintString (
                "mappedbase requires BSS sections to be at the end\n" )

            TlErrorExit ()
        END

        lnksection^.VirtualAddress = base

        base += (lnksection^.Size + lnksection^.DynamicData.Count)

        IF base & LnkArchitecturePageMask THEN
            base += (LnkArchitecturePageMask + 1)
        END

        listentry = listentry^.Next
    END
END

LnkSectionName : UBYTE[256]
LnkExprStr : UBYTE[256]
LnkAtomStr : UBYTE[256]

FN LnkEvaluateExpr ()

    // Evaluate a component of the move expression of the following form:
    //
    // atom+atom+atom+...
    //
    // An atom can either be a constant number, or one of the following:
    //
    // [section name]: The base of a section.
    // @[section name]: The end of a section.
    // #[section name]: The size of a section.
    // %: Alignment to a page size.

    lnksection := CAST TlLookupHashTable (
        &LnkSectionTable, // hashtable
        &LnkSectionName[0], // key
    ) TO ^LnkSection

    IF NOT lnksection THEN
        TlPrintString ( "move: " )
        TlPrintString ( &LnkSectionName[0] )
        TlPrintString ( ": no such section\n" )

        TlErrorExit ()
    END

    expr := &LnkExprStr[0]
    pen := 0
    base := 0
    atomstr := &LnkAtomStr[0]

    WHILE TRUE DO
        IF expr^ == '+' OR expr^ == 0 THEN
            atomstr[pen] = 0

            refsection : ^LnkSection

            IF atomstr[0] >= '0' AND atomstr[0] <= '9' THEN
                // Constant value.

                val : UWORD

                IF NOT TlStringToNumber (
                    atomstr, // src
                    256, // bufsize
                    OUT val, // num
                ) THEN
                    TlPrintString ( "Move expression syntax error\n" )

                    TlErrorExit ()
                END

                base += val

            ELSEIF atomstr[0] == '@' THEN
                // The end of a section.

                refsection = CAST TlLookupHashTable (
                    &LnkSectionTable, // hashtable
                    &atomstr[1], // key
                ) TO ^LnkSection

                IF NOT refsection THEN
                    TlPrintString ( "move: " )
                    TlPrintString ( &atomstr[1] )
                    TlPrintString ( ": no such section\n" )

                    TlErrorExit ()
                END

                base += (refsection^.VirtualAddress +
                    refsection^.Size + refsection^.DynamicData.Count)

            ELSEIF atomstr[0] == '#' THEN
                // The size of a section.

                refsection = CAST TlLookupHashTable (
                    &LnkSectionTable, // hashtable
                    &atomstr[1], // key
                ) TO ^LnkSection

                IF NOT refsection THEN
                    TlPrintString ( "move: " )
                    TlPrintString ( &atomstr[1] )
                    TlPrintString ( ": no such section\n" )

                    TlErrorExit ()
                END

                base += (refsection^.Size + refsection^.DynamicData.Count)

            ELSEIF atomstr[0] == '%' AND atomstr[1] == 0 THEN
                // Alignment to page size.

                base += LnkArchitecturePageMask
                base &= ~LnkArchitecturePageMask

            ELSE
                // The base of a section.

                refsection = CAST TlLookupHashTable (
                    &LnkSectionTable, // hashtable
                    atomstr, // key
                ) TO ^LnkSection

                IF NOT refsection THEN
                    TlPrintString ( "move: " )
                    TlPrintString ( atomstr )
                    TlPrintString ( ": no such section\n" )

                    TlErrorExit ()
                END

                base += refsection^.VirtualAddress
            END

            pen = 0

            IF expr^ == 0 THEN
                BREAK
            END

        ELSE
            IF pen >= 255 THEN
                TlPrintString ( "Move expression atom too long\n" )

                TlErrorExit ()
            END

            atomstr[pen] = expr^

            pen += 1
        END

        expr += 1
    END

    lnksection^.VirtualAddress = base
END

FN LnkEvaluateMoveExpression (
    IN expr : ^UBYTE,
)

    // Evaluate the "move expression", which is a string of the following form:
    //
    // [section name]=expr,[section name]=expr,...

    collectingsection := TRUE
    pen := 0

    WHILE TRUE DO
        IF expr^ == ',' OR expr^ == 0 THEN
            IF collectingsection THEN
                TlPrintString ( "Move expression syntax error\n" )

                TlErrorExit ()
            END

            LnkExprStr[pen] = 0

            LnkEvaluateExpr ()

            collectingsection = TRUE

            pen = 0

            IF expr^ == 0 THEN
                BREAK
            END

        ELSEIF expr^ == '=' THEN
            IF NOT collectingsection THEN
                TlPrintString ( "Move expression syntax error\n" )

                TlErrorExit ()
            END

            LnkSectionName[pen] = 0

            collectingsection = FALSE

            pen = 0

        ELSE
            IF pen >= 255 THEN
                TlPrintString ( "Move expression string too long\n" )

                TlErrorExit ()
            END

            IF collectingsection THEN
                LnkSectionName[pen] = expr^

            ELSE
                LnkExprStr[pen] = expr^
            END

            pen += 1
        END

        expr += 1
    END
END

FN LnkPerformRelocations ()

    // Perform the final section relocations before emission.

    IF LnkBaseAddress THEN
        // A simple base address was provided.

        LnkAssignSectionBases ( LnkBaseAddress )

    ELSEIF LnkMappedBase THEN
        // A mappedbase was provided.

        LnkAssignMappedBases ( LnkMappedBase )

    ELSEIF LnkMoveExpression THEN
        // A move expression was provided.

        LnkEvaluateMoveExpression ( LnkMoveExpression )

    ELSE
        LEAVE
    END

    // Now iterate the relocation tables for each section and perform the
    // relocations to move them to their base address.

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        relochead := &lnksection^.RelocationListHead
        relocentry := relochead^.Next

        WHILE relocentry != relochead DO
            lnkreloc := CONTAINEROF relocentry TO LnkRelocation.Entry

            LnkPerformRelocationTable[lnkreloc^.Type] (
                lnkreloc^.Section^.Data + lnkreloc^.SectionOffset, // ptr
                lnksection^.VirtualAddress, // value
            )

            relocentry = relocentry^.Next
        END

        listentry = listentry^.Next
    END

    // Now perform all of the special relocations which could not have been done
    // earlier since we didn't understand how the sections would be laid out
    // yet.

    listhead = &LnkSpecialRelocationList
    listentry = listhead^.Next

    WHILE listentry != listhead DO
        lnkreloc := CONTAINEROF listentry TO LnkRelocation.Entry

        symbol := CAST lnkreloc^.Extern TO ^LnkSymbol

        value : UWORD

        IF symbol^.SectionOffset == LNK_SYMBOL_BASE THEN
            value = symbol^.Section^.VirtualAddress

        ELSEIF symbol^.SectionOffset == LNK_SYMBOL_SIZE THEN
            value = symbol^.Section^.Size + symbol^.Section^.DynamicData.Count

        ELSEIF symbol^.SectionOffset == LNK_SYMBOL_END THEN
            value = symbol^.Section^.VirtualAddress +
                symbol^.Section^.Size + symbol^.Section^.DynamicData.Count
        END

        LnkPerformRelocationTable[lnkreloc^.Type] (
            lnkreloc^.Section^.Data + lnkreloc^.SectionOffset, // ptr
            value, // value
        )

        listentry = listentry^.Next
    END
END

FN LnkOutputBinary ()

    // Output a flat binary file.

    // First perform the final section relocations.

    LnkPerformRelocations ()

    // Now dump the sections in sequence to the file.

    handle : ^VOID

    status := TlOpenDestination (
        LnkOutputName, // filename
        OUT handle, // handle
    )

    IF status THEN
        TlPrintString ( LnkOutputName )
        TlPrintString ( ": failed to open\n" )

        TlErrorExit ()
    END

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        IF NOT (lnksection^.Flags & XLO_SECTION_ZERO) THEN
            IF lnksection^.Size THEN
                TlWriteFile (
                    handle, // handle
                    lnksection^.Size, // bytes
                    lnksection^.Data, // buffer
                )
            END

            IF lnksection^.DynamicData.Count THEN
                TlWriteFile (
                    handle, // handle
                    lnksection^.DynamicData.Count, // bytes
                    lnksection^.DynamicData.Buffer, // buffer
                )
            END
        END

        listentry = listentry^.Next
    END

    TlClose ( handle )
END

FN LnkOutputXlo ()

    // Output an XLO executable.


END

FN LnkLinkObject ()

    // Link the final object.

    LnkAllocateStorage ()

    LnkMergeSections ()

    LnkCreateSpecialSymbols ()

    LnkMergeSymbolTables ()

    LnkResolveExterns ()

    LnkBindExports ()

    IF LnkUnresolvedCount AND NOT LnkCreateFragment THEN
        LnkDieCuzOfUnresolvedExterns ()
    END

    LnkResolveFixupTable ()

    IF LnkCreateBin THEN
        LnkOutputBinary ()

        LEAVE
    END

    LnkOutputXlo ()
END

FN LnkInitializeDatabase ()

    // Initialize the linker database.

    TlInitializeList ( &LnkObjectListHead )

    TlInitializeList ( &LnkLibListHead )

    TlInitializeList ( &LnkUnresolvedFixupList )

    TlInitializeList ( &LnkSpecialRelocationList )

    TlInitializeHashTable ( &LnkSectionTable )

    TlInitializeHashTable ( &LnkSymbolTable )

    TlInitializeHashTable ( &LnkExternTable )
END