//
// Link stuff.
//

#INCLUDE "<inc>/Linker.hjk"
#INCLUDE "../../Rtl/Xlo/XloRelocations.jkl"

#IF ( == BLD_BITS 32 )

#MACRO LnkEncodeExternLink ( extern, ptr ) [
    extern^.Padding2 = CAST ptr TO UWORD
]

#MACRO LnkFetchExternLinkToSymbol ( extern ) [
    CAST extern^.Padding2 TO ^LnkSymbol
]

#MACRO LnkFetchExternLinkToExtern ( extern ) [
    CAST extern^.Padding2 TO ^LnkExtern
]

#ELSE

// This is necessary since the extern table entries are not necessarily UQUAD
// aligned, and we will run on 64-bit architectures w/ alignment restrictions
// (such as Aphelion).

#MACRO LnkEncodeExternLink ( extern, ptr ) [
    extern^.Padding2 = (CAST ptr TO UWORD) & 0xFFFFFFFF
    extern^.Padding3 = (CAST ptr TO UWORD) >> 32
]

#MACRO LnkFetchExternLinkToSymbol ( extern ) [
    CAST extern^.Padding2 | (extern^.Padding3 << 32) TO ^LnkSymbol
]

#MACRO LnkFetchExternLinkToExtern ( extern ) [
    CAST extern^.Padding2 | (extern^.Padding3 << 32) TO ^LnkExtern
]

#END

LnkObjectListHead : TlListEntry
LnkLibListHead : TlListEntry
LnkUnresolvedFixupList : TlListEntry
LnkSpecialRelocationList : TlListEntry
LnkSectionTable : TlHashTable
LnkSymbolTable : TlHashTable
LnkExternTable : TlHashTable
LnkJumpStubSection : ^LnkSection
LnkAccumulateZeroSection : ^LnkSection
LnkAccumulatePagedZeroSection : ^LnkSection

LnkSectionCount := 0
LnkSymbolCount := 0
LnkExternCount := 0
LnkUnresolvedCount := 0
LnkHeadLength := 0
LnkLibraryCount := 0
LnkUnresolvedFixupCount := 0

LnkIndexedSectionArray : ^LnkSection[256]

#MACRO LnkFileAlign ( x ) [
    (((x) + LnkObjectFileAlignmentMask) & ~LnkObjectFileAlignmentMask)
]

STRUCT LnkObject
    Entry : TlListEntry,

    Path : ^UBYTE,
    Data : ^UBYTE,
END

STRUCT LnkLibrary
    Entry : TlListEntry,

    RuntimePath : ^UBYTE,
    Path : ^UBYTE,
    Data : ^UBYTE,

    FixupTable : ^XloImportFixupEntry,

    FixupListHead : TlListEntry,
    FixupCount : UWORD,
    Index : UWORD,
END

STRUCT LnkSection
    Entry : TlHashTableEntry,

    RelocationListHead : TlListEntry,
    RelocationCount : UWORD,

    RelocationTable : ^XloRelocEntry,

    RolledInto : ^LnkSection,
    RolledAt : UWORD,

    VirtualAddress : UWORD,
    Size : UWORD,
    VirtualSize : UWORD,
    Flags : UWORD,
    Index : UWORD,
    FinalIndex : UWORD,
    Pen : UWORD,

    Data : ^UBYTE,
    DynamicData : TlDynamicBuffer,
END

STRUCT LnkRelocation
    Entry : TlListEntry,

    Section : ^LnkSection,
    SectionOffset : UWORD,
    Type : UWORD,
    Extern : ^LnkExtern,
    OriginalValue : ULONG,
END

#DEFINE LNK_SYMBOL_BASE 1
#DEFINE LNK_SYMBOL_SIZE 2
#DEFINE LNK_SYMBOL_END 3

STRUCT LnkSymbol
    Entry : TlHashTableEntry,

    Section : ^LnkSection,
    SectionOffset : UWORD,
    Type : UWORD,

    SourceObject : ^LnkObject,
END

STRUCT LnkExtern
    Entry : TlHashTableEntry,

    SourceObject : ^LnkObject,

    Library : ^LnkLibrary,
    Symbol : ^XloSymbolEntry,
    Address : UWORD,

    Index : UWORD,

    JumpStubOffset : UWORD,

    HasJumpStub : UBYTE,
END

FN LnkFindSection (
    IN name : ^UBYTE,
    IN flags : UWORD,
    IN objectname : ^UBYTE,
) : ^LnkSection

    // Find or create a matching section.

    created : UBYTE

    section := CAST TlLookupOrAllocateEntryHashTable (
        &LnkSectionTable, // hashtable
        SIZEOF LnkSection, // entrysize
        name, // key
        OUT created, // created
    ) TO ^LnkSection

    IF created THEN
        // Initialize the section structure.

        IF LnkSectionCount == 256 THEN
            TlError ( "%s: %s: Maximum section count exceeded\n",
                objectname, name )
        END

        section^.Size = 0
        section^.VirtualSize = 0
        section^.Flags = flags
        section^.Index = LnkSectionCount
        section^.FinalIndex = 0
        section^.Pen = 0
        section^.Data = NULLPTR
        section^.VirtualAddress = 0
        section^.RelocationCount = 0
        section^.RolledInto = NULLPTR
        section^.RolledAt = 0

        TlInitializeList ( &section^.RelocationListHead )

        // Note that the DynamicData mechanism for appending bytes to the end
        // of a section !! ONLY !! works for code sections, since ZERO sections
        // are destroyed and data sections end up having the ZERO sections
        // tacked on the end, which is currently incompatible with this
        // mechanism.

        TlInitializeDynamicBuffer ( &section^.DynamicData )

        LnkIndexedSectionArray[LnkSectionCount] = section
    
        LnkSectionCount += 1

        IF NOT LnkJumpStubSection AND flags & XLO_SECTION_CODE THEN
            // The first code section found is used as the stub section.

            LnkJumpStubSection = section

        ELSEIF NOT LnkAccumulateZeroSection AND
            flags & (XLO_SECTION_CODE | XLO_SECTION_MAP |
            XLO_SECTION_ZERO | XLO_SECTION_PAGED) == XLO_SECTION_MAP THEN

            // The first data section found is the one we accumulate all of the
            // zero sections onto in the final executable.

            LnkAccumulateZeroSection = section

        ELSEIF NOT LnkAccumulatePagedZeroSection AND
            flags & (XLO_SECTION_CODE | XLO_SECTION_MAP |
            XLO_SECTION_ZERO | XLO_SECTION_PAGED) ==
            (XLO_SECTION_MAP | XLO_SECTION_PAGED) THEN

            LnkAccumulatePagedZeroSection = section
        END

    ELSE
        // Check that the section matches.

        IF flags != section^.Flags THEN
            TlError ( "%s: Mismatched section '%s'\n", objectname, name )
        END
    END

    RETURN section
END

FN LnkAddStaticObject (
    IN filename : ^UBYTE,
)

    // Allocate an object block.
    // N.B. filename must be in permanent memory.

    object : ^LnkObject

    status := TlBumpAlloc (
        SIZEOF LnkObject, // bytes
        OUT object, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate object block", 0, 0, 0 )
    END

    // Load the static object.

    object^.Data = LnkLoadXloFile ( filename )
    object^.Path = filename

    // Sanity check the header.

    header := CAST object^.Data TO ^XloHeader

    IF NOT (header^.Flags & XLO_FILE_FRAGMENT) THEN
        TlError ( "%s: Can't link non-fragment objects\n", filename )
    END

    // Insert in list.

    TlInsertAtTailList (
        &LnkObjectListHead, // head
        &object^.Entry, // entry
    )
END

FN LnkAddDynamicObject (
    IN filename : ^UBYTE,
)

    // Allocate a library block.
    // N.B. filename must be in permanent memory.

    library : ^LnkLibrary

    status := TlBumpAlloc (
        SIZEOF LnkLibrary, // bytes
        OUT library, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate library block", 0, 0, 0 )
    END

    // Libraries have a link time and runtime path, separated by a colon:
    //
    // [runtime]:[link time]
    //
    // The link time path is used to locate the dynamic library to bind with.
    // The runtime path is used by the dynamic linker at load time to find the
    // dynamic library in the system.
    //
    // If there is no colon, the runtime path is the final component of the
    // link time path. Lets find out.

    i := 0

    WHILE TRUE DO
        IF filename[i] == ':' THEN
            filename[i] = 0

            library^.Path = &filename[i + 1]
            library^.RuntimePath = &filename[0]

            BREAK

        ELSEIF filename[i] == 0 THEN
            library^.Path = filename
            library^.RuntimePath = TlGetFileName ( filename )
        END

        i += 1
    END

    // Load the dynamic library.

    library^.Data = LnkLoadXloFile ( library^.Path )

    library^.FixupCount = 0
    library^.Index = LnkLibraryCount

    TlInitializeList ( &library^.FixupListHead )

    // Sanity check the header.

    header := CAST library^.Data TO ^XloHeader

    IF header^.Flags & XLO_FILE_FRAGMENT THEN
        TlError ( "%s: Can't dynamically link against fragment\n", filename )
    END

    LnkLibraryCount += 1

    // Insert in list.

    TlInsertAtTailList (
        &LnkLibListHead, // head
        &library^.Entry, // entry
    )
END

LnkCreateJumpStub : UBYTE[XLO_RELOC_MAX] = {
    [XLO_RELOC_XR17032_ABSJ] = TRUE,
    [XLO_RELOC_FOX32_CALL] = TRUE,
}

FN LnkRelocateInternalSection (
    IN section : ^XloSectionHeader,
    IN sectiontable : ^XloSectionHeader,
    IN base : ^VOID,
    IN offset : UWORD,
)

    // Relocate a section by the provided offset.

    reloc := CAST base + section^.RelocTableOffset TO ^XloRelocEntry
    count := section^.RelocCount

    WHILE count DO
        targetsection := &sectiontable[reloc^.SectionIndex]

        XloPerformRelocationTable[reloc^.Type] (
            base + targetsection^.FileOffset + reloc^.SectionOffset, // ptr
            offset, // value
            LnkArchitectureInTokyo, // bits
            FALSE, // absolute
        )

        count -= 1
        reloc += SIZEOF XloRelocEntry
    END
END

FN LnkAllocateStorage ()

    // Allocate storage for each of the sections in each of the objects.
    // We also relocate the section by its offset.

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeader

        sectiontable :=
            CAST header + header^.SectionTableOffset TO ^XloSectionHeader

        stringtable := CAST header + header^.StringTableOffset TO ^UBYTE

        i := 0

        WHILE i < header^.SectionCount DO
            section := &sectiontable[i]
            sectionname := stringtable + section^.NameOffset

            IF section^.VirtualAddress != 0 THEN
                TlError ( "%s: Section with non-zero base '%s'\n",
                    object^.Path, sectionname )
            END

            // Find the final section.

            lnksection := LnkFindSection (
                sectionname, // name
                section^.Flags, // flags
                object^.Path, // objectname
            )

            // Cache the index of the final section.

            section^.NameOffset = lnksection^.Index

            // Stash the offset of this section from the base of the matching
            // final section in the VirtualAddress field of its header.

            section^.VirtualAddress = lnksection^.VirtualSize

            // Increment the size of the final section.

            lnksection^.Size += section^.DataLength
            lnksection^.VirtualSize += section^.VirtualLength

            // Run down the relocation table to offset all references to
            // this section by the byte count we've determined.
            // Don't bother if the offset is zero.

            IF section^.VirtualAddress THEN
                LnkRelocateInternalSection (
                    section, // section
                    sectiontable, // sectiontable
                    header, // base
                    section^.VirtualAddress, // offset
                )
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkMergeSections ()

    // Merge the relocation tables and contents of the sections.

    status : TlStatus

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeader

        sectiontable :=
            CAST header + header^.SectionTableOffset TO ^XloSectionHeader

        i := 0

        WHILE i < header^.SectionCount DO
            section := &sectiontable[i]

            // Find the final section using the cached index.

            lnksection := LnkIndexedSectionArray[section^.NameOffset]

            IF NOT (lnksection^.Flags & XLO_SECTION_ZERO) THEN
                IF NOT lnksection^.Data AND lnksection^.Size THEN
                    // We need to allocate the data buffer.

                    status = TlBumpAlloc (
                        lnksection^.Size, // bytes
                        OUT lnksection^.Data, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate section contents", 0, 0, 0 )
                    END
                END

                IF section^.DataLength THEN
                    // Copy our data into the final section.

                    TlCopyMemory (
                        lnksection^.Data + lnksection^.Pen, // dest
                        header + section^.FileOffset, // src
                        section^.DataLength, // sz
                    )

                    lnksection^.Pen += section^.DataLength
                END
            END

            IF section^.RelocCount THEN
                // Copy our relocations into the final section.

                reloctable :=
                    CAST header + section^.RelocTableOffset TO ^XloRelocEntry

                j := 0

                WHILE j < section^.RelocCount DO
                    reloc := &reloctable[j]

                    lnkreloc : ^LnkRelocation

                    status = TlBumpAlloc (
                        SIZEOF LnkRelocation, // bytes
                        OUT lnkreloc, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate relocation", 0, 0, 0 )
                    END

                    // Create the relocation structure.

                    targetsection := &sectiontable[reloc^.SectionIndex]

                    // Make sure to increment the offset by the offset of the
                    // target section from the base of the final section.

                    lnkreloc^.SectionOffset =
                        reloc^.SectionOffset + targetsection^.VirtualAddress

                    // Store a pointer to the final section.

                    lnkreloc^.Section =
                        LnkIndexedSectionArray[targetsection^.NameOffset]

                    // Copy the relocation type.

                    lnkreloc^.Type = reloc^.Type

                    // Insert in the final section's relocation list.

                    TlInsertAtTailList (
                        &lnksection^.RelocationListHead, // head
                        &lnkreloc^.Entry, // entry
                    )

                    lnksection^.RelocationCount += 1

                    j += 1
                END
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkRemoveZeroSections ()

    // Remove the ZERO sections (like bss) by stacking them onto a single data
    // section.

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        zeropaged := lnksection^.Flags & (XLO_SECTION_ZERO | XLO_SECTION_PAGED)

        rollsection : ^LnkSection = NULLPTR

        IF zeropaged == XLO_SECTION_ZERO THEN
            // Roll it into the nonpaged data section.

            rollsection = LnkAccumulateZeroSection
        
        ELSEIF zeropaged == (XLO_SECTION_ZERO | XLO_SECTION_PAGED) THEN
            // Roll it into the paged data section.

            rollsection = LnkAccumulatePagedZeroSection
        END

        IF rollsection THEN
            // Relocate the ZERO section by the current virtual size of the
            // rollsection, and move each relocation into the list for the
            // rollsection.

            lnksection^.RolledInto = rollsection
            lnksection^.RolledAt = rollsection^.VirtualSize

            relochead := &lnksection^.RelocationListHead
            relocentry := relochead^.Next

            WHILE relocentry != relochead DO
                lnkreloc := CONTAINEROF relocentry TO LnkRelocation.Entry

                XloPerformRelocationTable[lnkreloc^.Type] (
                    lnkreloc^.Section^.Data + lnkreloc^.SectionOffset, // ptr
                    rollsection^.VirtualSize, // value
                    LnkArchitectureInTokyo, // bits
                    FALSE, // absolute
                )

                // Capture the next entry first since we're about to manipulate
                // the list links.

                relocentry = relocentry^.Next

                // Move the relocation to the data section's list.

                TlRemoveEntryList ( &lnkreloc^.Entry )

                TlInsertAtTailList (
                    &rollsection^.RelocationListHead, // head
                    &lnkreloc^.Entry, // entry
                )

                lnksection^.RelocationCount -= 1
                rollsection^.RelocationCount += 1
            END

            // Increment the virtual size of the rollsection.

            rollsection^.VirtualSize += lnksection^.VirtualSize

            // Remove this ZERO section from the list.

            LnkSectionCount -= 1
            TlRemoveHashTable ( &lnksection^.Entry )
        END

        listentry = listentry^.Next
    END
END

FN LnkCreateSpecialSymbol (
    IN section : ^LnkSection,
    IN name : ^UBYTE,
    IN type : UWORD,
)

    // Helper function to create a special symbol.

    lnksymbol : ^LnkSymbol

    status := TlBumpAlloc (
        SIZEOF LnkSymbol, // bytes
        OUT lnksymbol, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate special symbol", 0, 0, 0 )
    END

    lnksymbol^.SourceObject =
        CONTAINEROF LnkObjectListHead.Next TO LnkObject.Entry
    
    lnksymbol^.Section = section

    lnksymbol^.SectionOffset = type

    lnksymbol^.Type = XLO_SYMBOL_SPECIAL

    TlInsertHashTable (
        &LnkSymbolTable, // hashtable
        &lnksymbol^.Entry, // entry
        name, // key
    )
END

FN LnkCreateSpecialSymbols ()
    
    // Create special symbols for each section.
    // These consist of:
    //
    // _[section]: The base of the section.
    // _[section]_size: The size of the section.
    // _[section]_end: The end of the section.

    symnamearray : ^TlDynamicBuffer

    status := TlBumpAlloc (
        SIZEOF TlDynamicBuffer, // bytes
        OUT symnamearray, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate special sym names", 0, 0, 0 )
    END

    TlInitializeDynamicBuffer ( symnamearray )

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        sectionname := lnksection^.Entry.Key
        sectionnamelen := TlMeasureString ( sectionname )

        TlInsertDynamicBuffer (
            symnamearray, // array
            '_', // byte
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            sectionname, // srcbuf
            sectionnamelen, // length
        )

        TlInsertDynamicBuffer (
            symnamearray, // array
            0, // byte
        )

        basename :=
            &symnamearray^.Buffer[symnamearray^.Count - sectionnamelen - 2]

        TlInsertDynamicBuffer (
            symnamearray, // array
            '_', // byte
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            sectionname, // srcbuf
            sectionnamelen, // length
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            "_size", // srcbuf
            6, // length (plus null terminator)
        )

        sizename :=
            &symnamearray^.Buffer[symnamearray^.Count - sectionnamelen - 7]

        TlInsertDynamicBuffer (
            symnamearray, // array
            '_', // byte
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            sectionname, // srcbuf
            sectionnamelen, // length
        )

        TlCopyIntoDynamicBuffer (
            symnamearray, // array
            "_end", // srcbuf
            5, // length (plus null terminator)
        )

        endname :=
            &symnamearray^.Buffer[symnamearray^.Count - sectionnamelen - 6]

        LnkCreateSpecialSymbol (
            lnksection, // section
            basename, // name
            LNK_SYMBOL_BASE, // type
        )

        LnkCreateSpecialSymbol (
            lnksection, // section
            sizename, // name
            LNK_SYMBOL_SIZE, // type
        )

        LnkCreateSpecialSymbol (
            lnksection, // section
            endname, // name
            LNK_SYMBOL_END, // type
        )

        listentry = listentry^.Next
    END
END

FN LnkMergeSymbolTables ()

    // Merge the symbol tables together.

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeader

        symboltable :=
            CAST header + header^.SymbolTableOffset TO ^XloSymbolEntry

        sectiontable :=
            CAST header + header^.SectionTableOffset TO ^XloSectionHeader

        stringtable := CAST header + header^.StringTableOffset TO ^UBYTE

        i := 0

        WHILE i < header^.SymbolCount DO
            symbol := &symboltable[i]

            section := &sectiontable[symbol^.SectionIndex]

            created : UBYTE

            lnksymbol := CAST TlLookupOrAllocateEntryHashTable (
                &LnkSymbolTable, // hashtable
                SIZEOF LnkSymbol, // entrysize
                stringtable + symbol^.NameOffset, // key
                OUT created, // created
            ) TO ^LnkSymbol

            IF NOT created THEN
                // There's a symbol collision!

                TlError ( "Symbol '%s' defined in both:\n %s\n %s\n",
                    stringtable + symbol^.NameOffset,
                    lnksymbol^.SourceObject^.Path,
                    object^.Path )
            END

            // Initialize the symbol structure.

            lnksymbol^.SourceObject = object
            
            lnksection := LnkIndexedSectionArray[section^.NameOffset]

            rolledat := 0

            IF lnksection^.RolledInto THEN
                rolledat = lnksection^.RolledAt
                lnksection = lnksection^.RolledInto
            END

            lnksymbol^.Section = lnksection
            
            // Make sure the symbol value is offset by the offset of the
            // original section, which has been stashed in the VirtualAddress
            // field of the original section header.
            //
            // If it pointed into a ZERO section which has been rolled into a
            // data section, the offset of that must be added as well.

            lnksymbol^.SectionOffset =
                symbol^.SectionOffset + section^.VirtualAddress + rolledat

            lnksymbol^.Type = symbol^.Type

            IF symbol^.Type == XLO_SYMBOL_EXPORT OR
                LnkKeepGlobals OR LnkCreateFragment THEN

                LnkSymbolCount += 1
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkResolveExterns ()

    // Resolve the outstanding externs for each object file.

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeader

        externtable :=
            CAST header + header^.ExternTableOffset TO ^XloExternEntry

        stringtable := CAST header + header^.StringTableOffset TO ^UBYTE

        i := 0

        WHILE i < header^.ExternCount DO
            extern := &externtable[i]

            // Look up the extern's name in the combined symbol table.

            symbol := CAST TlLookupHashTable (
                &LnkSymbolTable, // hashtable
                stringtable + extern^.NameOffset, // key
            ) TO ^LnkSymbol

            IF symbol THEN
                // Resolved! Record that.

                extern^.Type = XLO_EXTERN_RESOLVED

                LnkEncodeExternLink ( extern, symbol )

            ELSE
                // Not resolved (yet). Place into the global extern hash table.

                created : UBYTE

                lnkextern := CAST TlLookupOrAllocateEntryHashTable (
                    &LnkExternTable, // hashtable
                    SIZEOF LnkExtern, // entrysize
                    stringtable + extern^.NameOffset, // key
                    OUT created, // created
                ) TO ^LnkExtern

                IF created THEN
                    // Initialize.

                    lnkextern^.SourceObject = object
                    lnkextern^.Library = NULLPTR
                    lnkextern^.Symbol = NULLPTR
                    lnkextern^.HasJumpStub = FALSE
                    lnkextern^.Index = LnkExternCount

                    IF LnkExternCount == 0xFFFF THEN
                        TlError ( "Maximum extern count (65536) exceeded\n" )
                    END

                    LnkExternCount += 1
                    LnkUnresolvedCount += 1
                END

                LnkEncodeExternLink ( extern, lnkextern )
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkBindExports ()

    // Bind the exported symbols of the dynamic libraries to any relevant
    // outstanding externs.

    listhead := &LnkLibListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        library := CONTAINEROF listentry TO LnkLibrary.Entry
        
        header := CAST library^.Data TO ^XloHeader

        symboltable :=
            CAST header + header^.SymbolTableOffset TO ^XloSymbolEntry

        stringtable := CAST header + header^.StringTableOffset TO ^UBYTE

        sectiontable :=
            CAST header + header^.SectionTableOffset TO ^XloSectionHeader

        i := 0

        WHILE i < header^.SymbolCount DO
            symbol := &symboltable[i]
            section := &sectiontable[symbol^.SectionIndex]

            IF symbol^.Type == XLO_SYMBOL_EXPORT THEN
                // Look it up in the extern hash table.

                lnkextern := CAST TlLookupHashTable (
                    &LnkExternTable, // hashtable
                    stringtable + symbol^.NameOffset, // key
                ) TO ^LnkExtern

                IF lnkextern AND NOT lnkextern^.Library THEN
                    // Woo! Got one.

                    lnkextern^.Library = library
                    
                    lnkextern^.Symbol = symbol
                    
                    lnkextern^.Address =
                        section^.VirtualAddress + symbol^.SectionOffset

                    LnkUnresolvedCount -= 1
                END
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FNPTR LnkCreateStubF (
    IN lnkextern : ^LnkExtern,
)

FN (LnkCreateStubF) LnkCreateXr17032Stub (
    IN lnkextern : ^LnkExtern,
)

    // Create a jump stub for XR/17032.
    // This is just a single  J [ADDR]  instruction appended to the end of the
    // jump stub section.

    inst : ULONG[1]

    inst[0] = 0x6 // J opcode
    inst[0] |= (lnkextern^.Address >> 2) << 3

    TlCopyIntoDynamicBuffer (
        &LnkJumpStubSection^.DynamicData, // array
        &inst[0], // srcbuf
        4, // length
    )

    // Create the import fixup that fixes up the jump stub if the dynamic
    // library is relocated.

    lnkreloc : ^LnkRelocation

    status := TlBumpAlloc (
        SIZEOF LnkRelocation, // bytes
        OUT lnkreloc, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate relocation", 0, 0, 0 )
    END

    lnkreloc^.Extern = lnkextern

    lnkreloc^.SectionOffset = lnkextern^.JumpStubOffset

    lnkreloc^.Section = LnkJumpStubSection

    lnkreloc^.Type = XLO_RELOC_XR17032_ABSJ

    lnkreloc^.OriginalValue = 0

    TlInsertAtTailList (
        &lnkextern^.Library^.FixupListHead, // head
        &lnkreloc^.Entry, // entry
    )

    lnkextern^.Library^.FixupCount += 1
END

FN (LnkCreateStubF) LnkCreateFox32Stub (
    IN lnkextern : ^LnkExtern,
)

    // Create a jump stub for fox32.
    // This is just a single  JMP [ADDR]  instruction appended to the end of the
    // jump stub section.

    op : UINT[1]
    op[0] = 0x8802

    addr : ULONG[1]
    addr[0] = lnkextern^.Address

    TlCopyIntoDynamicBuffer (
        &LnkJumpStubSection^.DynamicData, // array
        &op[0], // srcbuf
        2, // length
    )

    TlCopyIntoDynamicBuffer (
        &LnkJumpStubSection^.DynamicData, // array
        &addr[0], // srcbuf
        4, // length
    )

    // Create the import fixup that fixes up the jump stub if the dynamic
    // library is relocated.

    lnkreloc : ^LnkRelocation

    status := TlBumpAlloc (
        SIZEOF LnkRelocation, // bytes
        OUT lnkreloc, // ptr
    )

    IF status THEN
        TlInternalError ( "Failed to allocate relocation", 0, 0, 0 )
    END

    lnkreloc^.Extern = lnkextern

    lnkreloc^.SectionOffset = lnkextern^.JumpStubOffset + 2

    lnkreloc^.Section = LnkJumpStubSection

    lnkreloc^.Type = XLO_RELOC_PTR

    lnkreloc^.OriginalValue = 0

    TlInsertAtTailList (
        &lnkextern^.Library^.FixupListHead, // head
        &lnkreloc^.Entry, // entry
    )

    lnkextern^.Library^.FixupCount += 1
END

LnkCreateStubTable : LnkCreateStubF[XLO_ARCHITECTURE_MAX] = {
    [XLO_ARCHITECTURE_XR17032] = &LnkCreateXr17032Stub,
    [XLO_ARCHITECTURE_FOX32] = &LnkCreateFox32Stub,
}

FN LnkResolveFixupTable ()

    // For each object, we now need to iterate its unresolved fixup table and
    // figure out the nature of each fixup.
    //
    // 1. If it pointed to an extern that we resolved "internally", we have to
    //    perform the relocation to replace the placeholder zeroes with the
    //    address of the symbol it was resolved to. We then need to create a new
    //    relocation for that.
    //
    // 2. If it pointed to an extern that we resolved "externally", i.e. in a
    //    dynamic library, we have to create an import fixup for placement in
    //    the library import's fixup table.
    //
    // 3. If it was unresolved, just place it in an unresolved fixup list.

    status : TlStatus

    lnkreloc : ^LnkRelocation

    listhead := &LnkObjectListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        object := CONTAINEROF listentry TO LnkObject.Entry
        
        header := CAST object^.Data TO ^XloHeaderExtended

        externtable :=
            CAST header + header^.Hdr.ExternTableOffset TO ^XloExternEntry

        stringtable := CAST header + header^.Hdr.StringTableOffset TO ^UBYTE

        fixuptable :=
            CAST header + header^.UnresolvedFixupTableOffset TO ^XloRelocEntry

        sectiontable :=
            CAST header + header^.Hdr.SectionTableOffset TO ^XloSectionHeader

        i := 0

        WHILE i < header^.UnresolvedFixupCount DO
            fixup := &fixuptable[i]
            extern := &externtable[fixup^.ExternIndex]
            section := &sectiontable[fixup^.SectionIndex]
            lnksection := LnkIndexedSectionArray[section^.NameOffset]

            IF extern^.Type == XLO_EXTERN_RESOLVED THEN
                // Case 1: Resolved internally.
            
                lnksymbol := LnkFetchExternLinkToSymbol ( extern )

                IF lnksymbol^.Type != XLO_SYMBOL_SPECIAL THEN
                    // Perform the fixup to bind the extern.

                    XloPerformRelocationTable[fixup^.Type] (
                        lnksection^.Data +
                        section^.VirtualAddress +
                        fixup^.SectionOffset, // ptr
                        lnksymbol^.SectionOffset, // value
                        LnkArchitectureInTokyo, // bits
                        FALSE, // absolute
                    )

                    // Create new relocation.

                    status = TlBumpAlloc (
                        SIZEOF LnkRelocation, // bytes
                        OUT lnkreloc, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate relocation", 0, 0, 0 )
                    END

                    lnkreloc^.SectionOffset =
                        section^.VirtualAddress + fixup^.SectionOffset

                    lnkreloc^.Section = lnksection

                    lnkreloc^.Type = fixup^.Type

                    TlInsertAtTailList (
                        &lnksymbol^.Section^.RelocationListHead, // head
                        &lnkreloc^.Entry, // entry
                    )

                    lnksymbol^.Section^.RelocationCount += 1

                ELSE
                    // This was a special symbol, so create a special deferred
                    // relocation, which is only used internally by the linker
                    // after section parameters are fully known.

                    status = TlBumpAlloc (
                        SIZEOF LnkRelocation, // bytes
                        OUT lnkreloc, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate relocation", 0, 0, 0 )
                    END

                    lnkreloc^.SectionOffset =
                        section^.VirtualAddress + fixup^.SectionOffset

                    lnkreloc^.Section = lnksection

                    lnkreloc^.Extern = CAST lnksymbol TO ^LnkExtern

                    lnkreloc^.Type = fixup^.Type

                    TlInsertAtTailList (
                        &LnkSpecialRelocationList, // head
                        &lnkreloc^.Entry, // entry
                    )
                END

            ELSE
                lnkextern := LnkFetchExternLinkToExtern ( extern )

                IF lnkextern^.Library THEN
                    // Case 2: Resolved in dynamic library.

                    // Fetch the current offset from the symbol encoded in the
                    // section data.

                    oldvalue := XloFetchRelocationTable[fixup^.Type] (
                        lnksection^.Data +
                        section^.VirtualAddress +
                        fixup^.SectionOffset, // ptr
                        LnkArchitectureInTokyo, // bits
                    )

                    IF LnkCreateJumpStub[fixup^.Type] AND
                        LnkCreateStubs AND
                        oldvalue == 0 THEN

                        // We need to use a jump stub.

                        IF NOT lnkextern^.HasJumpStub THEN
                            // Create the jump stub.

                            IF NOT LnkJumpStubSection THEN
                                TlError ( "No code section for stubs\n" )
                            END

                            lnkextern^.JumpStubOffset =
                                LnkJumpStubSection^.Size +
                                LnkJumpStubSection^.DynamicData.Count

                            lnkextern^.HasJumpStub = TRUE

                            // Call the architecture-specific junk to actually
                            // encode it. Also creates the import fixup.

                            LnkCreateStubTable[LnkArchitectureType] (
                                lnkextern, // lnkextern
                            )
                        END

                        // Perform the fixup to redirect to the jump stub.

                        XloPerformRelocationTable[fixup^.Type] (
                            lnksection^.Data +
                            section^.VirtualAddress +
                            fixup^.SectionOffset, // ptr
                            lnkextern^.JumpStubOffset, // value
                            LnkArchitectureInTokyo, // bits
                            FALSE, // absolute
                        )

                        // Create a relocation referencing the jump stub.

                        status = TlBumpAlloc (
                            SIZEOF LnkRelocation, // bytes
                            OUT lnkreloc, // ptr
                        )

                        IF status THEN
                            TlInternalError (
                                "Failed to allocate relocation", 0, 0, 0 )
                        END

                        lnkreloc^.SectionOffset =
                            section^.VirtualAddress + fixup^.SectionOffset

                        lnkreloc^.Section = lnksection

                        lnkreloc^.Type = fixup^.Type

                        TlInsertAtTailList (
                            &LnkJumpStubSection^.RelocationListHead, // head
                            &lnkreloc^.Entry, // entry
                        )

                        LnkJumpStubSection^.RelocationCount += 1

                    ELSE
                        // Perform the fixup to bind the extern.

                        XloPerformRelocationTable[fixup^.Type] (
                            lnksection^.Data +
                            section^.VirtualAddress +
                            fixup^.SectionOffset, // ptr
                            lnkextern^.Address, // value
                            LnkArchitectureInTokyo, // bits
                            FALSE, // absolute
                        )

                        // Create an import fixup.

                        status = TlBumpAlloc (
                            SIZEOF LnkRelocation, // bytes
                            OUT lnkreloc, // ptr
                        )

                        IF status THEN
                            TlInternalError (
                                "Failed to allocate relocation", 0, 0, 0 )
                        END

                        lnkreloc^.Extern = lnkextern

                        lnkreloc^.SectionOffset =
                            section^.VirtualAddress + fixup^.SectionOffset

                        lnkreloc^.Section = lnksection

                        lnkreloc^.Type = fixup^.Type

                        lnkreloc^.OriginalValue = oldvalue

                        TlInsertAtTailList (
                            &lnkextern^.Library^.FixupListHead, // head
                            &lnkreloc^.Entry, // entry
                        )

                        lnkextern^.Library^.FixupCount += 1
                    END

                ELSE
                    // Case 3: Not resolved. Insert in unresolved fixup list.

                    status = TlBumpAlloc (
                        SIZEOF LnkRelocation, // bytes
                        OUT lnkreloc, // ptr
                    )

                    IF status THEN
                        TlInternalError (
                            "Failed to allocate relocation", 0, 0, 0 )
                    END

                    lnkreloc^.Extern = lnkextern

                    lnkreloc^.SectionOffset =
                        section^.VirtualAddress + fixup^.SectionOffset

                    lnkreloc^.Section = lnksection

                    lnkreloc^.Type = fixup^.Type

                    TlInsertAtTailList (
                        &LnkUnresolvedFixupList, // head
                        &lnkreloc^.Entry, // entry
                    )

                    LnkUnresolvedFixupCount += 1
                END
            END

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN LnkDieCuzOfUnresolvedExterns ()

    // Print all of the unresolved symbols and die.

    TlPrintByHandle (
        TlStdErr, // handle
        "Failed to resolve the following externs:\n", // fmt
    )

    listhead := &LnkExternTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnkextern := CONTAINEROF listentry TO LnkExtern.Entry.OrderedEntry

        IF NOT lnkextern^.Library THEN
            TlPrintByHandle (
                TlStdErr, // handle
                " %s: %s\n", // fmt
                lnkextern^.SourceObject^.Path,
                lnkextern^.Entry.Key,
            )
        END

        listentry = listentry^.Next
    END

    TlErrorExit ()
END

FN LnkAssignSectionBases (
    IN base : UWORD,
)

    // Assign a simple consecutive base to each section.

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        IF LnkPageAligned THEN
            base += LnkArchitecturePageMask
            base &= ~LnkArchitecturePageMask
        END

        lnksection^.VirtualAddress = base

        base += (lnksection^.VirtualSize + lnksection^.DynamicData.Count)

        listentry = listentry^.Next
    END
END

FN LnkAssignMappedBases (
    IN base : UWORD,
)

    // Assign a page-aligned mapped base to each section.
    //
    // Following this relocation, the sections can be mapped rounded down to the
    // previous page size, for a length up to the following page size, without
    // having to be physically page aligned within the file, which saves a lot
    // of bytes on disk (especially on Aphelion... 16K pages!)
    //
    // Note that this does require that the zeroed bss sections are all placed
    // at the end.

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    sawbss := FALSE

    base += LnkHeadLength & LnkArchitecturePageMask

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        IF lnksection^.Flags & XLO_SECTION_ZERO THEN
            // We can reset the alignment for bss.

            base &= ~LnkArchitecturePageMask

            sawbss = TRUE
        
        ELSEIF sawbss THEN
            TlError ( "-mappedbase: BSS sections must be final\n" )
        END

        lnksection^.VirtualAddress = base

        base += (lnksection^.VirtualSize + lnksection^.DynamicData.Count)

        IF base & LnkArchitecturePageMask THEN
            base += (LnkArchitecturePageMask + 1)
        END

        listentry = listentry^.Next
    END
END

LnkSectionName : UBYTE[256]
LnkExprStr : UBYTE[256]
LnkAtomStr : UBYTE[256]

FN LnkEvaluateExpr ()

    // Evaluate a component of the move expression of the following form:
    //
    // atom+atom+atom+...
    //
    // An atom can either be a constant number, or one of the following:
    //
    // [section name]: The base of a section.
    // @[section name]: The end of a section.
    // #[section name]: The size of a section.
    // %: Alignment to a page size.

    lnksection := CAST TlLookupHashTable (
        &LnkSectionTable, // hashtable
        &LnkSectionName[0], // key
    ) TO ^LnkSection

    IF NOT lnksection THEN
        TlError ( "-move: No such section '%s'\n", &LnkSectionName[0] )
    END

    expr := &LnkExprStr[0]
    pen := 0
    base := 0
    atomstr := &LnkAtomStr[0]

    WHILE TRUE DO
        IF expr^ == '+' OR expr^ == 0 THEN
            atomstr[pen] = 0

            refsection : ^LnkSection

            IF atomstr[0] >= '0' AND atomstr[0] <= '9' THEN
                // Constant value.

                val : UWORD

                IF NOT TlStringToNumber (
                    atomstr, // src
                    256, // bufsize
                    OUT val, // num
                ) THEN
                    TlError ( "-move: Expression syntax error\n" )
                END

                base += val

            ELSEIF atomstr[0] == '@' THEN
                // The end of a section.

                refsection = CAST TlLookupHashTable (
                    &LnkSectionTable, // hashtable
                    &atomstr[1], // key
                ) TO ^LnkSection

                IF NOT refsection THEN
                    TlError ( "-move: No such section '%s'\n", &atomstr[1] )
                END

                base += (refsection^.VirtualAddress +
                    refsection^.VirtualSize + refsection^.DynamicData.Count)

            ELSEIF atomstr[0] == '#' THEN
                // The size of a section.

                refsection = CAST TlLookupHashTable (
                    &LnkSectionTable, // hashtable
                    &atomstr[1], // key
                ) TO ^LnkSection

                IF NOT refsection THEN
                    TlError ( "-move: No such section '%s'\n", &atomstr[1] )
                END

                base += (refsection^.VirtualSize +
                    refsection^.DynamicData.Count)

            ELSEIF atomstr[0] == '%' AND atomstr[1] == 0 THEN
                // Alignment to page size.

                base += LnkArchitecturePageMask
                base &= ~LnkArchitecturePageMask

            ELSE
                // The base of a section.

                refsection = CAST TlLookupHashTable (
                    &LnkSectionTable, // hashtable
                    atomstr, // key
                ) TO ^LnkSection

                IF NOT refsection THEN
                    TlError ( "-move: No such section '%s'\n", atomstr )
                END

                base += refsection^.VirtualAddress
            END

            pen = 0

            IF expr^ == 0 THEN
                BREAK
            END

        ELSE
            IF pen >= 255 THEN
                TlError ( "-move: Expression atom too long\n" )
            END

            atomstr[pen] = expr^

            pen += 1
        END

        expr += 1
    END

    lnksection^.VirtualAddress = base
END

FN LnkEvaluateMoveExpression (
    IN expr : ^UBYTE,
)

    // Evaluate the "move expression", which is a string of the following form:
    //
    // [section name]=expr,[section name]=expr,...

    collectingsection := TRUE
    pen := 0

    WHILE TRUE DO
        IF expr^ == ',' OR expr^ == 0 THEN
            IF collectingsection THEN
                TlError ( "-move: Expression syntax error\n" )
            END

            LnkExprStr[pen] = 0

            LnkEvaluateExpr ()

            collectingsection = TRUE

            pen = 0

            IF expr^ == 0 THEN
                BREAK
            END

        ELSEIF expr^ == '=' THEN
            IF NOT collectingsection THEN
                TlError ( "-move: Expression syntax error\n" )
            END

            LnkSectionName[pen] = 0

            collectingsection = FALSE

            pen = 0

        ELSE
            IF pen >= 255 THEN
                TlError ( "-move: Expression syntax error\n" )
            END

            IF collectingsection THEN
                LnkSectionName[pen] = expr^

            ELSE
                LnkExprStr[pen] = expr^
            END

            pen += 1
        END

        expr += 1
    END
END

FN LnkIterateRelocationTables ()

    // Now iterate the relocation tables for each section and perform the
    // relocations to move them to their base address.

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        relochead := &lnksection^.RelocationListHead
        relocentry := relochead^.Next

        WHILE relocentry != relochead DO
            lnkreloc := CONTAINEROF relocentry TO LnkRelocation.Entry

            XloPerformRelocationTable[lnkreloc^.Type] (
                lnkreloc^.Section^.Data + lnkreloc^.SectionOffset, // ptr
                lnksection^.VirtualAddress, // value
                LnkArchitectureInTokyo, // bits
                FALSE, // absolute
            )

            relocentry = relocentry^.Next
        END

        listentry = listentry^.Next
    END

    // Now perform all of the special relocations which could not have been done
    // earlier since we didn't understand how the sections would be laid out
    // yet.

    listhead = &LnkSpecialRelocationList
    listentry = listhead^.Next

    WHILE listentry != listhead DO
        lnkreloc := CONTAINEROF listentry TO LnkRelocation.Entry

        symbol := CAST lnkreloc^.Extern TO ^LnkSymbol

        value : UWORD

        IF symbol^.SectionOffset == LNK_SYMBOL_BASE THEN
            value = symbol^.Section^.VirtualAddress

        ELSEIF symbol^.SectionOffset == LNK_SYMBOL_SIZE THEN
            value = symbol^.Section^.VirtualSize +
                symbol^.Section^.DynamicData.Count

        ELSEIF symbol^.SectionOffset == LNK_SYMBOL_END THEN
            value = symbol^.Section^.VirtualAddress +
                symbol^.Section^.VirtualSize + symbol^.Section^.DynamicData.Count
        END

        XloPerformRelocationTable[lnkreloc^.Type] (
            lnkreloc^.Section^.Data + lnkreloc^.SectionOffset, // ptr
            value, // value
            LnkArchitectureInTokyo, // bits
            FALSE, // absolute
        )

        listentry = listentry^.Next
    END
END

FN LnkPerformRelocations ()

    // Perform the final section relocations before emission.

    IF LnkMappedBase THEN
        // A mappedbase was provided.

        LnkAssignMappedBases ( LnkBaseAddress )

    ELSEIF LnkBaseAddress THEN
        // A simple base address was provided.

        LnkAssignSectionBases ( LnkBaseAddress )

    ELSEIF LnkMoveExpression THEN
        // A move expression was provided.

        LnkEvaluateMoveExpression ( LnkMoveExpression )

    ELSE
        LEAVE
    END

    LnkIterateRelocationTables ()
END

FN LnkOutputFxf ()

    // Output a fox32os FXF executable.

    // First we need to relocate all of the sections contiguously, with a base
    // of zero.

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    base := 0
    sawbss := FALSE
    codesize := 0
    bsssize := 0
    reloccount := 0

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        IF lnksection^.Flags & XLO_SECTION_ZERO THEN
            sawbss = TRUE
            bsssize += lnksection^.VirtualSize

        ELSEIF sawbss THEN
            TlError ( "-fxf: BSS sections must be final\n" )

        ELSE
            codesize += (lnksection^.VirtualSize +
                lnksection^.DynamicData.Count)
        END

        lnksection^.VirtualAddress = base

        base += (lnksection^.VirtualSize + lnksection^.DynamicData.Count)

        reloccount += lnksection^.RelocationCount

        listentry = listentry^.Next
    END

    // Now do the relocations.

    LnkIterateRelocationTables ()

    // Now initialize the header.

    header : FxfHeader

    header.MagicAndVersion = FXF_MAGIC_AND_VERSION
    header.CodeBytes = codesize
    header.RelocTableBytes = reloccount * 4
    header.BssBytes = bsssize

    offset := SIZEOF FxfHeader

    header.RelocTableOffset = offset

    reloctable : ^ULONG = NULLPTR

    IF reloccount THEN
        status := TlBumpAlloc (
            reloccount * 4, // bytes
            OUT reloctable, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to allocate relocation table", 0, 0, 0 )
        END

        offset += reloccount * 4

        i := 0

        listhead = &LnkSectionTable.OrderedListHead
        listentry = listhead^.Next

        WHILE listentry != listhead DO
            lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

            // Fill in the relocation table.

            rhead := &lnksection^.RelocationListHead
            rlistentry := rhead^.Next

            WHILE rlistentry != rhead DO
                lnkreloc := CONTAINEROF rlistentry TO LnkRelocation.Entry

                reloctable[i] =
                    lnkreloc^.Section^.VirtualAddress + lnkreloc^.SectionOffset

                rlistentry = rlistentry^.Next
                i += 1
            END

            listentry = listentry^.Next
        END
    END

    header.CodeOffset = offset

    // Now output all of these binary structures to the object file.

    handle : ^VOID

    status := TlOpenDestination (
        LnkOutputName, // filename
        OUT handle, // handle
    )

    IF status THEN
        TlError ( "%s: Failed to open\n", LnkOutputName )
    END

    // Output the header.

    TlWriteFile (
        handle, // handle
        SIZEOF FxfHeader, // bytes
        &header, // buffer
    )

    IF reloctable THEN
        // Output the relocation table.

        TlWriteFile (
            handle, // handle
            reloccount * 4, // bytes
            reloctable, // buffer
        )
    END

    // Output the section contents.

    listhead = &LnkSectionTable.OrderedListHead
    listentry = listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        IF lnksection^.Size THEN
            TlWriteFile (
                handle, // handle
                lnksection^.Size, // bytes
                lnksection^.Data, // buffer
            )
        END

        IF lnksection^.DynamicData.Count THEN
            TlWriteFile (
                handle, // handle
                lnksection^.DynamicData.Count, // bytes
                lnksection^.DynamicData.Buffer, // buffer
            )
        END

        listentry = listentry^.Next
    END

    TlClose ( handle )
END

FN LnkOutputBinary ()

    // Output a flat binary file.

    // First perform the final section relocations.

    LnkPerformRelocations ()

    // Now dump the sections in sequence to the file.

    handle : ^VOID

    status := TlOpenDestination (
        LnkOutputName, // filename
        OUT handle, // handle
    )

    IF status THEN
        TlError ( "%s: Failed to open\n", LnkOutputName )
    END

    listhead := &LnkSectionTable.OrderedListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        lnksection := CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

        IF NOT (lnksection^.Flags & XLO_SECTION_ZERO) THEN
            IF lnksection^.Size THEN
                TlWriteFile (
                    handle, // handle
                    lnksection^.Size, // bytes
                    lnksection^.Data, // buffer
                )
            END

            IF lnksection^.DynamicData.Count THEN
                TlWriteFile (
                    handle, // handle
                    lnksection^.DynamicData.Count, // bytes
                    lnksection^.DynamicData.Buffer, // buffer
                )
            END
        END

        listentry = listentry^.Next
    END

    TlClose ( handle )
END

LnkStringTable : TlDynamicBuffer
LnkSixteenZeroes : UBYTE[16]

FN LnkAddString (
    IN str : ^UBYTE,
) : UWORD

    // Add the string to the string table and return the offset.

    offset := LnkStringTable.Count

    TlCopyIntoDynamicBuffer (
        &LnkStringTable, // array
        str, // srcbuf
        TlMeasureString ( str ) + 1, // length (plus null terminator)
    )

    RETURN offset
END

FN LnkOutputXlo ()

    // Output the linked executable to an XLO format file.

    i : UWORD
    j : UWORD
    status : TlStatus
    head : ^TlListEntry
    listentry : ^TlListEntry
    rhead : ^TlListEntry
    rlistentry : ^TlListEntry
    lnkreloc : ^LnkRelocation
    lnksection : ^LnkSection

    // Initialize the string table buffer.

    TlInitializeDynamicBuffer ( &LnkStringTable )

    // Now initialize easy bits of the object header, and set the others to
    // 0xABABABAB to easily tell if something is left uninitialized.

    header : XloHeaderExtended

    header.Hdr.Magic = XLO_MAGIC_NUMBER
    header.Hdr.SymbolTableOffset = 0xABABABAB
    header.Hdr.SymbolCount = LnkSymbolCount
    header.Hdr.StringTableOffset = 0xABABABAB
    header.Hdr.StringTableSize = 0xABABABAB
    header.Hdr.TargetArchitecture = LnkArchitectureType
    header.Hdr.HeadLength = 0xABABABAB
    header.Hdr.ImportTableOffset = 0xABABABAB
    header.Hdr.Flags = 0
    header.Hdr.Timestamp = TlCurrentEpochTime ()
    header.Hdr.SectionTableOffset = 0xABABABAB
    header.Hdr.ExternTableOffset = 0xABABABAB
    header.Hdr.ExternCount = LnkExternCount
    header.Hdr.SectionCount = LnkSectionCount
    header.Hdr.ImportCount = LnkLibraryCount
    header.UnresolvedFixupTableOffset = 0xABABABAB
    header.UnresolvedFixupCount = LnkUnresolvedFixupCount

    offset : UWORD

    IF LnkCreateFragment THEN
        header.Hdr.Flags = XLO_FILE_FRAGMENT

        offset = SIZEOF XloHeaderExtended

    ELSE
        offset = SIZEOF XloHeader
    END

    IF LnkStripRelocs THEN
        header.Hdr.Flags |= XLO_FILE_STRIPPED
    END

    // Create the section table.

    sectiontable : ^XloSectionHeader = NULLPTR

    IF LnkSectionCount THEN
        status = TlBumpAlloc (
            SIZEOF XloSectionHeader * LnkSectionCount, // bytes
            OUT sectiontable, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to create section table", 0, 0, 0 )
        END

        // Record and bump the offset.

        header.Hdr.SectionTableOffset = offset

        offset += SIZEOF XloSectionHeader * LnkSectionCount

        i = 0

        head = &LnkSectionTable.OrderedListHead
        listentry = head^.Next

        // First assign indices.

        WHILE listentry != head DO
            lnksection = CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

            lnksection^.FinalIndex = i

            i += 1
            listentry = listentry^.Next
        END

        i = 0
        listentry = head^.Next

        WHILE listentry != head DO
            lnksection = CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

            lnksection^.RelocationTable = NULLPTR

            // Fill in the parts of the section table entry that we can do now,
            // i.e., everything except for the file offset and virtual address.

#IF ( == BLD_BITS 64 )
            sectiontable[i].VirtualAddress = 0
#ELSE
            sectiontable[i].VirtualAddress = 0
            sectiontable[i].Reserved = 0
#END
            sectiontable[i].NameOffset = LnkAddString ( lnksection^.Entry.Key )

            sectiontable[i].DataLength =
                lnksection^.Size + lnksection^.DynamicData.Count

            sectiontable[i].VirtualLength =
                lnksection^.VirtualSize + lnksection^.DynamicData.Count

            sectiontable[i].RelocTableOffset = 0xABABABAB

            sectiontable[i].RelocCount = 0

            sectiontable[i].Flags = lnksection^.Flags

            // Now create the relocation table.

            IF lnksection^.RelocationCount AND NOT LnkStripRelocs THEN
                status = TlBumpAlloc (
                    SIZEOF XloRelocEntry * lnksection^.RelocationCount, // bytes
                    OUT lnksection^.RelocationTable, // ptr
                )

                IF status THEN
                    TlInternalError ( "Failed to create reloc table", 0, 0, 0 )
                END

                sectiontable[i].RelocCount = lnksection^.RelocationCount

                // Record and bump the offset.

                sectiontable[i].RelocTableOffset = offset

                offset += SIZEOF XloRelocEntry * lnksection^.RelocationCount

                // Fill in the relocation table.

                j = 0

                rhead = &lnksection^.RelocationListHead
                rlistentry = rhead^.Next

                WHILE rlistentry != rhead DO
                    lnkreloc = CONTAINEROF rlistentry TO LnkRelocation.Entry

                    lnksection^.RelocationTable[j].SectionOffset =
                        lnkreloc^.SectionOffset

                    lnksection^.RelocationTable[j].ExternIndex = 0

                    lnksection^.RelocationTable[j].Type = lnkreloc^.Type

                    lnksection^.RelocationTable[j].SectionIndex =
                        lnkreloc^.Section^.FinalIndex

                    rlistentry = rlistentry^.Next
                    j += 1
                END
            END

            listentry = listentry^.Next
            i += 1
        END
    END

    // Create the global and exported symbol table.

    symboltable : ^XloSymbolEntry = NULLPTR

    IF LnkSymbolCount THEN
        status = TlBumpAlloc (
            SIZEOF XloSymbolEntry * LnkSymbolCount, // bytes
            OUT symboltable, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to create symbol table", 0, 0, 0 )
        END

        // Record and bump the offset.

        header.Hdr.SymbolTableOffset = offset

        offset += SIZEOF XloSymbolEntry * LnkSymbolCount

        // Fill in the table.

        i = 0

        head = &LnkSymbolTable.OrderedListHead
        listentry = head^.Next

        WHILE listentry != head DO
            lnksymbol := CONTAINEROF listentry TO LnkSymbol.Entry.OrderedEntry

            IF lnksymbol^.Type != XLO_SYMBOL_SPECIAL AND
                (lnksymbol^.Type != XLO_SYMBOL_GLOBAL OR
                LnkCreateFragment OR LnkKeepGlobals) THEN

                symboltable[i].SectionIndex = lnksymbol^.Section^.FinalIndex
                symboltable[i].Type = lnksymbol^.Type
                symboltable[i].Flags = 0
                symboltable[i].Padding = 0
                symboltable[i].SectionOffset = lnksymbol^.SectionOffset
                symboltable[i].NameOffset =
                    LnkAddString ( lnksymbol^.Entry.Key )

                i += 1
            END

            listentry = listentry^.Next
        END
    END

    // Create the extern symbol table.

    externtable : ^XloExternEntry = NULLPTR

    IF LnkExternCount THEN
        status = TlBumpAlloc (
            SIZEOF XloExternEntry * LnkExternCount, // bytes
            OUT externtable, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to create extern table", 0, 0, 0 )
        END

        // Record and bump the offset.

        header.Hdr.ExternTableOffset = offset

        offset += SIZEOF XloExternEntry * LnkExternCount

        // Fill in the table.

        i = 0

        head = &LnkExternTable.OrderedListHead
        listentry = head^.Next

        WHILE listentry != head DO
            lnkextern := CONTAINEROF listentry TO LnkExtern.Entry.OrderedEntry

            externtable[i].NameOffset = LnkAddString ( lnkextern^.Entry.Key )
            externtable[i].Type = XLO_EXTERN_UNRESOLVED
            externtable[i].Padding = 0
            externtable[i].ImportIndex = 0
            externtable[i].Padding2 = 0
            externtable[i].Padding3 = 0

            IF lnkextern^.Library THEN
                externtable[i].Type = XLO_EXTERN_IMPORTED
                externtable[i].ImportIndex = lnkextern^.Library^.Index
            END

            listentry = listentry^.Next
            i += 1
        END
    END

    // Create the extern fixup table.

    externfixtable : ^XloRelocEntry = NULLPTR

    IF LnkUnresolvedFixupCount THEN
        status = TlBumpAlloc (
            SIZEOF XloRelocEntry * LnkUnresolvedFixupCount, // bytes
            OUT externfixtable, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to create externfix table", 0, 0, 0 )
        END

        // Record and bump the offset.

        header.UnresolvedFixupTableOffset = offset

        offset += SIZEOF XloRelocEntry * LnkUnresolvedFixupCount

        // Fill in the table.

        i = 0

        head = &LnkUnresolvedFixupList
        listentry = head^.Next

        WHILE listentry != head DO
            lnkreloc = CONTAINEROF listentry TO LnkRelocation.Entry

            externfixtable[i].SectionOffset = lnkreloc^.SectionOffset
            externfixtable[i].ExternIndex = lnkreloc^.Extern^.Index
            externfixtable[i].Type = lnkreloc^.Type
            externfixtable[i].SectionIndex = lnkreloc^.Section^.FinalIndex

            listentry = listentry^.Next
            i += 1
        END
    END

    // Create the import table.

    importtable : ^XloImportEntry = NULLPTR

    IF LnkLibraryCount THEN
        status = TlBumpAlloc (
            SIZEOF XloImportEntry * LnkLibraryCount, // bytes
            OUT importtable, // ptr
        )

        IF status THEN
            TlInternalError ( "Failed to create import table", 0, 0, 0 )
        END

        // Record and bump the offset.

        header.Hdr.ImportTableOffset = offset

        offset += SIZEOF XloImportEntry * LnkLibraryCount

        // Fill in the table.

        i = 0

        head = &LnkLibListHead
        listentry = head^.Next

        WHILE listentry != head DO
            library := CONTAINEROF listentry TO LnkLibrary.Entry

            libheader := CAST library^.Data TO ^XloHeader

            library^.FixupTable = NULLPTR

            importtable[i].NameOffset = LnkAddString ( library^.RuntimePath )
            importtable[i].ExpectedTimestamp = libheader^.Timestamp
            importtable[i].FixupTableOffset = 0xABABABAB
            importtable[i].FixupCount = library^.FixupCount

            // Now create the relocation table.

            IF library^.FixupCount THEN
                status = TlBumpAlloc (
                    SIZEOF XloImportFixupEntry * library^.FixupCount, // bytes
                    OUT library^.FixupTable, // ptr
                )

                IF status THEN
                    TlInternalError ( "Failed to create fixup table", 0, 0, 0 )
                END

                // Record and bump the offset.

                importtable[i].FixupTableOffset = offset

                offset += SIZEOF XloImportFixupEntry * library^.FixupCount

                // Fill in the fixup table.

                j = 0

                rhead = &library^.FixupListHead
                rlistentry = rhead^.Next

                WHILE rlistentry != rhead DO
                    lnkreloc = CONTAINEROF rlistentry TO LnkRelocation.Entry

                    library^.FixupTable[j].SectionOffset =
                        lnkreloc^.SectionOffset

                    library^.FixupTable[j].ExternIndex =
                        lnkreloc^.Extern^.Index

                    library^.FixupTable[j].Type = lnkreloc^.Type

                    library^.FixupTable[j].SectionIndex =
                        lnkreloc^.Section^.FinalIndex

                    library^.FixupTable[j].OriginalValue =
                        lnkreloc^.OriginalValue

                    rlistentry = rlistentry^.Next
                    j += 1
                END
            END

            listentry = listentry^.Next
            i += 1
        END
    END

    // Now record the string table and bump the offset.

    header.Hdr.StringTableOffset = offset
    header.Hdr.StringTableSize = LnkStringTable.Count

    offset += LnkStringTable.Count

    // Record the head length, since it is now known.

    header.Hdr.HeadLength = offset

    // Calculate padding required by target between head and first section.

    diff := LnkFileAlign ( offset ) - offset

    offset += diff

    LnkHeadLength = offset

    // Now perform the final section relocations.

    LnkPerformRelocations ()

    // And fill in the data offsets in the section table.

    IF LnkSectionCount THEN
        i = 0

        head = &LnkSectionTable.OrderedListHead
        listentry = head^.Next

        WHILE listentry != head DO
            lnksection = CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

            sectiontable[i].VirtualAddress = lnksection^.VirtualAddress

            sectiontable[i].FileOffset = offset

            offset += lnksection^.Size + lnksection^.DynamicData.Count

            listentry = listentry^.Next
            i += 1
        END
    END

    // Now output all of these binary structures to the object file.

    handle : ^VOID

    status = TlOpenDestination (
        LnkOutputName, // filename
        OUT handle, // handle
    )

    IF status THEN
        TlPrint ( "%s: Failed to open\n", LnkOutputName )
    END

    // Output the header.

    IF LnkCreateFragment THEN
        TlWriteFile (
            handle, // handle
            SIZEOF XloHeaderExtended, // bytes
            &header, // buffer
        )
    ELSE
        TlWriteFile (
            handle, // handle
            SIZEOF XloHeader, // bytes
            &header, // buffer
        )
    END

    IF sectiontable THEN
        // Output the section table.

        TlWriteFile (
            handle, // handle
            SIZEOF XloSectionHeader * LnkSectionCount, // bytes
            sectiontable, // buffer
        )

        // Output the relocation tables.

        i = 0

        head = &LnkSectionTable.OrderedListHead
        listentry = head^.Next

        WHILE listentry != head DO
            lnksection = CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

            IF lnksection^.RelocationTable THEN
                TlWriteFile (
                    handle, // handle
                    SIZEOF XloRelocEntry * lnksection^.RelocationCount, // bytes
                    lnksection^.RelocationTable, // buffer
                )
            END

            listentry = listentry^.Next
            i += 1
        END
    END

    IF symboltable THEN
        // Output the symbol table.

        TlWriteFile (
            handle, // handle
            SIZEOF XloSymbolEntry * LnkSymbolCount, // bytes
            symboltable, // buffer
        )
    END

    IF externtable THEN
        // Output the extern table.

        TlWriteFile (
            handle, // handle
            SIZEOF XloExternEntry * LnkExternCount, // bytes
            externtable, // buffer
        )
    END

    IF externfixtable THEN
        // Output the extern fixup table.

        TlWriteFile (
            handle, // handle
            SIZEOF XloRelocEntry * LnkUnresolvedFixupCount, // bytes
            externfixtable, // buffer
        )
    END

    IF importtable THEN
        // Output the import table.

        TlWriteFile (
            handle, // handle
            SIZEOF XloImportEntry * LnkLibraryCount, // bytes
            importtable, // buffer
        )

        // Output the fixup tables.

        i = 0

        head = &LnkLibListHead
        listentry = head^.Next

        WHILE listentry != head DO
            library := CONTAINEROF listentry TO LnkLibrary.Entry

            IF library^.FixupTable THEN
                TlWriteFile (
                    handle, // handle
                    SIZEOF XloImportFixupEntry * library^.FixupCount, // bytes
                    library^.FixupTable, // buffer
                )
            END

            listentry = listentry^.Next
            i += 1
        END
    END

    IF LnkStringTable.Count THEN
        // Output the string table.

        TlWriteFile (
            handle, // handle
            LnkStringTable.Count, // bytes
            LnkStringTable.Buffer, // buffer
        )
    END

    // Output the section contents.

    IF LnkSectionCount THEN
        IF diff THEN
            // Output padding.

            TlWriteFile (
                handle, // handle
                diff, // bytes
                &LnkSixteenZeroes[0], // buffer
            )
        END

        i = 0

        head = &LnkSectionTable.OrderedListHead
        listentry = head^.Next

        WHILE listentry != head DO
            lnksection = CONTAINEROF listentry TO LnkSection.Entry.OrderedEntry

            IF lnksection^.Size THEN
                TlWriteFile (
                    handle, // handle
                    lnksection^.Size, // bytes
                    lnksection^.Data, // buffer
                )
            END

            IF lnksection^.DynamicData.Count THEN
                TlWriteFile (
                    handle, // handle
                    lnksection^.DynamicData.Count, // bytes
                    lnksection^.DynamicData.Buffer, // buffer
                )
            END

            listentry = listentry^.Next
            i += 1
        END
    END
END

FN LnkLinkObject ()

    // Link the final object.

    LnkAllocateStorage ()

    LnkMergeSections ()

    IF NOT LnkCreateFragment AND
        NOT LnkCreateFxf AND
        NOT LnkCreateBin THEN

        LnkRemoveZeroSections ()
    END

    LnkCreateSpecialSymbols ()

    LnkMergeSymbolTables ()

    LnkResolveExterns ()

    LnkBindExports ()

    IF LnkUnresolvedCount AND NOT LnkCreateFragment THEN
        LnkDieCuzOfUnresolvedExterns ()
    END

    LnkResolveFixupTable ()

    IF LnkUnresolvedFixupCount AND NOT LnkCreateFragment THEN
        TlInternalError ( "Unresolved fixups in non-fragment", 0, 0, 0 )
    END

    IF LnkCreateFxf THEN
        LnkOutputFxf ()

        LEAVE
    END

    IF LnkCreateBin THEN
        LnkOutputBinary ()

        LEAVE
    END

    LnkOutputXlo ()
END

FN LnkInitializeDatabase ()

    // Initialize the linker database.

    TlInitializeList ( &LnkObjectListHead )

    TlInitializeList ( &LnkLibListHead )

    TlInitializeList ( &LnkUnresolvedFixupList )

    TlInitializeList ( &LnkSpecialRelocationList )

    TlInitializeHashTable ( &LnkSectionTable )

    TlInitializeHashTable ( &LnkSymbolTable )

    TlInitializeHashTable ( &LnkExternTable )
END