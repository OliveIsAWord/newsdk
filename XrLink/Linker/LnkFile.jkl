//
// Implements support routines for loading and validating an XLO object.
//

#INCLUDE "<inc>/Linker.hjk"

PUBLIC LnkArchitectureType := 0
PUBLIC LnkArchitectureInTokyo := 0
PUBLIC LnkArchitecturePageMask := 0

LnkArchitectureBitTable : UWORD[XLO_ARCHITECTURE_MAX] = {
    [XLO_ARCHITECTURE_XR17032] = 32,
    [XLO_ARCHITECTURE_FOX32] = 32,
    [XLO_ARCHITECTURE_APHELION] = 64,
    [XLO_ARCHITECTURE_AMD64] = 64,
}

LnkArchitecturePageMaskTable : UWORD[XLO_ARCHITECTURE_MAX] = {
    [XLO_ARCHITECTURE_XR17032] = 0xFFF,
    [XLO_ARCHITECTURE_FOX32] = 0xFFF,
    [XLO_ARCHITECTURE_APHELION] = 0x3FFF,
    [XLO_ARCHITECTURE_AMD64] = 0xFFF,
}

FN LnkLoadXloFile (
    IN filename : ^UBYTE,
) : ^UBYTE

    // First, open the object file.

    handle : ^VOID

    status := TlOpenSource (
        filename, // filename
        OUT handle, // handle
    )

    IF status THEN
        TlPrintString ( "Failed to open object file '" )
        TlPrintString ( filename )
        TlPrintString ( "'\n" )

        TlErrorExit ()
    END

    // Now stat the file to acquire the size.

    statrecord : TlStatRecord

    IF TlStatFile (
        filename, // path
        &statrecord, // statrecord
    ) THEN
        TlInternalError ( "Failed to stat object file", 0, 0, 0 )
    END

    // Allocate a buffer to contain the file contents.

    ptr : ^UBYTE

    status = TlAlloc (
        statrecord.SizeInBytes, // bytes
        OUT ptr, // ptr
    )

    // Read the file.

    TlReadFile (
        handle, // handle
        statrecord.SizeInBytes, // bytes
        ptr, // buffer
    )

    // Now basically validate the header.

    header := CAST ptr TO ^XloHeader

    IF header^.Magic != XLO_MAGIC_NUMBER THEN
        TlPrintString ( filename )
        TlPrintString ( ": Not a valid XLO object file\n" )

        TlErrorExit ()
    END

    IF NOT LnkArchitectureType THEN
        LnkArchitectureType = header^.TargetArchitecture

        IF header^.TargetArchitecture >= XLO_ARCHITECTURE_MAX THEN
            TlPrintString ( filename )
            TlPrintString ( ": Unknown architecture type\n" )

            TlErrorExit ()
        END

        LnkArchitecturePageMask =
            LnkArchitecturePageMaskTable[LnkArchitectureType]

        LnkArchitectureInTokyo = LnkArchitectureBitTable[LnkArchitectureType]

        IF NOT LnkArchitectureInTokyo THEN
            TlPrintString ( filename )
            TlPrintString ( ": Unknown architecture type\n" )
            
            TlErrorExit ()
        END

#IF ( == BITS 32 )
        IF LnkArchitectureInTokyo == 64 THEN
            TlPrintString ( filename )
            TlPrintString ( ": Can't link 64-bit architecture with 32-bit linker build\n" )

            TlErrorExit ()
        END
#END

    ELSEIF LnkArchitectureType != header^.TargetArchitecture THEN
        TlPrintString ( filename )
        TlPrintString ( ": Incompatible architecture type\n" )

        TlErrorExit ()
    END

    RETURN ptr
END