//
// Disk Update Tool initialization.
//

#INCLUDE "Dut.hjk"

FN DutUsage ()
    TlPrintByHandle (
        TlStdErr, // handle
        "Usage: %s <command> <options ...>

Commands:
  info <imagename>:
    Print miscellaneous information about the disk image.

  create <imagename> <sectors>
  [-apt:disklabel,label1:sectors1,label2:sectors2,... [-boot:bootfile]]
  [-fs:part,fsname[,manifest1,manifest2,...]]
  [-os:part,labelfile,bootstrapfile,sector,length]:
    Create a disk image with the given name, size in sectors, partition layout,
    boot sector, and initialize with one or more filesystems.

  update <imagename> <partition> <manifest>:
    Update all recursive subdirectories indicated by manifest file.

  updatefiles <imagename> <partition> <listfile>:
    Update all files indicated by list file.

  ls <imagename> <partition> <path>:
    List the contents of the specified filesystem directory.

  read <imagename> <partition> <path>:
    Read the contents of the specified file to stdout.

  write <imagename> <partition> <path> <hostpath>:
    Write the contents of the specified file from another file.

  delete <imagename> <partition> <path>:
    Delete the specified file.\n", // fmt
        TlProgramName,
    )

    TlErrorExit ()
END

DutBuffer1 : UBYTE[DUT_LABEL_MAX]
DutBuffer2 : UBYTE[DUT_LABEL_MAX]

STRUCT DutManifest
    Entry : TlListEntry,

    PathBuffer : TlDynamicBuffer,
END

STRUCT DutFsDescription
    Entry : TlListEntry,

    PartId : UWORD,
    FsName : UBYTE[DUT_LABEL_MAX],

    ManifestListHead : TlListEntry,
END

STRUCT DutOsDescription
    Entry : TlListEntry,

    PartId : UWORD,
    LabelFile : ^VOID,
    BootstrapFile : ^VOID,
    BootstrapSector : UWORD,
    BootstrapLength : UWORD,

    LabelFileName : TlDynamicBuffer,
    BootstrapFileName : TlDynamicBuffer,
END

FN DutCreateFilesystems (
    IN image : ^DutDiskImage,
    IN fslisthead : ^TlListEntry,
)

    // Create filesystems on the image as specified.

    listentry := fslisthead^.Next

    WHILE listentry != fslisthead DO
        fs := CONTAINEROF listentry TO DutFsDescription.Entry

        volume : ^DutDiskCommon

        IF fs^.PartId == -1 THEN
            // -1 means to use the entire disk image.

            volume = CAST image TO ^DutDiskCommon

        ELSE
            volume = CAST DutFindPartitionById (
                image, // image
                fs^.PartId, // id
            ) TO ^DutDiskCommon

            IF NOT volume THEN
                TlError ( "No such partition %d\n", fs^.PartId )
            END
        END

        // Now look up the filesystem name.

        fsd := DutLookupFilesystem ( &fs^.FsName[0] )

        IF NOT fsd THEN
            TlError ( "No such filesystem %s\n", &fs^.FsName[0] )
        END

        // Call the filesystem's format routine with the volume handle we just
        // acquired.

        fsd^.Format ( volume )

        IF &fs^.ManifestListHead != fs^.ManifestListHead.Next THEN
            // There are manifest files specified, so mount the filesystem.

            mount := DutMountFilesystem (
                volume, // volume
                fsd, // fs
            )

            IF NOT mount THEN
                TlError ( "Failed to mount filesystem\n" )
            END

            // Now initialize the filesystem hierarchy using the manifest files.

            // ...

            // Unmount the filesystem.

            DutUnmountFilesystem ( mount )
        END

        listentry = listentry^.Next
    END
END

FN DutMakeBootable (
    IN image : ^DutDiskImage,
    IN oslisthead : ^TlListEntry,
)

    // Create bootable partitions on the image as specified.

    listentry := oslisthead^.Next

    WHILE listentry != oslisthead DO
        os := CONTAINEROF listentry TO DutOsDescription.Entry

        volume : ^DutDiskCommon

        IF os^.PartId == -1 THEN
            // -1 means to use the entire disk image.

            volume = CAST image TO ^DutDiskCommon

        ELSE
            volume = CAST DutFindPartitionById (
                image, // image
                os^.PartId, // id
            ) TO ^DutDiskCommon

            IF NOT volume THEN
                TlError ( "No such partition %d\n", os^.PartId )
            END
        END

        // Write the OS label.

        TlReadFile (
            os^.LabelFile, // handle
            1024, // bytes
            &DutTemporaryBuffer[0], // buffer
        )

        DutWriteSector (
            volume, // volume
            &DutTemporaryBuffer[0], // buffer
            1, // sector
        )

        DutWriteSector (
            volume, // volume
            &DutTemporaryBuffer[512], // buffer
            2, // sector
        )

        // Write the bootstrap.

        i := 0

        WHILE i < os^.BootstrapLength DO
            TlReadFile (
                os^.BootstrapFile, // handle
                512, // bytes
                &DutTemporaryBuffer[0], // buffer
            )

            DutWriteSector (
                volume, // volume
                &DutTemporaryBuffer[0], // buffer
                os^.BootstrapSector + i, // sector
            )

            i += 1
        END

        listentry = listentry^.Next
    END
END

FN DutCreateImage (
    IN argc : ULONG,
    IN argv : ^^UBYTE,
)

    // Parse the arguments and generate a disk image as specified.

    imagename := argv[2]

    sectors : UWORD

    IF NOT TlStringToNumber (
        argv[3], // src
        -1, // bufsize
        OUT sectors, // num
    ) THEN
        DutUsage ()
    END

    i := 4
    j : UWORD
    apt := FALSE
    status : TlStatus
    desclisthead : TlListEntry
    fslisthead : TlListEntry
    oslisthead : TlListEntry
    bootfilehandle := NULLPTR
    fs : ^DutFsDescription
    manifest : ^DutManifest

    TlInitializeList ( &fslisthead )
    TlInitializeList ( &oslisthead )

    WHILE i < argc DO
        arg := argv[i]

        IF arg[0] != '-' THEN
            DutUsage ()
        END

        IF TlCompareStringWithMax ( arg, "-apt:", 5 ) == 0 THEN
            // Parse APT partition table specifiers.

            apt = TRUE

            arg += 5

            // First component is disk label.

            j = 0

            WHILE arg^ != ',' AND arg^ != 0 DO
                IF j == DUT_LABEL_MAX - 1 THEN
                    TlError ( "-apt: Too many characters in disk label\n" )
                END

                DutBuffer2[j] = arg^

                j += 1
                arg += 1
            END

            DutBuffer2[j] = 0

            IF NOT DutBuffer2[0] THEN
                TlError ( "-apt: Disk label must be at least 1 character\n" )
            END

            IF arg^ == ',' THEN
                arg += 1

                // Parse the partition list.

                TlInitializeList ( &desclisthead )

                currentpart : ^DutPartitionDescription = NULLPTR
                label := FALSE

                WHILE TRUE DO
                    IF NOT currentpart THEN
                        status = TlBumpAlloc (
                            SIZEOF DutPartitionDescription, // bytes
                            OUT currentpart, // ptr
                        )

                        IF status THEN
                            TlInternalError (
                                "Failed to allocate part", 0, 0, 0 )
                        END

                        j = 0
                        label = TRUE
                    END

                    IF arg^ == ':' THEN
                        IF NOT label THEN
                            TlError ( "Syntax error\n" )
                        END

                        currentpart^.Label[j] = 0

                        IF currentpart^.Label[0] == 0 THEN
                            TlError (
                            "-apt: Part label must be at least 1 character\n" )
                        END

                        label = FALSE
                        j = 0

                    ELSEIF arg^ == ',' OR arg^ == 0 THEN
                        IF label THEN
                            TlError ( "Syntax error\n" )
                        END

                        DutBuffer1[j] = 0

                        IF NOT TlStringToNumber (
                            &DutBuffer1[0], // src
                            -1, // bufsize
                            OUT currentpart^.SectorCount, // num
                        ) THEN
                            TlError ( "Syntax error\n" )
                        END

                        TlInsertAtTailList (
                            &desclisthead, // head
                            &currentpart^.Entry, // entry
                        )

                        label = TRUE
                        currentpart = NULLPTR

                        IF arg^ == 0 THEN
                            BREAK
                        END

                    ELSEIF label THEN
                        IF j == DUT_LABEL_MAX - 1 THEN
                            TlError (
                                "-apt: Too many characters in part label\n" )
                        END

                        currentpart^.Label[j] = arg^
                        j += 1

                    ELSE
                        IF j == DUT_LABEL_MAX - 1 THEN
                            TlError (
                                "-apt: Too many characters in part size\n" )
                        END

                        DutBuffer1[j] = arg^
                        j += 1
                    END

                    arg += 1
                END
            END

        ELSEIF TlCompareStringWithMax ( arg, "-boot:", 6 ) == 0 THEN
            IF NOT apt THEN
                TlError ( "-boot: only relevant when APT partitioning\n" )
            END

            IF bootfilehandle THEN
                TlClose ( bootfilehandle )
            END

            status = TlOpenSource (
                &arg[6], // filename
                OUT bootfilehandle, // handle
            )

            IF status THEN
                TlError ( "-boot: Failed to open '%s'\n", &arg[6] )
            END

        ELSEIF TlCompareStringWithMax ( arg, "-fs:", 4 ) == 0 THEN
            arg += 4

            j = 0

            // Allocate fs block.

            status = TlBumpAlloc (
                SIZEOF DutFsDescription, // bytes
                OUT fs, // ptr
            )

            IF status THEN
                TlInternalError ( "Failed to allocate fs", 0, 0, 0 )
            END

            TlInitializeList ( &fs^.ManifestListHead )

            // Collect partition number.

            WHILE arg^ AND arg^ != ',' DO
                IF j == DUT_LABEL_MAX - 1 THEN
                    TlError ( "-fs: Too many characters in part number\n" )
                END

                DutBuffer1[j] = arg^

                j += 1
                arg += 1
            END

            DutBuffer1[j] = 0

            IF NOT TlStringToNumber (
                &DutBuffer1[0], // src
                -1, // bufsize
                OUT fs^.PartId, // num
            ) THEN
                TlError ( "-fs: Bad partition number\n" )
            END

            // Collect fs name.

            IF arg[0] != ',' THEN
                TlError ( "-fs: Syntax error\n" )
            END

            arg += 1

            j = 0

            WHILE arg^ AND arg^ != ',' DO
                IF j == DUT_LABEL_MAX - 1 THEN
                    TlError ( "-fs: Too many characters in fs name\n" )
                END

                fs^.FsName[j] = arg^

                j += 1
                arg += 1
            END

            fs^.FsName[j] = 0

            IF fs^.FsName[0] == 0 THEN
                TlError ( "-fs: Syntax error\n" )
            END

            // Collect manifest names.

            WHILE arg^ == ',' DO
                arg += 1

                status = TlBumpAlloc (
                    SIZEOF DutManifest, // bytes
                    OUT manifest, // ptr
                )

                IF status THEN
                    TlInternalError ( "Failed to allocate manifest", 0, 0, 0 )
                END

                TlInitializeDynamicBuffer ( &manifest^.PathBuffer )

                WHILE arg^ AND arg^ != ',' DO
                    TlInsertDynamicBuffer (
                        &manifest^.PathBuffer, // array
                        arg^, // byte
                    )

                    arg += 1
                END

                IF manifest^.PathBuffer.Count == 0 THEN
                    TlError ( "-fs: Syntax error\n" )
                END

                TlInsertDynamicBuffer (
                    &manifest^.PathBuffer, // array
                    0, // byte
                )

                TlInsertAtTailList (
                    &fs^.ManifestListHead, // head
                    &manifest^.Entry, // entry
                )
            END

            TlInsertAtTailList (
                &fslisthead, // head
                &fs^.Entry, // entry
            )

        ELSEIF TlCompareStringWithMax ( arg, "-os:", 4 ) == 0 THEN
            arg += 4

            // Allocate os block.

            os : ^DutOsDescription

            status = TlBumpAlloc (
                SIZEOF DutOsDescription, // bytes
                OUT os, // ptr
            )

            IF status THEN
                TlInternalError ( "Failed to allocate os", 0, 0, 0 )
            END

            TlInitializeDynamicBuffer ( &os^.LabelFileName )
            TlInitializeDynamicBuffer ( &os^.BootstrapFileName )

            // Collect partition number.

            j = 0

            WHILE arg^ != ',' DO
                IF NOT arg^ THEN
                    TlError ( "-os: Syntax error\n" )
                END

                IF j == DUT_LABEL_MAX - 1 THEN
                    TlError ( "-os: Too many characters in part number\n" )
                END

                DutBuffer1[j] = arg^

                j += 1
                arg += 1
            END

            DutBuffer1[j] = 0

            IF NOT TlStringToNumber (
                &DutBuffer1[0], // src
                -1, // bufsize
                OUT os^.PartId, // num
            ) THEN
                TlError ( "-os: Bad partition number\n" )
            END

            arg += 1

            // Collect label file name.

            WHILE arg^ != ',' DO
                IF NOT arg^ THEN
                    TlError ( "-os: Syntax error\n" )
                END

                TlInsertDynamicBuffer (
                    &os^.LabelFileName, // array
                    arg^, // byte
                )

                j += 1
                arg += 1
            END

            TlInsertDynamicBuffer (
                &os^.LabelFileName, // array
                0, // byte
            )

            IF os^.LabelFileName.Count == 0 THEN
                TlError ( "-os: Syntax error\n" )
            END

            status = TlOpenSource (
                os^.LabelFileName.Buffer, // filename
                OUT os^.LabelFile, // handle
            )

            IF status THEN
                TlError ( "-os: Failed to open '%s'\n",
                    os^.LabelFileName.Buffer )
            END

            arg += 1

            // Collect bootstrap file name.

            WHILE arg^ != ',' DO
                IF NOT arg^ THEN
                    TlError ( "-os: Syntax error\n" )
                END

                TlInsertDynamicBuffer (
                    &os^.BootstrapFileName, // array
                    arg^, // byte
                )

                j += 1
                arg += 1
            END

            TlInsertDynamicBuffer (
                &os^.BootstrapFileName, // array
                0, // byte
            )

            IF os^.BootstrapFileName.Count == 0 THEN
                TlError ( "-os: Syntax error\n" )
            END

            status = TlOpenSource (
                os^.BootstrapFileName.Buffer, // filename
                OUT os^.BootstrapFile, // handle
            )

            IF status THEN
                TlError ( "-os: Failed to open '%s'\n",
                    os^.BootstrapFileName.Buffer )
            END

            arg += 1

            // Collect bootstrap sector offset.

            j = 0

            WHILE arg^ != ',' DO
                IF NOT arg^ THEN
                    TlError ( "-os: Syntax error\n" )
                END

                IF j == DUT_LABEL_MAX - 1 THEN
                    TlError ( "-os: Too many characters in boot offset\n" )
                END

                DutBuffer1[j] = arg^

                j += 1
                arg += 1
            END

            DutBuffer1[j] = 0

            IF NOT TlStringToNumber (
                &DutBuffer1[0], // src
                -1, // bufsize
                OUT os^.BootstrapSector, // num
            ) THEN
                TlError ( "-os: Bad bootstrap sector offset\n" )
            END

            arg += 1

            // Collect bootstrap length.

            j = 0

            WHILE arg^ DO
                IF j == DUT_LABEL_MAX - 1 THEN
                    TlError ( "-os: Too many characters in boot length\n" )
                END

                DutBuffer1[j] = arg^

                j += 1
                arg += 1
            END

            DutBuffer1[j] = 0

            IF NOT TlStringToNumber (
                &DutBuffer1[0], // src
                -1, // bufsize
                OUT os^.BootstrapLength, // num
            ) THEN
                TlError ( "-os: Bad bootstrap length\n" )
            END

            // Insert in list.

            TlInsertAtTailList (
                &oslisthead, // head
                &os^.Entry, // entry
            )

        ELSE
            DutUsage ()
        END

        i += 1
    END

    di := DutOpenDiskImage (
        imagename, // filename
        TRUE, // create
        sectors, // sectors
    )

    IF apt THEN
        DutPartitionDisk (
            di, // image
            &desclisthead, // desclisthead
            &DutBuffer2[0], // label
            bootfilehandle, // handle
        )

        IF NOT DutParsePartitionTable ( di ) THEN
            TlInternalError (
                "Failed to parse partition table we just made", 0, 0, 0 )
        END
    END

    IF fslisthead.Next != &fslisthead THEN
        // Create filesystems.

        DutCreateFilesystems (
            di, // image
            &fslisthead, // fslisthead
        )
    END

    IF oslisthead.Next != &oslisthead THEN
        // Make partitions bootable.

        DutMakeBootable (
            di, // image
            &oslisthead, // oslisthead
        )
    END
END

FN DutMountFromImageAndPart (
    IN imagename : ^UBYTE,
    IN partition : ^UBYTE,
) : ^DutMount

    partid : UWORD

    IF NOT TlStringToNumber (
        partition, // src
        -1, // bufsize
        OUT partid, // num
    ) THEN
        TlError ( "Bad partition number\n" )
    END

    di := DutOpenDiskImage (
        imagename, // filename
        FALSE, // create
        0, // sectors
    )

    IF partid != -1 THEN
        DutParsePartitionTable ( di )
    END

    volume := CAST DutFindPartitionById (
        di, // image
        partid, // id
    ) TO ^DutDiskCommon

    IF NOT volume THEN
        TlError ( "No such partition %d\n", partid )
    END

    mount := DutMountUnknownFilesystem ( volume )

    IF NOT mount THEN
        TlError ( "Failed to mount filesystem\n" )
    END

    RETURN mount
END

FN DutDumpInfo (
    IN imagename : ^UBYTE,
)

    TlInternalError ( "DutDumpInfo", 0, 0, 0 )
END

FN DutUpdate (
    IN imagename : ^UBYTE,
    IN partition : ^UBYTE,
    IN manifest : ^UBYTE,
)

    TlInternalError ( "DutUpdate", 0, 0, 0 )
END

FN DutUpdateFiles (
    IN imagename : ^UBYTE,
    IN partition : ^UBYTE,
    IN listfile : ^UBYTE,
)

    TlInternalError ( "DutUpdateFiles", 0, 0, 0 )
END

FN DutList (
    IN imagename : ^UBYTE,
    IN partition : ^UBYTE,
    IN path : ^UBYTE,
)

    mount := DutMountFromImageAndPart (
        imagename, // imagename
        partition, // partition
    )

    error : ^UBYTE

    file := DutOpenFile (
        mount, // mount
        path, // path
        FALSE, // create
        OUT error, // error
    )

    IF NOT file THEN
        TlError ( "%s: %s\n", path, error )
    END

    DutListFiles ( file )
END

FN DutRead (
    IN imagename : ^UBYTE,
    IN partition : ^UBYTE,
    IN path : ^UBYTE,
)

    mount := DutMountFromImageAndPart (
        imagename, // imagename
        partition, // partition
    )

    error : ^UBYTE

    file := DutOpenFile (
        mount, // mount
        path, // path
        FALSE, // create
        OUT error, // error
    )

    IF NOT file THEN
        TlError ( "%s: %s\n", path, error )
    END

    offset := 0

    WHILE TRUE DO
        len := DutReadFile (
            file, // file
            offset, // offset
            4096, // len
            &DutTemporaryBuffer[0], // buf
        )

        i := 0

        WHILE i < len DO
            TlPrint ( "%c", DutTemporaryBuffer[i] )
            i += 1
        END

        IF len < 4096 THEN
            BREAK
        END

        offset += 4096
    END

    DutCloseFile ( file )

    DutUnmountFilesystem ( mount )
END

FN DutWrite (
    IN imagename : ^UBYTE,
    IN partition : ^UBYTE,
    IN path : ^UBYTE,
    IN hostpath : ^UBYTE,
)

    handle : ^VOID

    status := TlOpenSource (
        hostpath, // path
        OUT handle, // handle
    )

    IF status THEN
        TlError ( "%s: Failed to open host file\n", hostpath )
    END

    mount := DutMountFromImageAndPart (
        imagename, // imagename
        partition, // partition
    )

    error : ^UBYTE

    file := DutOpenFile (
        mount, // mount
        path, // path
        TRUE, // create
        OUT error, // error
    )

    IF NOT file THEN
        TlError ( "%s: %s\n", path, error )
    END

    DutTruncateFile ( file )

    offset := 0

    WHILE TRUE DO
        len := TlReadFile (
            handle, // handle
            4096, // bytes
            &DutTemporaryBuffer[0], // buffer
        )

        IF len == 0 THEN
            BREAK
        END

        wrotelen := DutWriteFile (
            file, // file
            offset, // offset
            len, // len
            &DutTemporaryBuffer[0], // buf
        )

        IF wrotelen == 0xFFFFFFFF THEN
            TlError ( "I/O error\n" )
        END

        offset += 4096
    END

    DutCloseFile ( file )

    DutUnmountFilesystem ( mount )
END

FN DutDelete (
    IN imagename : ^UBYTE,
    IN partition : ^UBYTE,
    IN path : ^UBYTE,
)

    mount := DutMountFromImageAndPart (
        imagename, // imagename
        partition, // partition
    )

    error : ^UBYTE

    status := DutDeleteFile (
        mount, // mount
        path, // path
        OUT error, // error
    )

    IF NOT status THEN
        TlError ( "%s: %s\n", path, error )
    END

    DutUnmountFilesystem ( mount )
END

FN TlMain (
    IN argc : ULONG,
    IN argv : ^^UBYTE,
)

    // Dispatch to the correct command.

    IF argc < 2 THEN
        DutUsage ()
    END

    cmd := argv[1]

    IF TlCompareString ( cmd, "info" ) == 0 THEN
        DutDumpInfo ( argv[2] )

    ELSEIF TlCompareString ( cmd, "create" ) == 0 THEN
        IF argc < 4 THEN
            DutUsage ()
        END

        DutCreateImage ( argc, argv )

    ELSEIF TlCompareString ( cmd, "update" ) == 0 THEN
        IF argc != 5 THEN
            DutUsage ()
        END

        DutUpdate (
            argv[2], // imagename
            argv[3], // partition
            argv[4], // manifest
        )

    ELSEIF TlCompareString ( cmd, "updatefiles" ) == 0 THEN
        IF argc != 5 THEN
            DutUsage ()
        END

        DutUpdateFiles (
            argv[2], // imagename
            argv[3], // partition
            argv[4], // listfile
        )

    ELSEIF TlCompareString ( cmd, "ls" ) == 0 THEN
        IF argc != 5 THEN
            DutUsage ()
        END

        DutList (
            argv[2], // imagename
            argv[3], // partition
            argv[4], // path
        )

    ELSEIF TlCompareString ( cmd, "read" ) == 0 THEN
        IF argc != 5 THEN
            DutUsage ()
        END

        DutRead (
            argv[2], // imagename
            argv[3], // partition
            argv[4], // path
        )

    ELSEIF TlCompareString ( cmd, "write" ) == 0 THEN
        IF argc != 6 THEN
            DutUsage ()
        END

        DutWrite (
            argv[2], // imagename
            argv[3], // partition
            argv[4], // path
            argv[5], // hostpath
        )

    ELSEIF TlCompareString ( cmd, "delete" ) == 0 THEN
        IF argc != 5 THEN
            DutUsage ()
        END

        DutDelete (
            argv[2], // imagename
            argv[3], // partition
            argv[4], // path
        )

    ELSE
        DutUsage ()
    END
END